<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InPlay API: SPI device driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">InPlay API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___h_a_l___s_p_i.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI device driver<div class="ingroups"><a class="el" href="group___h_a_l.html">HAL driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>HAL_SPI.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab8662401ed15b6f5702950647dd774e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gab8662401ed15b6f5702950647dd774e2">spi_id</a> { <a class="el" href="group___h_a_l___s_p_i.html#ggab8662401ed15b6f5702950647dd774e2a73ea0e1ba419ed3296773558f1b66ea8">MSPI_ID</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#ggab8662401ed15b6f5702950647dd774e2a53c5ea397a943fcdd46cecb64617f6b8">SSPI0_ID</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#ggab8662401ed15b6f5702950647dd774e2a677c15f9f9a4d49760d735ecf901c625">SSPI1_ID</a>
 }</td></tr>
<tr class="memdesc:gab8662401ed15b6f5702950647dd774e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI ID.  <a href="group___h_a_l___s_p_i.html#gab8662401ed15b6f5702950647dd774e2">More...</a><br /></td></tr>
<tr class="separator:gab8662401ed15b6f5702950647dd774e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ed7a75d5d3def730827bf79a96424b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga27ed7a75d5d3def730827bf79a96424b">spi_fmt</a> { <a class="el" href="group___h_a_l___s_p_i.html#gga27ed7a75d5d3def730827bf79a96424ba83823c4e17ea1dd1ed689249030513fa">SPI_STD_FMT</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#gga27ed7a75d5d3def730827bf79a96424babe22e1577d2b0344604cc7fd62e63bc7">SPI_DUAL_FMT</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#gga27ed7a75d5d3def730827bf79a96424bae37c1ca66e8f770f9179e70cb84be183">SPI_QUAD_FMT</a>
 }</td></tr>
<tr class="memdesc:ga27ed7a75d5d3def730827bf79a96424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI format.  <a href="group___h_a_l___s_p_i.html#ga27ed7a75d5d3def730827bf79a96424b">More...</a><br /></td></tr>
<tr class="separator:ga27ed7a75d5d3def730827bf79a96424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6513c5c3389afe1c7aa12dedc75653e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gae6513c5c3389afe1c7aa12dedc75653e">spi_tmod</a> { <a class="el" href="group___h_a_l___s_p_i.html#ggae6513c5c3389afe1c7aa12dedc75653eabddf3ee3854f4bced120e3f5e5e0f9f2">SPI_TMOD_TX_AND_RX</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#ggae6513c5c3389afe1c7aa12dedc75653ea760e43c5f6bc804cb5940cf113b5c6ee">SPI_TMOD_TX_ONLY</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#ggae6513c5c3389afe1c7aa12dedc75653ea2d9ec2db5989585fc44a7506489615e9">SPI_TMOD_RX_ONLY</a>, 
<a class="el" href="group___h_a_l___s_p_i.html#ggae6513c5c3389afe1c7aa12dedc75653eaf0711e7f4b65198f25d909726b8c4577">SPI_TMOD_EEPROM_READ</a>
 }</td></tr>
<tr class="memdesc:gae6513c5c3389afe1c7aa12dedc75653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer mode.  <a href="group___h_a_l___s_p_i.html#gae6513c5c3389afe1c7aa12dedc75653e">More...</a><br /></td></tr>
<tr class="separator:gae6513c5c3389afe1c7aa12dedc75653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc684e45dc033c88af301fb218850a8"><td class="memItemLeft" align="right" valign="top"><a id="gaccc684e45dc033c88af301fb218850a8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8">spi_dfs_bit</a> </td></tr>
<tr class="memdesc:gaccc684e45dc033c88af301fb218850a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI data frame size. <br /></td></tr>
<tr class="separator:gaccc684e45dc033c88af301fb218850a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15319111e661191d82defc0a867dbba3"><td class="memItemLeft" align="right" valign="top"><a id="ga15319111e661191d82defc0a867dbba3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3">spi_err</a> </td></tr>
<tr class="memdesc:ga15319111e661191d82defc0a867dbba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI error code. <br /></td></tr>
<tr class="separator:ga15319111e661191d82defc0a867dbba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71988a616b32126cd2639005f1a9e579"><td class="memItemLeft" align="right" valign="top"><a id="ga71988a616b32126cd2639005f1a9e579"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga71988a616b32126cd2639005f1a9e579">spi_dir</a> </td></tr>
<tr class="memdesc:ga71988a616b32126cd2639005f1a9e579"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI DMA direction. <br /></td></tr>
<tr class="separator:ga71988a616b32126cd2639005f1a9e579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b11bb49a290b1398924813b20df59c"><td class="memItemLeft" align="right" valign="top"><a id="gad3b11bb49a290b1398924813b20df59c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gad3b11bb49a290b1398924813b20df59c">spi_mstr_cs</a> </td></tr>
<tr class="memdesc:gad3b11bb49a290b1398924813b20df59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI CS (master only) <br /></td></tr>
<tr class="separator:gad3b11bb49a290b1398924813b20df59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff84c0bc8f8eba94943af44c67282191"><td class="memItemLeft" align="right" valign="top"><a id="gaff84c0bc8f8eba94943af44c67282191"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gaff84c0bc8f8eba94943af44c67282191">qspi_cmd_width</a> </td></tr>
<tr class="memdesc:gaff84c0bc8f8eba94943af44c67282191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual or Quad SPI command width. <br /></td></tr>
<tr class="separator:gaff84c0bc8f8eba94943af44c67282191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cc3213327c2c278c338d795da5a025"><td class="memItemLeft" align="right" valign="top"><a id="ga35cc3213327c2c278c338d795da5a025"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga35cc3213327c2c278c338d795da5a025">qspi_addr_width</a> </td></tr>
<tr class="memdesc:ga35cc3213327c2c278c338d795da5a025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual or Quad SPI address width. <br /></td></tr>
<tr class="separator:ga35cc3213327c2c278c338d795da5a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4b6262ab656bde8034d503c1cad17d"><td class="memItemLeft" align="right" valign="top"><a id="ga4f4b6262ab656bde8034d503c1cad17d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga4f4b6262ab656bde8034d503c1cad17d">qspi_ttype</a> </td></tr>
<tr class="memdesc:ga4f4b6262ab656bde8034d503c1cad17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quad SPI command and address transfer type. <br /></td></tr>
<tr class="separator:ga4f4b6262ab656bde8034d503c1cad17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab995d7ea256e4c506fc772fd8ff5729e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gab995d7ea256e4c506fc772fd8ff5729e">hal_spi_open</a> (int id, int speed, int phase, int polarity, int prio)</td></tr>
<tr class="memdesc:gab995d7ea256e4c506fc772fd8ff5729e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the SPI driver.  <a href="#gab995d7ea256e4c506fc772fd8ff5729e">More...</a><br /></td></tr>
<tr class="separator:gab995d7ea256e4c506fc772fd8ff5729e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6e676fef4c3051926763022ce27c25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gacd6e676fef4c3051926763022ce27c25">hal_spi_close</a> (void *hdl)</td></tr>
<tr class="memdesc:gacd6e676fef4c3051926763022ce27c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the SPI driver.  <a href="#gacd6e676fef4c3051926763022ce27c25">More...</a><br /></td></tr>
<tr class="separator:gacd6e676fef4c3051926763022ce27c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac42b3e3e83048a16b37288b9d1778e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga6ac42b3e3e83048a16b37288b9d1778e">hal_spi_int_prio</a> (void *hdl, int prio)</td></tr>
<tr class="memdesc:ga6ac42b3e3e83048a16b37288b9d1778e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPI interrupt priority.  <a href="#ga6ac42b3e3e83048a16b37288b9d1778e">More...</a><br /></td></tr>
<tr class="separator:ga6ac42b3e3e83048a16b37288b9d1778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac99fe5227a1bd6f5f1f4ed3e9729f102"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gac99fe5227a1bd6f5f1f4ed3e9729f102">hal_spi_tx_non_block</a> (void *hdl, int cs, int dfs, void *buffer, uint16_t buffer_len, void *arg, void(*callback)(void *arg, int status, uint16_t size))</td></tr>
<tr class="memdesc:gac99fe5227a1bd6f5f1f4ed3e9729f102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI transmit function.  <a href="#gac99fe5227a1bd6f5f1f4ed3e9729f102">More...</a><br /></td></tr>
<tr class="separator:gac99fe5227a1bd6f5f1f4ed3e9729f102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf453270595e780b99153327e633242"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gadbf453270595e780b99153327e633242">hal_spi_rx_non_block</a> (void *hdl, int cs, int dfs, void *buffer, uint16_t buffer_len, void *arg, void(*callback)(void *arg, int status, uint16_t size))</td></tr>
<tr class="memdesc:gadbf453270595e780b99153327e633242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI Receive function.  <a href="#gadbf453270595e780b99153327e633242">More...</a><br /></td></tr>
<tr class="separator:gadbf453270595e780b99153327e633242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461b8e686bd08d2957a2d37d4b44a763"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga461b8e686bd08d2957a2d37d4b44a763">hal_spi_trx_non_block</a> (void *hdl, int cs, int dfs, void *wbuf, void *rbuf, uint16_t buf_len, void *arg, void(*callback)(void *arg, int status, uint16_t actual_size))</td></tr>
<tr class="memdesc:ga461b8e686bd08d2957a2d37d4b44a763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI Transmit and Receive function (bi-direction)  <a href="#ga461b8e686bd08d2957a2d37d4b44a763">More...</a><br /></td></tr>
<tr class="separator:ga461b8e686bd08d2957a2d37d4b44a763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329448e642abc4a8b6da531f5303b383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga329448e642abc4a8b6da531f5303b383">hal_spi_tx_dma</a> (void *hdl, int cs, void *buffer, uint16_t buffer_len, uint16_t *actual_size)</td></tr>
<tr class="memdesc:ga329448e642abc4a8b6da531f5303b383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI transmit DMA function.  <a href="#ga329448e642abc4a8b6da531f5303b383">More...</a><br /></td></tr>
<tr class="separator:ga329448e642abc4a8b6da531f5303b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46b4e0d2f43e388edddc36ed3f39b90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gaf46b4e0d2f43e388edddc36ed3f39b90">hal_spi_rx_dma</a> (void *hdl, int cs, void *buffer, uint16_t buffer_len, uint16_t *actual_size)</td></tr>
<tr class="memdesc:gaf46b4e0d2f43e388edddc36ed3f39b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI Receive DMA function.  <a href="#gaf46b4e0d2f43e388edddc36ed3f39b90">More...</a><br /></td></tr>
<tr class="separator:gaf46b4e0d2f43e388edddc36ed3f39b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644cbbf8dd4ac4deec9a10a1e05ccfa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga644cbbf8dd4ac4deec9a10a1e05ccfa4">hal_spi_trx_dma</a> (void *hdl, int cs, void *wbuf, void *rbuf, uint16_t buffer_len, uint16_t *actual_size)</td></tr>
<tr class="memdesc:ga644cbbf8dd4ac4deec9a10a1e05ccfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI Transmit and Receive DMA function (bi-direction)  <a href="#ga644cbbf8dd4ac4deec9a10a1e05ccfa4">More...</a><br /></td></tr>
<tr class="separator:ga644cbbf8dd4ac4deec9a10a1e05ccfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5506696dd2ad49c072eded08829c3dab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga5506696dd2ad49c072eded08829c3dab">hal_slv_spi_tx</a> (void *hdl, int phase, int polarity, int dfs, void *buf, uint16_t buf_len, uint16_t *wlen)</td></tr>
<tr class="memdesc:ga5506696dd2ad49c072eded08829c3dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave SPI transmit function.  <a href="#ga5506696dd2ad49c072eded08829c3dab">More...</a><br /></td></tr>
<tr class="separator:ga5506696dd2ad49c072eded08829c3dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829386e115dea84ab3ad2abfc58cf331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga829386e115dea84ab3ad2abfc58cf331">hal_slv_spi_rx</a> (void *hdl, int phase, int polarity, int dfs, void *buf, uint16_t buf_len, uint16_t *rlen)</td></tr>
<tr class="memdesc:ga829386e115dea84ab3ad2abfc58cf331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave SPI Receive function.  <a href="#ga829386e115dea84ab3ad2abfc58cf331">More...</a><br /></td></tr>
<tr class="separator:ga829386e115dea84ab3ad2abfc58cf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65b45b1971eb5df7bba78ac90ddbe26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gac65b45b1971eb5df7bba78ac90ddbe26">hal_slv_spi_trx</a> (void *hdl, int phase, int polarity, int dfs, void *wbuf, void *rbuf, uint16_t buf_len, uint16_t *wlen, uint16_t *rlen)</td></tr>
<tr class="memdesc:gac65b45b1971eb5df7bba78ac90ddbe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave SPI Transmit and Receive function (bi-direction)  <a href="#gac65b45b1971eb5df7bba78ac90ddbe26">More...</a><br /></td></tr>
<tr class="separator:gac65b45b1971eb5df7bba78ac90ddbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63b0f1180cb61eac2a1f1db68f97773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gae63b0f1180cb61eac2a1f1db68f97773">hal_slv_spi_stop</a> (void *hdl)</td></tr>
<tr class="memdesc:gae63b0f1180cb61eac2a1f1db68f97773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave SPI stop function.  <a href="#gae63b0f1180cb61eac2a1f1db68f97773">More...</a><br /></td></tr>
<tr class="separator:gae63b0f1180cb61eac2a1f1db68f97773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7dcbafcf3c30c059e4e9c52843f7b6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gaf7dcbafcf3c30c059e4e9c52843f7b6b">hal_spi_busy</a> (void *hdl)</td></tr>
<tr class="memdesc:gaf7dcbafcf3c30c059e4e9c52843f7b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPI busy status.  <a href="#gaf7dcbafcf3c30c059e4e9c52843f7b6b">More...</a><br /></td></tr>
<tr class="separator:gaf7dcbafcf3c30c059e4e9c52843f7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bb740ff18ad1ddad2e2ba6afd9c82c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#ga00bb740ff18ad1ddad2e2ba6afd9c82c">hal_spi_trx_dma_chain_start</a> (void *hdl, int cs, int speed, int phase, int polarity, int dfs, void *wbuf[2], void *rbuf[2], uint16_t buffer_len, void *arg, void(*callback)(void *arg, int dir, int id, int status))</td></tr>
<tr class="memdesc:ga00bb740ff18ad1ddad2e2ba6afd9c82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master SPI Transmit and Receive DMA block chain function (bi-direction)  <a href="#ga00bb740ff18ad1ddad2e2ba6afd9c82c">More...</a><br /></td></tr>
<tr class="separator:ga00bb740ff18ad1ddad2e2ba6afd9c82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa124c5efb9e6c78c6780601241aab562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___s_p_i.html#gaa124c5efb9e6c78c6780601241aab562">hal_spi_trx_dma_chain_stop</a> (void *hdl)</td></tr>
<tr class="memdesc:gaa124c5efb9e6c78c6780601241aab562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master or Slave SPI Transmit and Receive DMA block chain function (bi-direction)  <a href="#gaa124c5efb9e6c78c6780601241aab562">More...</a><br /></td></tr>
<tr class="separator:gaa124c5efb9e6c78c6780601241aab562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>HAL_SPI. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga27ed7a75d5d3def730827bf79a96424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ed7a75d5d3def730827bf79a96424b">&#9670;&nbsp;</a></span>spi_fmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_a_l___s_p_i.html#ga27ed7a75d5d3def730827bf79a96424b">spi_fmt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga27ed7a75d5d3def730827bf79a96424ba83823c4e17ea1dd1ed689249030513fa"></a>SPI_STD_FMT&#160;</td><td class="fielddoc"><p>Standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga27ed7a75d5d3def730827bf79a96424babe22e1577d2b0344604cc7fd62e63bc7"></a>SPI_DUAL_FMT&#160;</td><td class="fielddoc"><p>Dual format with 2 data wire. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga27ed7a75d5d3def730827bf79a96424bae37c1ca66e8f770f9179e70cb84be183"></a>SPI_QUAD_FMT&#160;</td><td class="fielddoc"><p>Quad format with 4 data wire. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab8662401ed15b6f5702950647dd774e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8662401ed15b6f5702950647dd774e2">&#9670;&nbsp;</a></span>spi_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_a_l___s_p_i.html#gab8662401ed15b6f5702950647dd774e2">spi_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI ID. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab8662401ed15b6f5702950647dd774e2a73ea0e1ba419ed3296773558f1b66ea8"></a>MSPI_ID&#160;</td><td class="fielddoc"><p>Master SPI Id. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab8662401ed15b6f5702950647dd774e2a53c5ea397a943fcdd46cecb64617f6b8"></a>SSPI0_ID&#160;</td><td class="fielddoc"><p>Slave SPI Id. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab8662401ed15b6f5702950647dd774e2a677c15f9f9a4d49760d735ecf901c625"></a>SSPI1_ID&#160;</td><td class="fielddoc"><p>Slave SPI Id. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae6513c5c3389afe1c7aa12dedc75653e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6513c5c3389afe1c7aa12dedc75653e">&#9670;&nbsp;</a></span>spi_tmod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_a_l___s_p_i.html#gae6513c5c3389afe1c7aa12dedc75653e">spi_tmod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae6513c5c3389afe1c7aa12dedc75653eabddf3ee3854f4bced120e3f5e5e0f9f2"></a>SPI_TMOD_TX_AND_RX&#160;</td><td class="fielddoc"><p>Transfer in bi-direction mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae6513c5c3389afe1c7aa12dedc75653ea760e43c5f6bc804cb5940cf113b5c6ee"></a>SPI_TMOD_TX_ONLY&#160;</td><td class="fielddoc"><p>Tranfer in TX mode only. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae6513c5c3389afe1c7aa12dedc75653ea2d9ec2db5989585fc44a7506489615e9"></a>SPI_TMOD_RX_ONLY&#160;</td><td class="fielddoc"><p>Transfer in RX mode only. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae6513c5c3389afe1c7aa12dedc75653eaf0711e7f4b65198f25d909726b8c4577"></a>SPI_TMOD_EEPROM_READ&#160;</td><td class="fielddoc"><p>Transfer in EEPROM. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga829386e115dea84ab3ad2abfc58cf331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829386e115dea84ab3ad2abfc58cf331">&#9670;&nbsp;</a></span>hal_slv_spi_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_slv_spi_rx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave SPI Receive function. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>SPI slave can receive multiple uint within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The RX buffer length. <br />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rlen</td><td>Actual RX length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gae63b0f1180cb61eac2a1f1db68f97773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63b0f1180cb61eac2a1f1db68f97773">&#9670;&nbsp;</a></span>hal_slv_spi_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hal_slv_spi_stop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave SPI stop function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac65b45b1971eb5df7bba78ac90ddbe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac65b45b1971eb5df7bba78ac90ddbe26">&#9670;&nbsp;</a></span>hal_slv_spi_trx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_slv_spi_trx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave SPI Transmit and Receive function (bi-direction) </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbuf</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The TX and RX buffer length. <br />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wlen</td><td>Actual TX length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rlen</td><td>Actual RX length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga5506696dd2ad49c072eded08829c3dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5506696dd2ad49c072eded08829c3dab">&#9670;&nbsp;</a></span>hal_slv_spi_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_slv_spi_tx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave SPI transmit function. </p>
<p>Experimental slave SPI API <br />
 </p><dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The TX buffer length. <br />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wlen</td><td>Actual TX length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gaf7dcbafcf3c30c059e4e9c52843f7b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7dcbafcf3c30c059e4e9c52843f7b6b">&#9670;&nbsp;</a></span>hal_spi_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_busy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPI busy status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if busy, otherwise 0 </dd></dl>

</div>
</div>
<a id="gacd6e676fef4c3051926763022ce27c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd6e676fef4c3051926763022ce27c25">&#9670;&nbsp;</a></span>hal_spi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the SPI driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga6ac42b3e3e83048a16b37288b9d1778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac42b3e3e83048a16b37288b9d1778e">&#9670;&nbsp;</a></span>hal_spi_int_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_int_prio </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPI interrupt priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Interrupt priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>in_irq.h.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gab995d7ea256e4c506fc772fd8ff5729e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab995d7ea256e4c506fc772fd8ff5729e">&#9670;&nbsp;</a></span>hal_spi_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hal_spi_open </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the SPI driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The SPI ID, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gab8662401ed15b6f5702950647dd774e2" title="SPI ID. ">spi_id</a>. <br />
 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the SPI driver, NULL means open failed. </dd></dl>

</div>
</div>
<a id="gaf46b4e0d2f43e388edddc36ed3f39b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46b4e0d2f43e388edddc36ed3f39b90">&#9670;&nbsp;</a></span>hal_spi_rx_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_rx_dma </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>actual_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI Receive DMA function. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>SPI slave can receive multiple uint within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for master SPI and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The RX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gadbf453270595e780b99153327e633242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf453270595e780b99153327e633242">&#9670;&nbsp;</a></span>hal_spi_rx_non_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_rx_non_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, int status, uint16_t size)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI Receive function. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>SPI slave can receive multiple uint within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for master SPI and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The RX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga644cbbf8dd4ac4deec9a10a1e05ccfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644cbbf8dd4ac4deec9a10a1e05ccfa4">&#9670;&nbsp;</a></span>hal_spi_trx_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_trx_dma </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>actual_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI Transmit and Receive DMA function (bi-direction) </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for master SPI and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbuf</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The TX and RX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga00bb740ff18ad1ddad2e2ba6afd9c82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00bb740ff18ad1ddad2e2ba6afd9c82c">&#9670;&nbsp;</a></span>hal_spi_trx_dma_chain_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_trx_dma_chain_start </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>wbuf</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rbuf</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, int dir, int id, int status)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master SPI Transmit and Receive DMA block chain function (bi-direction) </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This is to start the DMA block chaining. The SPI's TX/RX FIFO will be automatically filled/emptied by the DMA.</li>
<li>While user handles the ping buffer, the DMA will handle the pong buffer</li>
</ol>
<ol type="1">
<li>The ping/pong scheme will continuously transfer data to/from slave which means the slave selected signal will be always low. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for master SPI and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>The ping/pong buffers pointer array for the TX. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbuf</td><td>The ping/pong buffer pointer array for the RX. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The ping/pong buffer size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The user provided argument for the ping/pong completed call back function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The user provided ping/pong completed call back function:</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gaa124c5efb9e6c78c6780601241aab562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa124c5efb9e6c78c6780601241aab562">&#9670;&nbsp;</a></span>hal_spi_trx_dma_chain_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_trx_dma_chain_stop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI Transmit and Receive DMA block chain function (bi-direction) </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Stop the DMA block chaining.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga461b8e686bd08d2957a2d37d4b44a763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga461b8e686bd08d2957a2d37d4b44a763">&#9670;&nbsp;</a></span>hal_spi_trx_non_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_trx_non_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, int status, uint16_t actual_size)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI Transmit and Receive function (bi-direction) </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
 </li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for master SPI and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rbuf</td><td>The void pointer point to the RX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>The TX and RX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="ga329448e642abc4a8b6da531f5303b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329448e642abc4a8b6da531f5303b383">&#9670;&nbsp;</a></span>hal_spi_tx_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_tx_dma </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>actual_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI transmit DMA function. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for SPI master and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The TX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
<a id="gac99fe5227a1bd6f5f1f4ed3e9729f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac99fe5227a1bd6f5f1f4ed3e9729f102">&#9670;&nbsp;</a></span>hal_spi_tx_non_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_tx_non_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, int status, uint16_t size)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master or Slave SPI transmit function. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For SPI slave transmit, the master needs to provide the "Slave Select" signal. The SPI slave will transmit one unit (could be byte, short, or long depends on the data frame size) out per "Slave Select" signal. SPI slave can't do multiple transfer within one "Slave Select" signal.</li>
<li>SPI slave can only support speed up to D0 clock divided by 4. If D0 clock is 32 Mhz, then SPI master speed has to be less or equal to 8 Mhz. <br />
</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>The handle from the "open" function call. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>The SPI slave select. This is only valid for SPI master and the possible value are 0 or 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>The SPI serial clock rate. They can be 16, 8, 4, 2, or 1 Mhz. Only for master. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>The SPI clock phase. 0: first edge of SPI clock, 1: trailing edge of SPI clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polarity</td><td>The SPI clock polarity. 0: rising, 1: falling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dfs</td><td>The data frame size, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#gaccc684e45dc033c88af301fb218850a8" title="SPI data frame size. ">spi_dfs_bit</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The void pointer point to the TX buffer. This pointer, depends on the data frame size, will be cast by the driver to byte, short, or long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_len</td><td>The TX buffer length. <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPI_ERR_OK if successful, otherwise failed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="group___h_a_l___s_p_i.html#ga15319111e661191d82defc0a867dbba3" title="SPI error code. ">spi_err</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
