[{"id":0,"href":"/docs/in6xxe/api.html","title":"API Doc","section":"IN6XXE","content":"API Doc\n"},{"id":1,"href":"/docs/in6xxe/getting-started/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Getting Started","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:\nTerminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\\tools\\ InPlayToolsSetup.exe, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, JLink will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":2,"href":"/docs/in6xxe/samples/adc-example-guide.html","title":"Adc Example Guide","section":"Samples","content":" ADC Example Guide # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_adc in-dev/proj/driver/proj_drv_adc Configuration # #define FORCE_MODE 1 //0: auto mode, 1: force mode Define whether choose force mode or not.\n#define FORCE_MODE_SAMPLE_NUM 16 #define AUTO_MODE_SAMPLE_NUM 16 Define the sample num in adc test.\n#define DISCARD_NUM 0 ///\u0026lt; skip adc sample number Define the sample num need to be discarded.\n#define CH_NUM 4 Define the adc test total channel num.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of sample value, test content and value according to UART Log. The following are samples: VBAT ch:14 =0xab3 3294.8mV,\ntest content: VBAT/Temperature/...\nchosen channel: ch:...\nmeasurement value: =0x...\nconverted value: here is 3294,8mV\nMore information may be found in debug guide page.\nTest Steps # force mode\nOpen Keil and set FORCE_MODE to be 1, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. auto mode\nOpen Keil and set FORCE_MODE to be 0, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. "},{"id":3,"href":"/docs/in6xxe/samples/aes-example-guide.html","title":"AES Example Guide","section":"Samples","content":" AES Example Guide # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.\nAES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted. AES encryption has three modes: ECB (Electronic Codebook), CBC (Cipher Block Chaining), and CFB (Cipher Feedback).\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_aes in-dev/proj/driver/proj_drv_aes Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of encryption to UART Log. If test pass, ...passed or ... successed will be shown on UART log.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil, download proj_drv_aes. Press the reset button and observe the log for the message main start.... The status of encryption will be shown on UART log. "},{"id":4,"href":"/docs/in6xxe/samples/ble-advertising-example-guide.html","title":"Ble Advertising Example Guide","section":"Samples","content":" Bluetooth Advertising Example Guide # Overview # Bluetooth advertising is based on the transmission of advertising packets. An advertising packet is a small amount of data that contains device identifiers and other relevant information. The transmission of advertising packets is connectionless, meaning that it does not require pairing or connection operations before establishing a Bluetooth connection.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_adv_conn in-dev/proj/BLE/proj_ble_adv_conn Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_adv_conn. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. We can search for the device with the corresponding address on a Bluetooth device. If we have two development boards, we can download the proj_ble_init project on another board. The board with proj_ble_init can automatically connect to the board with proj_ble_adv_conn. "},{"id":5,"href":"/docs/in6xxe/samples/ble-initiation-example-guide.html","title":"Ble Initiation Example Guide","section":"Samples","content":" Ble initiation Routine Guide # Overview # The Bluetooth connection initiation mode refers to the method utilized by a Bluetooth device to proactively initiate a connection with other devices. Within Bluetooth communication, there are typically two connection modes: Central and Peripheral. The Central mode represents the party that takes the initiative in establishing the connection, whereas the Peripheral mode signifies the party that passively accepts the connection.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_init in-dev/proj/BLE/proj_ble_init Debug # We can get the status of development board according to Uart Log. The following are samples,\nCentral # start initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nPeripheral # start advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_init (Central), and on another development board, download proj_ble_adv_conn (Peripheral).\nPress the reset button on the central board and the peripheral board, observe the text CHIP ID = appear in the log, and begin scanning based on the settings in in_config.h.\nWhen scanning for devices with the Peripheral address, the Central will initiate a connection request to the Peripheral, and the Peripheral will accept the connection request, establishing a Bluetooth connection.\n"},{"id":6,"href":"/docs/in6xxe/samples/ble-scan-example-guide.html","title":"Ble Scan Example Guide","section":"Samples","content":" Bluetooth Scan Example Guide # Overview # In Bluetooth Low Energy (BLE), scanning is the process where a BLE central device (such as a smartphone or a BLE-enabled gateway) actively searches and listens for advertising packets from nearby BLE peripheral devices. The scanning process allows the central device to discover and connect to nearby peripherals.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_scan in-dev/proj/BLE/proj_ble_scan Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart scan process: start scan get advertising data from other BLE device: *** ADV DATA FROM...*** , ...means the address of other device. More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_scan. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. After device scanning start, we can get advertising data from other BLE device. "},{"id":7,"href":"/docs/in6xxe/samples/ble-transparent-transmission-example-guide.html","title":"Ble Transparent Transmission Example Guide","section":"Samples","content":" BLE Transparent Transmission Guide # Overview # In Bluetooth data transparent transmission, the sending device packages the raw data into Bluetooth data packets and sends them to the receiving device through the Bluetooth connection. After receiving these data packets, the receiving device can directly read and parse the raw data without any decoding or processing.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_trx_clt\u0026amp;proj_ble_trx_svc in-dev/proj/BLE/proj_ble_trx_clt\u0026amp;proj_ble_trx_svc Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both central and peripheral according to Uart Log. The following are samples,\nCentral # start scan process Scan start\nstart initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nReceive data TRX RX: len=...\nPeripheral # start advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... More information may be found in debug guide page.\nTest Steps # Using a Single Development Board Download and run the proj_ble_trx_svc project. The development board starts Bluetooth broadcasting, allowing the Bluetooth device to search and find the broadcast data. The Bluetooth device initiates a connection request. After a successful connection, we can view the address information of the Bluetooth device on the Terminal Emulator. The Bluetooth device sends a write request to the development board. The developer inputs data on the Terminal Emulator and sends it. The development board transmits data to the Bluetooth device, which will display the same data content upon receiving it. Using Two Development Boards Central downloads the proj_ble_trx_clt, while Peripheral downloads the proj_ble_trx_svc. Reset Central device and Peripheral device. Peripheral development board starts Bluetooth broadcasting, allowing Central to search and find the broadcast data. Central initiates a connection request. After a successful connection, we can view the address information of the other party on Uart log. On the client side of the Uart, input data and send it. The client sends a write request to the server, and the server receives the same data. The developer on the Peripheral side inputs data and sends it. Peripheral transmits data to the Central, which will display the same data content upon receiving it. "},{"id":8,"href":"/docs/in6xxe/samples/debug-routine-guide.html","title":"Debug Routine Guide","section":"Samples","content":" Debug reference # Configuration and Connection during Debug # To connect with the IN628E, we should use a terminal emulator with following setting,\nPort: according to your device.\nBaud Rate: 115200.\nData bits: 8.\nStop bits: 1.\nParity: None.\nFlow control: None.\nUART Tx Pin: default is GPIO_2_1.\nUART Rx Pin: default is GPIO_2_7.\n"},{"id":9,"href":"/docs/in6xxe/samples/ecc-example-guide.html","title":"Ecc Example Guide","section":"Samples","content":" ECC Guide # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_ECC in-dev/proj/drv/proj_drv_ECC Debug # We can get the status of development board according to Uart Log. The following are samples,\nverify success: Verify OK More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_drv_ECC\nPress the reset button on the board and the peripheral board, observe the text CHIP ID = appear in the log.\nVerify the data using ECC. If verify success, text Verify OK will appear in the log.\n"},{"id":10,"href":"/docs/in6xxe/samples/gpio-example-guide.html","title":"Gpio Example Guide","section":"Samples","content":" GPIO Example Guide # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.\nIn this example, we can achieve basic input and output functionality using GPIO.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.\n#define KEY_PORT 2 #define KEY_PIN 3 Define the GPIO input port and pin.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nLED cycle flashing when the GPIO_2_3 put up, the message KEY up will be printed. More information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO output pin and input pin, then download proj_drv_GPIO. Press the reset button and observe the log for the message CHIP ID =. Repeat the LED on/off cycle. If the GPIO input pin is high, the message KEY up will be printed. "},{"id":11,"href":"/docs/in6xxe/samples/gpio-interrupt-example-guide.html","title":"Gpio Interrupt Example Guide","section":"Samples","content":" GPIO Interrupt Example Guide # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.\n#define GPIO_INTERRUPT_EDGE RISE_EDGE Define the edge-trigger signal for GPIO interrupts, including RISE_EDGE and FALL_EDGE. RISE_EDGE represents an interrupt when the GPIO input has a rising edge, while FALL_EDGE represents an interrupt when the GPIO input has a falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur rise:... fall:... wup:... mains the gpio interrupt source. More information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO interrupt pin. Download the proj_drv_gpio_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, rise:... fall:... wup:... will be printed. In this example, due to the presence of the mask function in the callback, the interrupt will only be triggered once. "},{"id":12,"href":"/docs/in6xxe/samples/gpio-reset-example-guide.html","title":"Gpio Reset Example Guide","section":"Samples","content":" GPIO Reset Example Guide # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_reset in-dev/proj/driver/proj_drv_gpio_reset Configuration # #define GPIO_RESET_TEST_PORT 1 #define GPIO_RESET_TEST_PIN 2 Define the GPIO reset port and pin.\n#define RESET_EDGE RISING_EDGE Define the triggering of a GPIO reset signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. 1 means rising edge, 0 means falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nWaiting for reset signals: Input pin is GPIO1_2 Wait for falling edge to trigger PD1 reset reset success:CHIP ID = ...\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO reset pin and edge, then download proj_drv_GPIO_RESET. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that we reset development board suceess. "},{"id":13,"href":"/docs/in6xxe/samples/gpio-wake-example-guide.html","title":"Gpio Wake Example Guide","section":"Samples","content":" GPIO Wake Example Guide # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.\n#define WUP_TRIGGER FALLING_EDGE // wake up source Define the triggering of a GPIO wake signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. The following enum is the mode can be chosen\nenum{ HIGH, LOW, RISING_EDGE, FALLING_EDGE, BOTH_EDGE, }; Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nPower down: power down Wake up:power up src=23. number 23 means wake-up source, we can find its meaning in pm_ws.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO wake-up pin and edge, then download proj_drv_gpio_wuk. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that development board wake up successfully. "},{"id":14,"href":"/docs/in6xxe/samples/gpio-wake-up-interrupt-example-guide.html","title":"Gpio Wake Up Interrupt Example Guide","section":"Samples","content":" GPIO Wake Interrupt Example Guide # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk_interrupt in-dev/proj/driver/proj_drv_gpio_wuk_interrupt Configuration # #define PORT 2 #define PIN 3 Define the port and pin for testing GPIO wake-up and interrupts.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur interrupt occur\nWake up power up src=\nPower down power down\nMore information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO wake-up and interrupt pin. Download the proj_drv_gpio_wuk_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, power up src=andinterrupt occur will be printed. "},{"id":15,"href":"/docs/in6xxe/samples/i2c-example-guide.html","title":"I2 C Example Guide","section":"Samples","content":" I2C Routine Guide # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.\nThis routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication. It enables serial communication of data between different development boards. The UART port prints the LOG, showing the data transmission and retrieval between the I2C Master and I2C Slave.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_I2C in-dev/proj/driver/proj_drv_I2C Configuration # #define TEST_CASE I2C_TEST_MASTER_XFER_BLOCKING_READ You can change the operation mode.\nAvailable modes for Master # I2C_TEST_MASTER_XFER_BLOCKING_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_READ I2C_TEST_MASTER_XFER_POLL_READ I2C_TEST_MASTER_XFER_BLOCKING_WRITE I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE I2C_TEST_MASTER_XFER_POLL_WRITE I2C_TEST_MASTER_XFER_BLOCKING_WRITE_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE_READ I2C_TEST_MASTER_XFER_POLL_WRITE_READ I2C_TEST_MASTER_XFER_ASYNC Slave mode # I2C_TEST_SLAVE_XFER #define I2C_SLAVE_ADDR 0x14 Set the address of the slave device in I2C communication.\n#define I2C_SPEED I2C_SPEED_100K Set the speed of the I2C communication.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both master and slave according to Uart Log and LED.\nWhen we transmit or receive data, we can get information on uart log. More information may be found in debug guide page.\nTest Steps # Master Setup and Download Open Keil, change the selected mode to master, compile, and download the project. Press the reset button and observe the LOG to see the text \u0026ldquo;master_xfer_blocking_read dma_en=0\u0026rdquo;, which represents the selected mode. Slave Setup and Download Open Keil, change the selected mode to slave, compile, and download the project. Press the reset button and observe the LOG to see the text which represents the selected mode., Testing Reset the slave first, then reset the master. We can see the data appearing in the LOG based on the selected mode of the master. After resetting both the slave and the master, we can observe the data appearing in the LOG based on the selected mode of the master. "},{"id":16,"href":"/docs/in6xxe/samples/keyboard-example-guide.html","title":"Keyboard Example Guide","section":"Samples","content":" Keyboard Routine Guide # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_keyboard in-dev/proj/driver/proj_drv_keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of keyboard on uart log.\npress button: press key: row:... col:... release button: release row:... col:... More information may be found in debug guide page.\nTest Steps # Open Keil and download the proj_drv_keyboard project. Press the reset button and observe the log for the text CHIP ID =. Press the button, we will get the status press button . After that, we release the button, we will get the status release button "},{"id":17,"href":"/docs/in6xxe/samples/pwm-example-guide.html","title":"Pwm Example Guide","section":"Samples","content":" PWM Routine Guide # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.\nThis routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_pwm in-dev/proj/driver/proj_drv_pwm Configuration # #define PWM0_PERIOD_USEC 10000 Define the PWM period for PWM0.\n#define PWM0_HIGH_USEC 5000 Define the duration of the high level for PWM0.\n#define PWM4_PERIOD_USEC 10000 Define the PWM period for PWM4.\n#define PWM4_HIGH_USEC 3000 Define the duration of the high level for PWM4.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to terminal emulator.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;input any key to pause PWM\u0026rdquo; appearing in the log. This indicates that the PWM has started. Use a logic analyzer or an oscilloscope to connect to GPIO_0_0 (pwm0) and GPIO_1_8 (pwm4) to observe the corresponding square waves with the specified period and duty cycle. "},{"id":18,"href":"/docs/in6xxe/samples/qdec-routine-guide.html","title":"Qdec Routine Guide","section":"Samples","content":" QDEC Routine Guide # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.\nThis routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).\nThe LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_qdec in-dev/proj/driver/proj_drv_qdec Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # The LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nMore information may be found in debug guide page.\nConnection # Connect the VCC and GND of IN6xxE to the qdec board. Then, connect GPIO_1_3 to cha-x-0, GPIO_1_6 to chb-x-0, and GPIO_2_3 to idx-x-0.\nTest Steps # Open Keil and download the proj_drv_qdec project. Press the K1 button and observe the text main start... appearing in the log. Rotate the rotary encoder in the forward direction. The count will increase, and the text cnt is 0x... will be displayed. Note: Connecting GP13 to chb_x_0 and GP16 to cha_x_0 will not affect the program\u0026rsquo;s operation but will change the direction determination during the rotary encoder rotation.\n"},{"id":19,"href":"/docs/in6xxe/samples/timer-routine-guide.html","title":"Timer Routine Guide","section":"Samples","content":" TIMER Routine Guide # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.\nThis routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_timer in-dev/proj/driver/proj_drv_timer Configuration # #define TEST_CASE SIMPLE_TIMER_ONCE After displaying \u0026ldquo;Select a number to test:\u0026rdquo; on the log, you can input a number between 0 and 2 to select a mode, including:\nenum { SIMPLE_TIMER_ONCE = 0, SIMPLE_TIMER_RELOAD, TIMER_EMIT, TIMER_CAPTURE, TIMER_MANUAL, };\tSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\n#define TMR_ID TMR0_ID Select the TMR ID to be used. This configuration is only effective for SIMPLE_TIMER_ONCE and SIMPLE_TIMER_RELOAD in the TEST CASE.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log.\nSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text test case: %d on the log, where %d represents the selected mode. Simple Timer Example: Depending on whether it is RELOAD or not, the callback may or may not appear repeatedly. If it is ONCE, it will stop after tmr cb. Emit \u0026amp; Capture: Two IN628E boards are required for testing. Download the emit program to Board 1 and the capture program to Board 2. After downloading, connect the signal pins (GPIO_2_7, GPIO_2_8, or GPIO_2_2) of Board 1 to the receiving signal pin (GPIO_0_3) of Board 2. Reset both boards simultaneously to receive signals on Board 2. "},{"id":20,"href":"/docs/in6xxe/samples/trigger-example-guide.html","title":"Trigger Example Guide","section":"Samples","content":" Trigger Routine Guide # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger. Three types of priority can be chosen, TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE.\n#define OUTPUT_PORT 0 #define OUTPUT_PIN 1 define the output pin.\n#define TIRG_COND_PORT 0 #define TIRG_COND_PIN 3 define the trigger condition pin.\n#define DEBUG_PORT 0 #define DEBUG_PIN 4 define the debug pin.\n#define TEST_OUTPUT_CMD 0 //test output #define TEST_REG_WR_CMD 0 //test register write #define TEST_TIMER_CMD 1 //test set timer and wait timer #define TEST_REG_CP_CMD 0 //test compare the value in register #define TEST_REG_MASK_CP_CMD 0 //test mask compare the value in register #define TEST_REG_RW_CMD 0 //test register read and write #define TEST_RD_CMP_CMD_WAIT 0 // //test read and compare the value in register(wait) #define TEST_RD_CMP_CMD_NO_WAIT 0 //test read and compare the value in register(not wait) Change the operation mode.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the trigger interrupt status on UART log.\nTEST_OUTPUT_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, it will output a high or low voltage level on the output pin based on whether it\u0026rsquo;s a rising or falling edge.\nTEST_REG_WR_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, value set will be written to register.\nTEST_TIMER_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, timer will be set, start and then stop.\nTEST_REG_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address.\nTEST_REG_MASK_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address with mask.\nTEST_REG_RW_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, read and write the register.\nTEST_RD_CMP_CMD_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nTEST_RD_CMP_CMD_NO_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nMore information may be found in debug guide page.\n​\nTest Steps # Open Keil and select the desired functionality, then download proj_drv_trig. Press the K1 button and observe the text \u0026ldquo;main start\u0026rdquo; appearing in the log. When the trigger pin is triggered, you will see something like \u0026ldquo;irq 0x5\u0026rdquo; in Figure 1-1, where 5 represents the status. At the same time, the corresponding functionality will be implemented based on the selected option. "},{"id":21,"href":"/docs/in6xxe/samples/uart-routine-guide.html","title":"Uart Routine Guide","section":"Samples","content":" UART Routine Guide # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.\nIn this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_UART in-dev/proj/driver/proj_drv_UART Configuration # #define MODE 2 Change the operating mode by replacing the number 2 with 0, 1, or 2.\n0 is POLL mode, 1 is INTR mode, and 2 is DMA mode.\n#define EN_FLOW_CTRL 0 0 indicates disabled flow control, 1 indicates enabled flow control.\n#define UART_BAUDRATE 115200 Set the baud rate for UART.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get information simply on UART log.\nMore information may be found in debug guide page.\nTest Steps # Without Flow Control Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;use poll mode\u0026rdquo; on the log, where \u0026ldquo;poll\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. With Flow Control Use the in_config tool to open the inc/in_config.h file in the corresponding project folder, check GPIO 1-5 and GPIO 1-6 under the peripheral section for MUX1, and connect them to CTS and RTS, respectively. Save the changes and open Keil to download the project. Open the debugger, check RTS or other flow control switches, and observe the text \u0026ldquo;use DMA mode\u0026rdquo; on the log, where \u0026ldquo;DMA\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. "},{"id":22,"href":"/docs/in6xxe/development-guide/adc-guide.html","title":"ADC Guide","section":"Development Guide","content":" ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.\nKey Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.\nMode # There are two modes for the ADC:\nForce Mode In Force Mode, the ADC samples a single channel once and returns the result.\nAuto Mode Auto Mode allows the ADC to continuously sample multiple channels. It is capable of sequential sampling across several channels. The results will be put into shared memory through DMA.\nChannels # The ADC supports measurement from 15 channels, including:\n12 input channels (analog/digtal mixed pins) 1 analog input channel (ADC_CH_IN) 1 VBAT (Voltage Battery) channel 1 temperature sensor channel enum adc_ch{ ADC_CH0 = 0, ///\u0026lt;ADC_CH_IN ADC_CH1, ///\u0026lt;GPIO_2_9 ADC_CH2, ///\u0026lt;GPIO_2_8 ADC_CH3, ///\u0026lt;GPIO_2_7 ADC_CH4, ///\u0026lt;GPIO_2_6 ADC_CH5, ///\u0026lt;GPIO_2_5 ADC_CH6, ///\u0026lt;GPIO_2_4 ADC_CH7, ///\u0026lt;GPIO_2_3 ADC_CH8, ///\u0026lt;GPIO_2_2 ADC_CH9, ///\u0026lt;GPIO_2_1 ADC_CH10 = 10, ///\u0026lt;GPIO_2_0 ADC_CH11, ///\u0026lt;GPIO_3_1 ADC_CH12, ///\u0026lt;GPIO_3_0 ADC_CH14 = 14, ///\u0026lt;VBAT ADC_CH15 = 15, ///\u0026lt;temperature sensor }; Note:\nChannel 13 is only for internal usage.\nVref # The Vref (Reference Voltage) can be configured as either 1.0V or 1.5V. The ADC\u0026rsquo;s range is 2*Vref. And the maximum ADC sample value is 0xFFF. Note:\nDon’t input voltage higher than 2*Vref to ADC pin.\nChannel 14(VBAT) and channel 15(temperature) can only use 1.0V Vref.\nCapture clock # Should set capture clock base on input impedance.\nCaputure clock frequency = 1 / (14*Rs*C) Rs is input\u0026#39;s output resistance (Rs). C is internal capacitor, it is 11 pF. Note:\nIf use a lower capture clock, will get a lower ADC sample rate.\nIf use a higher capture clock, it may be necessary to discard the first few samples.\nGroup interval # The group interval refers to the sampling interval between groups of samples in auto mode. The unit is us (the ADC clock is set to 1MHz) with the range of 0~255, and the default value is 16us.\nConfigration # Configration tool\nSelect \u0026ldquo;SADC\u0026rdquo; in SwiftConfig tool peripheral tab. If use auto mode, select \u0026ldquo;Sensor ADC\u0026rdquo; in Misc tab. And set SMEM size. A single sample has 2 bytes, and the minimum required size can be calculated according to the number of needed samples. SMEM size = all channel samples * 2 Example code # Force Mode Sample channel 5 in force mode:\nadc_dev_t * dev = hal_adc_open(); hal_adc_force_mode_enable_ch(dev, ADC_CH5); uint16_t buff[16]; int res = hal_adc_force_mode_start(dev, ADC_CH5, buff, 16); Auto Mode Enable \u0026ldquo;ADC_CH1\u0026rdquo; and \u0026ldquo;ADC_CH2\u0026rdquo;, get 32 samples for each channel.\nThe sampling order is shown as follows,end after 32 cycles:\nCH1 CH2 CH1 CH2 CH1 CH2 …\nuint8_t buf1[32]={0}; uint8_t buf2[32]={0}; adc_dev_t * dev = hal_adc_open(); hal_adc_auto_mode_enable_ch(dev, ADC_CH1, buf1, 32); hal_adc_auto_mode_enable_ch(dev, ADC_CH2, buf2, 32); hal_adc_auto_mode_start(dev,32, osWaitForever); Convert data # Convert raw data to voltage and temperature.\nUse \u0026ldquo;hal_adc_sample_convert\u0026rdquo; to covert raw data to voltage for channel0 ~ channel 12. Use \u0026ldquo;hal_adc_vbat_sample_convert\u0026rdquo; for channel 14. Use hal_adc_temp_sample_convert\u0026quot; for channel 15. These API use calibration data for coverting.\n"},{"id":23,"href":"/docs/in6xxe/getting-started/inplay-ble5.0-at-command-set.html","title":"BLE5.0 AT Command Set","section":"Getting Started","content":" Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.\nIN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.\nCONTROL INTERFACE # The AT commands are transmitted over standard UART interface. A terminal emulator, such as TeraTerm (Windows) or CoolTerm (Mac OS-X®), can be used to control the module from a computer, with the following default port settings:\n115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The serial port parameter configure command can modify the UART settings permanently.\nSYNTAX # The AT commands can be divided into 3 main categories: Command, Response and Event. The module receives Command and, after execution, sends back Response to the command initiator. When something happens in the module, such as an unexpected disconnection, receiving data from a remote device, etc., a corresponding Event is sent.\nCOMMAND SYNTAX # An AT command is composed of the Prefix, CommandID, CommandBody and Terminator as shown below.\nAT+\u0026lt;CommandID\u0026gt;=\u0026lt;CommandBody\u0026gt;\u0026lt;Terminator\u0026gt; The Prefix of each command is fixed ASCII string \u0026ldquo;AT\u0026rdquo; or \u0026ldquo;at\u0026rdquo;.\nCommandID is an ASCII string representing different command. It\u0026rsquo;s case sensitive.\nCommandBody can be either ASCII \u0026lsquo;?\u0026rsquo; if the command gets a parameter or parameters set if the command sets parameter. A parameter set is a collection of parameters surrounded by \u0026lsquo;[]\u0026rsquo;, each separated by \u0026lsquo;,\u0026rsquo;.\nTerminator of each command is carriage return (CR, \u0026lsquo;\\r\u0026rsquo;, \\x0d) and line feed (LF, \u0026lsquo;\\n\u0026rsquo;, \\x0a). Command is accepted and executed only when the Terminator is received.\nRESPONSE SYNTAX # After an AT command is executed, a response will be sent back. Response consists of corresponding CommandID, ResponseBody and Terminator as shown below.\n+\u0026lt;CommandID\u0026gt;=\u0026lt;ResponseBody\u0026gt;\u0026lt;Terminator\u0026gt; If command is to set parameter, the ResponseBody is either parameter set read or just a numerical error result code. The format of the read parameter set is same as the format of the set parameters of the corresponding command. Only result code is returned for set parameter commands.\nEVENT SYNTAX # An event is a message reported by the module initiatively, rather than a response obtained through the AT command. An event consists of EventID, EventBody and Terminator as shown in below.\n+\u0026lt;EventID\u0026gt;=\u0026lt;EventBody\u0026gt;\u0026lt;Terminator\u0026gt; EventID is an ASCII string representing different event. It\u0026rsquo;s case sensitive. EventBody is a parameter set and its format is same as CommandBody in AT command. Terminator is same as that in AT command response.\nPARAMETER VALUE # Parameter in parameter set supports numeric values, strings. There are three format of string: ASCII format string, Byte Array format string and Base64 encoding format string.\nEXAMPLES # The below table lists some examples of AT commands and their responses and events.\nCommand/Event Function Response AT+DEVCFG=[10,\"112222222211\",0,\"Slave\",1] Set device general configuration +DEVCFG=0000H AT+DEVCFG=? Get device general configuration +DEVCFG=[10,\"112222222211\",0,\"Slave\",1] AT+CFGADVACTV=[1,0,1,500,0,\"BwlJbnBsYXk=\"] Create legacy connectable advertising in 500ms interval. The payload is local name \"Inplay\" +CFGADVACTV=0000H: successful\n+CFGADVACTV=0043H: error advertising can't be create -EVTCONN=[1,\"EFBBCCCCDDEF\",1,1] Connected with device \"EF:DD:CC:CC:BB:EF\" on 1M PHY COMMAND REFERENCE # This section describes AT commands in detail and provides examples. Those parameter surrounded by \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; brackets are optional in some cases. If an optional parameter needs to be set, all optional parameters prior to that optional parameter must also be provided.\nSince the responseBody of the response returned by the get command is the same as the CommandBody of the corresponding set command, for simplicity, only the format of the get command is listed.\nGet Module State # This command gets the current status of the module.\nCommand: AT+STATE=?\nResponse: +STATE=[sys_state,pair_state,conn_state,scan_state,adv_state]\nParameter Type Value sys_state Number 0: Not ready;\n1: Ready pair_state Number 0: Not paired;\n1: Paired conn_state Number 0: Unconnected\n1: Connecting 2: Connected scan_state Number 0: Scanning Stopped;\n1: Scanning Started adv_state Number 0: Advertising Stopped;\n1: Advertising Started Example:\n→AT+STATE=?\n←+STATE=[1,0,0,0,0]\nGet Version # This command gets the version of the module including chip version, sdk version and firmware version\nCommand: AT+VER=?\nResponse: +VER=[chip_ver,sdk_ver,fw_ver]\nParameter Type Value chip_ver String Chip version sdk_ver String SDK version fw_ver String Firmware version Example:\n→AT+VER=?\n←+VER=[\u0026ldquo;602F0100\u0026rdquo;,\u0026ldquo;3.0.0\u0026rdquo;,\u0026ldquo;xxxx\u0026rdquo;]\nUART Configuration # This command sets UART parameters. Once UART parameter is changed, module will automatically reset and all parameters configured before will be lost.\nCommand: AT+CFGUART=[baud_rate,\u0026lt;data_bit\u0026gt;,,\u0026lt;stop_bit\u0026gt;]\nResponse: +CFGUART=err_code\nParameter Type Value baud_rate Number Standard UART baud rate value data_bit Number 5 - 8 bits polarity Number 0：No polarity\n1：Odd polarity\n2：Even polarity\nOther: invalid value stop_bit Number 0: 1 stop bits\n1: 2 stop bits Example:\n→AT+CFGUART=[921600,8,0,1]\n←+CFGUART=0000H\nDevice General Configuration # This command gets or sets the general parameters of the module.\nCommand: AT+CFGDEV=[role,dev_addr,addr_type,dev_name,phy]\nResponse: +CFGDEV=err_code\nParameter Type Value role Number 1 Observer 2 Broadcaster 5 Central 10 Peripheral 15 All Role dev_addr String Byte Array format string representing MAC address of device in little-endian mode addr_type Number 0: Public address;\n1: Static random address dev_name String ASCII phy Number 0 Random 1 1M Phy 2 2M Phy 4 Coded Phy Example:\n//Set device as BLE Peripheral, device public MAC address is 11-22-22-22-22-11, device name is \u0026ldquo;Slave\u0026rdquo; and prefered PHY is 1M PHY\n→AT+CFGDEV=[10,\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,1]\n←+CFGDEV=0000H\n//Set device as All role and prefered PHY is Coded Phy\n→AT+CFGDEV=[15,\u0026ldquo;AABB0101BBAA\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,4]\n←+CFGDEV=0000H\nData Transparent Transmission Service Configuration # This command gets or sets parameters of Inplay private data transparent tranmission service as GATT server, including service UUID, maximum data transmission size etc. After the execution of the command, the service with specified parameters will be created. It MUST be sent after +CFGDEV\nIt is only allowed by device with \u0026lsquo;Peripheral role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXSVC=[start_hdl,svc_uuid,max_data_sz]\nResponse: +CFGTRXSVC=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically created\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied max_data_sz Number Maximum data transmission size\n0: Default 20 bytes\n1 - 1024: Maximum data size Example:\n//Set service UUID as 1122b4f8-cdf3-11e9-a32f-2a2ae2dbcce4 and the maximum transmission data as 512 bytes.\n→AT+CFGTRXSVC=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;,512]\n←+CFGTRXSVC=0000H\n//Set service UUID by default. Fixed service start handle to 20\n→AT+CFGTRXSVC=[20,\u0026quot;\u0026quot;,0]\n←+CFGTRXSVC=0000H\nData Transparent Transmission Client Configuration # This command gets or sets parameter of Inplay private data transparent tranmission service as GATT client. If parameters are not set or parameter \u0026lsquo;start_hdl\u0026rsquo; is set to 0, device will initiate a Service Discovery Process (SDP) to find remote service after connection.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXCLT=[start_hdl,svc_uuid]\nResponse: +CFGTRXCLT=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically get by SDP\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied Example:\n//Set to discover service by SDP.\n→AT+CFGTRXCLT=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;]\n←+CFGTRXCLT=0000H\n//Set specific start handle and leave other in default, so that SDP is not necessary.\n→AT+CFGTRXCLT=[20,\u0026quot;\u0026quot;]\n←+CFGTRXCLT=0000H\nRF Configuration # This command gets or sets RF related parameter.\nCommand: AT+CFGRF=[tx_power]\nResponse: +CFGRF=err_code\nParameter Type Value tx_power Number TX power: 0Max TX power (~8dBm) 1-157dBm to 0dBm with step 0.5dBm 16-22-1dBm to -7dBm with step -1dBm Example:\n//Set TX power +3dBm\n→AT+CFGRF=[9]\n←+CFGRF=0000H\nSMP Configuration # This command gets or sets security parameters of the module.\nCommand: AT+CFGSMP=[smp,dev_io_cap,pairing_code]\nResponse: +CFGSMP=err_code\nParameter Type Value smp Number (1 byte) - - - - LE Secure Connection MITM - Encryption - - - - Bit3 Bit2 - Bit0 0: false; 1: true dev_io_cap Number 0 Display Only 1 Display Yes No 2 Keyboard Only 3 Keyboard Display 4 No Input No Output pairing_code String ASCII Paring code Example:\n//Set SMP to MITM security and encryption, with ability of keyboard input. The corresponding MITM pairing code is 012345\n→AT+CFGSMP=[5,2,\u0026ldquo;012345\u0026rdquo;]\n←+CFGSMP=0000H\nTarget Device Configuration # This command gets or sets the target devices that are allowed to connect or scan. If initiating activity is configured as direct connection type, only first device in the device list is the target. Maximum 25 target devices can be set.\nIt is only allowed by device with ‘Central role’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGTARGET=[dev1_addr,dev1_addr_type,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_addr_type\u0026gt;,\u0026hellip;]\nResponse: +CFGTARGET=err_code\nParameter Type Value dev_addr String Byte Array format string representing MAC address of target device in little-endian mode dev_addr_type Number 0: Public address;\n1: Static random address Example:\n→AT+CFGTARGET=[\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;AABBCCCCDDEE\u0026rdquo;,0]\n←+CFGTARGET=0000H\nAdvertising Activity Configuration # This command sets parameter to create BLE advertising activity. Maximum 2 advertising activities can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Peripheral’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGADVACTV=[actv_id,adv_type,connectable,intv,chn,payload]\nResponse: +CFGADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity adv_type Number 0: Legacy Advertise 1: Extended Advertise connectable Number 0: Unconnectable 1: Connectable intv Number 20-10240ms chn Number 0: all BLE advertising channel\n37-39: Fixed channel payload String BLE standard advertising data format in base64 encoding\nLength (1 byte) + Type (1 byte) + Content (length -1 byte) Example:\n//Set legacy connectable advertising in 500ms interval. The payload is local name \u0026ldquo;Inplay\u0026rdquo;\n→AT+CFGADVACTV=[1,0,1,500,0,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n//Successfully set\n←+CFGADVACTV=0000H\nScan Activity Configuration # This command sets parameter to create BLE scan activity. Only one scan activity can be created.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGSCANACTV=[actv_id,type]\nResponse: +CFGSCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity type Number 2: Observer\n3: Selective observer. Only devices configured by +CFGTARGET will be reported Example:\n//Set scan activity\n→AT+CFGSCANACTV=[20,3]\n//Successfully set\n←+CFGSCANACTV=0000H\nInitiating Activity Configuration # This command sets parameter to create BLE initiating activity to establish connections with the target device. Only one initiating activity can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Central\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGINITACTV=[actv_id,type]\nResponse: +CFGINITACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity type Number 0: Direct connect\n1: Auto connect. Only devices configured by +CFGTARGET can be connected Example:\n//Create initiating activity to auto connect with target devices.\n→AT+CFGINITACTV=[10,1]\n//Successfully set\n←+CFGINITACTV=0000H\n//Create initiating activity to direct connect with remote device.\n→AT+CFGINITACTV=[10,0]\n//Successfully set\n←+CFGINITACTV=0000H\nStart Advertising Activity # This command start advertising activity that is created by previous +CFGADVACTV command.\nCommand: AT+ADVACTV=[actv_id,op,\u0026lt;duration\u0026gt;]\nResponse: +ADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activities op Number 0: Stop Activity\n1: Start Activity duration Number 0: Forever\n10-65535: Actual duration (in unit of 10ms)\nDefault 0 Example:\n//Start advertising activty permanently\n→AT+ADVACTV=[1,1,0]\n//Successfully set\n←+ADVACTV=0000H\n//Stop advertising activity\n→AT+ADVACTV=[1,0]\n←+ADVACTV=0000H\nStart Scan Activity # This command start scan activity that is created by previous +CFGSCANACTV command. If target devices are not configured by +CFGTARGET command, advertisement from any devices scaned will be reported.\nCommand: AT+SCANACTV=[actv_id,op,\u0026lt;intv\u0026gt;,\u0026lt;wnd\u0026gt;,\u0026lt;chn\u0026gt;,\u0026lt;duration\u0026gt;,\u0026lt;dup_filter\u0026gt;]\nResponse: +SCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity op Number 0: Stop Activity\n1: Start Activity intv Number Scan activity interval 3-40959 ms\nDefault 200ms wnd Number Scan running time, must be less than intv\nDefault 100ms chn Number 0: Scan on three channel alternately\n37-39: Scan on fixed channel\nDefault 0 duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 dup_filter Number 0: No filtering\n1: Filter duplicates within the duration\nDefault 0 Example:\n//Start scan activty permanently\n→AT+SCANACTV=[20,1,200,100,0,0,1]\n//Successfully set\n←+SCANACTV=0000H\n//Stop scan activity\n→AT+SCANACTV=[20,0]\n←+SCANACTV=0000H\nStart Initiating Activity # This command start initiating activity that is created by previous +CFGINITACTV command. If target devices are not configured by +CFGTARGET command, activity cann\u0026rsquo;t be started and retures error response. When it is started permanently, it will end until all target devices configured are connected.\nCommand: AT+INITACTV=[actv_id,op,\u0026lt;conn_intv\u0026gt;,\u0026lt;latency\u0026gt;,\u0026lt;sup_tmo\u0026gt;,\u0026lt;duration\u0026gt;]\nResponse: +INITACTV=err_code\nParameter Type Value actv_id Number Unique ID for initiating activity op Number 0: Stop Activity\n1: Start Activity conn_intv Number Connection interval: 8 - 4800 ms\nDefault 100 ms latency Number 0 - 499\nDefault 0 sup_tmo Number 100 - 32000 ms\nDefault 20000 ms duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 Example:\n//Start initiating activty\n→AT+INITACTV=[10,1,200,0,20000,0]\n//Successfully set\n←+INITACTV=0000H\n//Stop initiating activity\n→AT+INITACTV=[10,0]\n←+INITACTV=0000H\nGet current connection list # This command gets a list of currently connected devices.\nCommand: AT+CONNLST=?\nResponse: +CONNLST=[\u0026lt;dev1_addr\u0026gt;,\u0026lt;dev1_role\u0026gt;,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_role\u0026gt;,\u0026hellip;]\nParameter Type Value dev_addr String The Byte Array format string representing MAC address of peer device in little-endian mode dev_role Number 0: Peer device as Master role;\n1: Peer device as Slave role Example:\n→AT+CONNLST=?\n//Connect to master device \u0026ldquo;66-55-44-33-22-11\u0026rdquo; and a peripheral device \u0026ldquo;FF-EE-DD-CC-BB-AA\u0026rdquo;\n←+CONNLST=[\u0026ldquo;112233445566\u0026rdquo;,0,\u0026ldquo;AABBCCDDEEFF\u0026rdquo;,1]\nStart Pairing # This command start operation of BLE pairing with connected device.\nCommand: AT+BOND=[op,dest_addr,\u0026lt;pairing_code\u0026gt;]\nResponse: +BOND=err_code\nParameter Type Value op Number 0: Cancel pairing\n1: Start pairing dest_addr String The Byte Array format string representing MAC address of connected device in little-endian mode pairing_code String 6 bytes ASCII pairing code Example:\n→AT+BOND=[1,\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;012345\u0026rdquo;]\n←+BOND=0000H\n//Stop pairing\n→AT+BOND=[0,\u0026ldquo;112233445566\u0026rdquo;]\n←+BOND=0000H\nData Transmit # This command transmit data via Inplay private transparent transmission service.\nCommand: AT+DATATX=[dest_addr,data]\nResponse: +DATATX=err_code\nParameter Type Value dest_addr String The Byte Array format string representing MAC address of destination connected device in little-endian mode data String Base64 encoding string representing binary data to transmit Example:\n//Send data \u0026ldquo;0x0001020304050607080910\u0026rdquo; to remove device \u0026ldquo;66-55-44-33-22-11\u0026rdquo;\n→AT+DATATX=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n←+DATATX=0000H\nReset # This command causes the system to reset. While execution, application can choose whether to save or clear current configured parameters permanently. This command don\u0026rsquo;t have any response. The application determines whether reset is complete or not by receiving the +EVTREADY event.\nCommand: AT+SYSRST=[op]\nResponse: N/A\nParameter Type Value op Number 0: Reset module\n1: Reset after saving current parameters to Flash\n2: Reset after clearing current parameter from Flash Example:\n→AT+SYSRST=[1]\nWatchdog # This command set up watch dog.\nCommand: AT+SYSWDT=[wdt_enable,wdt_int_pol,wdt_tmo]\nResponse: +SYSWDT=err_code\nParameter Type Value wdt_enable Number 0: Disable\n1: Enable wdt_int_pol Number 0: Low level trigger interrupt\n1: High level trigger interrupt wdt_tmo Number 1 - 65536 seconds Example:\n→AT+SYSWDT=[1,0,60]\n←+SYSWDT=0000H\nEVENT REFERENCE # -EVTREADY # This event indicates module is ready to accept AT commands. It is usually received after power on reset or +SYSRST command is executed.\nEvent: -EVTREADY=[prev_state]\nParameter Type Value prev_state Number 0 Power on reset or reset command with op 0 1 Reset command with op 1 2 Reset command with op 2 3 Watch dog reset Example:\n-EVTREADY=[1]\n-EVTCONN # This event indicates device has been connected or disconnected.\nEvent: -EVTCONN=[state,peer_addr,role,phy]\nParameter Type Value state Number 0: Disconnect\n1: Connect peer_addr String Byte Array format string representing MAC address of peer device in little role Number 5: Device is connected as Master role;\n10: Device is connected as Slave role phy Number Phy that connection on. Please refer to PHY parameter in command +DEVCFG Example:\n//Successfully connected with remote Master device \u0026ldquo;EF:DD:CC:CC:BB:EF\u0026rdquo; on 1M PHY.\n-EVTCONN=[1,\u0026lsquo;EFBBCCCCDDEF\u0026rsquo;,1,1]\n-EVTDATA # This event indicates the data reception from peer device.\nEvent: -EVTDATA=[peer_addr,data]\nParameter Type Value peer_addr String Byte Array format string representing MAC address of peer device in little-endian mode data String Base64 encoding format string representing binary data received Example:\n//Data \u0026ldquo;0x0001020304050607080910\u0026rdquo; received from remove device \u0026ldquo;66-55-44-33-22-11”\n-EVTDATA=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n-EVTADV # This event indicates that an advertising signal has been scanned.\nEvent: -EVTADV=[dev_addr,addr_type,connectable,rssi,payload]\nParameter Type Value dev_addr String Byte Array format string representing MAC address of advertising device in little-endian mode addr_type Number 0: Public\n1: Static random connectable Number 0: Unconnectable\n1: Connectable rssi Number Signed integer in dBm payload String Base64 encoding format string representing advertising payload binary data Example:\n//A connectable ad with local name \u0026lsquo;Inplay\u0026rsquo; as payload from device \u0026lsquo;66-55-44-33-22-11\u0026rsquo; is scanned. RSSI is -80dBm.\n-EVTADV=[\u0026ldquo;112233445566\u0026rdquo;,0,1,-80,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n-EVTACTVEND # This event indicates the termination of the command +SCANACTV, +ADVACTV, +INITACTV and +BOND, whether the commands are terminated automatically or manually.\nEvent: -EVTACTVEND=[actv_type,actv_id]\nParameter Type Value actv_type Number 0 Advertising activity 1 Scan activity 2 Initiating activity 3 Bond actv_id Number Unique ID for activity Example:\n//Advertising activity 1 has ended\n-EVTACTVEND=[0,1]\n//Scan activity has ended\n-EVTACTVEND=[1,20]\nERROR CODE # The ERROR CODE is returned as a hexadecimal value. Please refer to following table for details.\n0000H Command executed successfully 1001H Wrong command execution 100AH Wrong CommandID 100BH Wrong format 100DH Wrong parameter 100EH Execution overtime Others BLE error. Refer to in_ble_error.h in SDK "},{"id":24,"href":"/docs/in6xxe/development-guide/counter-development-guide.html","title":"Counter Guide","section":"Development Guide","content":" Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.\nThe 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.\nFor details, please refer to:\nHal_cnt_pwm.c Hal_cnt_timer.c Hal_ir.c Hal_sync7816.c Counter Mode # The counter supports four modes:\nCapture Mode: In Capture Mode, the counter captures waveforms on din A and din B. It detects falling edge and rising edge, records the timestamp into corresponding registers.\nCapture Register 0: Stores the counter value at the first event trigger(falling edge or rising edge).\nCapture Register 1: Stores the counter value at the second event trigger(falling edge or rising edge).\nCapture Register 2: Stores the counter value at the third event trigger(falling edge or rising edge). Subsequent event triggers will overwrite Capture Registers 0, 1, and 2.\nWaveform Mode: In Waveform Mode, the counter outputs signals on \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; based on the values stored in the target registers.\nTarget Register 0: Outputs 0 when the counter reaches the specified value. Target Register 1: Outputs 1 when the counter reaches the specified value. Target Register 2: Stops output when the counter reaches the specified value. Shift In Mode: In Shift In Mode, the counter reads signals from \u0026ldquo;Din A\u0026rdquo; and \u0026ldquo;Din B\u0026rdquo; on every clock cycle, capturing one bit at a time.\nShift Out Mode: In Shift Out Mode, the counter outputs signals to \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; on every clock cycle, transmitting one bit at a time.\nMode Switching: When automatic mode switching is enabled, Capture Mode and Waveform Mode can automatically switch. Similarly, Shift In Mode and Shift Out Mode can also automatically switch.\nConfiguration # Each counter has two input signals: \u0026ldquo;din A\u0026rdquo; and \u0026ldquo;din B\u0026rdquo;, as well as two output signals: \u0026ldquo;dout A\u0026rdquo; and \u0026ldquo;dout B\u0026rdquo;. These internal signal can be configured to connect to external pins. Specifically, these pins are represented as PIN0 to PINI7 (GPIO21 to GPIO28) on the diagram. Select \u0026ldquo;Counter\u0026rdquo; in config tool and select the corresponding pin according to the actual circuit.\nRefer to:\nint hal_cnt_internal_din_pinmux(int inner_pin, int ext_pin) int hal_cnt_internal_dout_pinmux(int inner_pin, int ext_pin) EXT_DIN is from PIN0~PIN7.\nINNTER_DIN is internal din signal from four counters.\nInterrupt # Interrupt status. Each bit is represented as follows:\nCNT_A_UPDATE 1\tcapture register a0 a1 a2 all updated CNT_B_UPDATE 0x2\tcapture register b0 b1 b2 all updated CNT_OVERFLOW 0x4\tcounter overflow the counting will restart CNT_SHIFTIN_COMPLETE 0x8 shift in completed CNT_SHIFTOUT_COMPLETE 0x10\tshift out completed CNT_WAVEFORM_STOP 0x20\twaveform stop, the counter has reached the value of register a2/b2 CNT_SHIFTIN_CAPTURE_END 0x40\tin the automatic switching mode, capture or shift in is completed CNT_SHIFTOUT_WAVEFORM_END 0x80 in the automatic switching mode, waveform or shift out is completed API # Set the callback of the interrupt. # The callback fun will be called during the interrupt.\nvoid hal_cnt_set_handler(cnt_dev_t *dev, CNT_ISR_FUN fun, void *arg) Mask/unmask interrupt # int hal_cnt_intr_unmask(cnt_dev_t* dev) int hal_cnt_intr_mask(cnt_dev_t* dev) Enable/Disable # void cnt_enable(uint32_t base) void cnt_disable(uint32_t base) Trigger and signal source # The counter can be set to be triggered by signal or manually.\nSet the signal source and edge\nvoid cnt_set_src_edge(uint32_t base, uint32_t src_edge)\nSignal source:\n#define CNT_EXT_DIN_A 1 #define CNT_EXT_DIN_B 2 #define CNT_GLOBAL_START_TRIGGER 3 #define CNT_SINGLE_START_TRIGGER 4 #define CNT_GLOBAL_STOP_TRIGGER 5 #define CNT_SINGLE_STOP_TRIGGER 6 #define CNT_INNER_DIN0 11 #define CNT_INNER_DIN1 12 #define CNT_INNER_DIN2 13 #define CNT_INNER_DIN3 14 Global trigger will trigger all four counters, single trigger will only trigger one counter.\nEdge\n#define CNT_RISING_EDGE 0 #define CNT_FALLING_EDGE 0x10UL #define CNT_BOTH_EDGE 0x20UL Signal\nStart signal\n#define CNT_START_SIGNLE_SHIFT 0 Stop signal\n#define CNT_STOP_SIGNLE_SHIFT 8 Din 0 signal\n#define CNT_DIN0_SHIFT 16 Din 1 signal\n#define CNT_DIN1_SHIFT 24 Example # Set the external DIN A as the start signal. Double edge trigger. The DIN0 signal is the external DIN A. Double edge trigger.\ncnt_set_src_edge(cnt_dev-\u0026gt;base, (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_START_SIGNLE_SHIFT | (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_DIN0_SHIFT); Manual trigger # void cnt_trigger_start (uint32_t base) void cnt_trigger_stop (uint32_t base) Set the internal signal # void cnt_set_input_mux(uint32_t base, uint32_t val) Parameter Val, bus A by default\n#define CNT0_BUS_B 0x1 #define CNT1_BUS_B 0x2 #define CNT2_BUS_B 0x4 #define CNT3_BUS_B 0x8 Target control # void cnt_set_target_ctrl (uint32_t base, uint32_t ctrl) The behavior when the counter reaches register A2.\nKeep or reset value. Reset value by default.\n#define CNT_A2_KEEP_VALUE 0x1UL #define CNT_A2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_A2_STOP_COUNTER 0x2UL #define CNT_A2_RESTART_COUNTER 0x0UL The behavior when the counter reaches register B2\nKeep or reset value. Reset value by default.\n#define CNT_B2_KEEP_VALUE 0x4UL #define CNT_B2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_B2_STOP_COUNTER 0x8UL #define CNT_B2_RESTART_COUNTER 0x0UL Set the value when resetting\n#define CNT_DOUT_A_RESET_VALUE_SHIFT 4 #define CNT_DOUT_B_RESET_VALUE_SHIFT 5 Example: # B2 is to hold and stop counter, while A2 resets value and stops counter. The reset values are both set to 0.\ncnt_set_target_ctrl(dev-\u0026gt;base, CNT_B2_KEEP_VALUE|CNT_B2_STOP_COUNTER |CNT_A2_RESET_VALUE|CNT_A2_STOP_COUNTER|(0\u0026lt;\u0026lt;CNT_DOUT_A_RESET_VALUE_SHIFT)|(0\u0026lt;\u0026lt;CNT_DOUT_B_RESET_VALUE_SHIFT)); Set output bypass # void cnt_set_out_bypass(uint32_t base, uint32_t val) Bypass A or B. A and B will perform the bit operation by default\n#define CNT_OUT_BYPASS_A 0x10000UL #define CNT_OUT_BYPASS_B 0x20000UL Set the logical operation of A, and the result of dout A is the result of the related bit operation of A and B.\n#define CNT_OPT_A_AND\t0x0 #define CNT_OPT_A_OR\t0x1 #define CNT_OPT_A_XOR\t0x2 Set the logical operation of B, and the result of dout B is the result of the related bit operation of A and B\n#define CNT_OPT_B_AND\t0x0 #define CNT_OPT_B_OR\t0x10 #define CNT_OPT_B_XOR\t0x20 "},{"id":25,"href":"/docs/in6xxe/development-guide/gpio-guide.html","title":"GPIO Guide","section":"Development Guide","content":" GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:\nDigital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to \u0026ldquo;proj_drv_gpio\u0026rdquo;.\nConfigure GPIO to output and output high/low:\nint level = 0; hal_gpio_cfg_output(port, poin); hal_gpio_output(port, poin, level); Configure GPIO to input and get input value:\nint level; hal_gpio_cfg_input(port, poin, GPIO_PULL_UP); level = hal_gpio_input_status(port, poin); Interrupt # Each pin in one group share the same interrupt. Supports falling edge, rising edge and both edge.\nRefer to \u0026ldquo;proj_drv_gpio_interrupt\u0026rdquo;.\nConfigure interrupt for falling edge and rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_NO_PULL); hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 1, 1, 0); Wake up # All pins can be configured to wake up the chip by high level, low level, falling edge, rising edge, and both edges.\nRefer to \u0026ldquo;proj_drv_gpio_wup\u0026rdquo;.\nConfigure to wake up by rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_PULL_DOWN); hal_gpio_cfg_wup_edge(port, pin, 1, 0); To output in sleep mode, set latch to 1:\n//output high in deep sleep and wake up hal_gpio_cfg_output(port, pin); hal_gpio_output(port, pin, 1); hal_gpio_sleep_pad_latch(port, pin, 1, 0); Wake up and get interrupt # After waking up, it can generate interrupt.\nRefer to \u0026ldquo;proj_drv_gpio_wup_interrupt\u0026rdquo;\n/// interrupt /// falling edge , wake up en hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 0, 1, 1); /// wake up by edge ///\tfalling edge hal_gpio_cfg_wup_edge(port, pin, 0, 1); Reset chip/CPU # GPIO pin can be configured to reset the chip/CPU by falling edge or rising edge.\nRefer to \u0026ldquo;proj_drv_gpio_reset\u0026rdquo;.\nReset chip by falling edge\nhal_gpio_cfg_input(port, pin, GPIO_PULL_UP); hal_gpio_reset_chip(port, pin, port, pin, 1, 16); "},{"id":26,"href":"/docs/in6xxe/getting-started/hci_command.html","title":"HCI Command","section":"Getting Started","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Command Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # packet type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 1\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding Table 2\ntx power: Value TX Power 0x00 Max Power 0x01 7dBm 0x02 6.5dBm 0x03 6dBm 0x04 5.5dBm 0x05 5dBm 0x06 4.5dBm 0x07 4dBm 0x08 3.5dBm 0x09 3dBm 0x0A 2.5dBm 0x0B 2dBm 0x0C 1.5dBm 0x0D 1dBm 0x0E 0.5dBm 0x0F 0dBm 0x10 -1dBm 0x11 -2dBm 0x12 -3dBm 0x13 -4dBm 0x14 -5dBm 0x15 -6dBm 0x16 -8dBm 0x17 -10dBm 0x18 -12dBm 0x19 -16dBm 0x1A -20dBm 0x1B -43dBm Table 3\nHCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,01, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 01, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 01, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 1\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 01, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x01, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: use default value. 0x1 ~ 0x7F: PA gain, 0x19 is 0dBm. Complete Event：0x04, 0x0E, 0x01, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 01, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x06, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\nComplete Event:0x04, 0x0E, 0x01, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nSet Cap # Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap to Efuse # Command: 0x01, 0x06, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x06, 0xFC, \u0026lt;status\u0026gt;\nNotice:\nThis command burn cap data to Efuse memory. Must supply 3.3V power on VDDQ pin.\nEfuse is OTP(One Time Programmable) memory. Make sure bure correct value in Efuse.\nSave Cap to Flash # Command: 0x01, 0x08, 0xFC, 0x01, \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3.\nCommands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 to 0x1A. Please refer to Table 3. Complete Event: 0x04, 0x0E, 01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nSet TX Gain # Command: 0x01, 0x51, 0xFC, 0x00, \u0026lt;TX Gain\u0026gt;\nTX Gain: TX gain, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power Table # Command: 0x01, 0x52, 0xFC, 0x00, \u0026lt;TX Power Table\u0026gt;\nTX Power Table: Range is 0x01 ~ 0x04. Default is 0x1. Table 1 is for low power mode. And table 4 is for high power mode. Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nStart PWM # Command: 0x01, 0x09, 0xFC, 0x01, \u0026lt;pwm id\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Command: 0x01, 0x0A, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number The following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq_offset_code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code\n"},{"id":27,"href":"/docs/in6xxe/getting-started/introduction-to-in6xxe-dk.html","title":"Introduction to IN6XXE DK","section":"Getting Started","content":" Overview # IN6XXE DK is a development board for IN6XXE series chips. The schematics can be downloaded here.\nHardware description # Component Description 1 RF Switch 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.8V Power 5V to 1.8V 10 ADC port 11 Cortex_debug Debug port 12 Power ON Power switch of the 5V supply from USB 13 Jlink+UART0 JLINK and UART0, UART0 Tx is GPIO_0_2, Rx is GPIO_1_0 14 1.2V Test point 15 LEDs LEDs connected to GPIO,on when GPIO drives HIGH. LED1:GPIO_2_8, LED2:GPIO_3_2, LED3:GPIO_3_3 16 GPIO Test Pin GPIO pins 17 GPIO Test Hole GPIO pins 18 GPIO Button+Reset One reset button, other buttons are LOW active(when pressed, GPIO input LOW) 19 Power Level Shift Convert UART interface voltage level between IN6XXE and USB to UART chip 20 UART1 flow control Control power supply of USB to UART chip; Control voltage level converter; Control which GPIOs are connected to the USB to UART chip, default is UART1: GPIO_2_1:TX GPIO_2_7:RX GPIO_1_5:RTS GPIO_1_6:CTS see UART Configuration 21 UART to USB 22 3.3V Power 5V to 3.3V 23 Type-C Power supply and connect to PC for UART port 24 External VBAT External supply to VBAT 25 External VDDIO External supply to VDDIO These components will be refered as \u0026ldquo;Component_xx\u0026rdquo;(xx is the component number) in this page.\nPower Supply # When the board is connected with USB and the switch is turned on, 5V, 3.3V and 1.8V power source will be valid, and 3 LEDs will indication the status:\nLED4: 5V LED5: 3.3V LED6: 1.8V However, how these power sources will supply IN6XXE chip is configured with Power Jumper(Component_7):\nCHIP_EN can always be connected to VBAT to reset the chip when powered on. VDDIO and VBAT are connected directly to the chip. VDDIO is power supply of IN6XXE\u0026rsquo;s IO, and the voltage level can be different with VBAT. These are confguration examples:\nConnections Description CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;3.3V,VBAT\u0026lt;-\u0026gt;3.3V Both VDDIO and VBAT are 3.3V, supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;1.8V,VBAT\u0026lt;-\u0026gt;3.3V VDDIO is 1.8V, VBAT is 3.3V, both supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;VBAT VBAT and VDDIO are powered by external power source, can be used when measuring power consumption of the chip Debug Port # There are three connectors(component 8, 11, 13) can be used as debug port, usually connected to J-Link.\nUART configuration # IN6XXE has two UART ports, UART0 and UART1. You can connect external USB to UART module to Component_13 if you use UART0.\nYou can also use the on board USB to UART chip, configured with Component_20:\nIf you want to use on board USB to UART chip, 1\u0026lt;-\u0026gt;2, 3\u0026lt;-\u0026gt;4 should be connected.\nIf you want to use UART1(GPIO_2_1 as Tx, and GPIO_2_7 as Rx):\n9\u0026lt;-\u0026gt;10, 11\u0026lt;-\u0026gt;12 should be connected for UART Rx and Tx.\n5\u0026lt;-\u0026gt;6, 7\u0026lt;-\u0026gt;8 should be connected for flow control.\nYou can connect 5,7,9,11 to other GPIOs if you use other GPIOs as UART port pins.\nCurrent measurement # If you want to measure current of IN6XXE, all pins of Component_13 should be disconnected.\nFor the Power Jumper, CHIP_EN\u0026lt;-\u0026gt;VBAT and VDDIO\u0026lt;-\u0026gt;VBAT should be connected.\nThen you can connect external power source to VBAT(Component_24) and GND(Component_6) to supply power to IN6XXE and measure the current.\n"},{"id":28,"href":"/docs/in6xxe/getting-started/jflash-download-guide.html","title":"JFlash Programming","section":"Getting Started","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XXE series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nCopy files: Copy IN6XXE to \u0026ldquo;C:\\Users\u0026lt;USER\u0026gt;\\AppData\\Roaming\\SEGGER\\JLinkDevices\u0026rdquo;. (Only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later.) Ubuntu # Copy IN6XXE to \u0026ldquo;$HOME/.config/SEGGER/JLinkDevices\u0026rdquo;. (Only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later.)\nmacOS # Copy IN6XXE to \u0026ldquo;$HOME/Library/Application Support/SEGGER/JLinkDevices\u0026rdquo;. (Only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later.)\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay IN6XXE device Open the Bin file\nClick the file menu, select “Open data file”, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":29,"href":"/docs/in6xxe/development-guide/trigger-handler-guide.html","title":"NanoSync Engine Guide","section":"Development Guide","content":" NanoSync Engine Guide # Introduction # NanoSync engine(trigger handler block) which can be used to perform many real-time events or tasks without the CPU’s intervention.\nThe NanoSync engine operates based on triggers and handlers. When a trigger (also called an event) happens, a handler will be invoked. A handler consists of a sequence of hardware actions (also called hardware tasks), which can be automatically executed by the hardware without the CPU intervention. Typical triggers include GPIO input status change, timer time out, CPU interrupts etc.\nTerminology # Priority Queues # NanoSync engine supports three priority queues:\nHigh Priority Queue:\nSupports up to 8 defined triggers. Dedicated memory of 512 words. Middle Priority Queue:\nSupports up to 8 defined triggers. Use shared memory, maximum memory usage is 512 words. Low Priority Queue:\nSupports up to 16 defined triggers. Use shared memory, maximum memory usage is 512 words. Higher priority queue can preempt lower priority queue.\nTrigger id # In each queue, there are multiple triggers. And each trigger is assined a unique trigger id. The high priority and middle priority queues have 8 triggers, with trigger id ranging from 0 to 7. The low priority queue has 16 triggers, with trigger id ranging from 0 to 15.\nWhen multiple triggers within the same queue are triggered simultaneously, the trigger with the smallest trigger id will be executed first.\nTrigger Header # Every trigger has a header. Trigger headers are located at beginning of queue memory.\nTrigger Signals # There are 255 trigger signals. And 0xFF is invalid trigger signal(refer to enum trig_cond_idx for details). Each trigger signal corresponds to an external or internal signal. When receive the signal(rising edge/failling edge), it triggers the corresponding trigger and executing the corresponding trigger command.\nTrigger Command # A trigger can have multiple trigger commands. When activated, these commands will be executed sequentially.\nODC(output direct controls) # Used by output command. Has 127 output direct controls(refer to enum trig_odc_idx for details).\nMemory # High priority queue has 512 words(2KB) dedicated memory(trig memory). Middle and low priority queue use shared memory.\nTimer # Each priority queue has its own 24-bit timer.\nAHB/APB bus # Trigger handler can use APB or AHB bus to access peripheral registers.\nAHB bus: CPU can access register with AHB bus. Read and write opertations don\u0026rsquo;t have a fix lantency. The deviation is about 3us.\nAPB bus: CPU can\u0026rsquo;t access register with APB bus. Has fix latency, The deviation is less than 0.1us.\nTrigger Address # All trigger API use word address offset, not byte address. Address offset is start from 0x0.\nTrigger configuration # Enable HW trigger in share memory configuration. The size is low priority queue memory size plus middle priority queue memory size. Maximum size is 4K(0x1000). If enable sleep, should select \u0026ldquo;Reten Mem\u0026rdquo; to retention shared memory and trigger memory.\nTrigger command # Set timer command # This commamnd is used to config the timer.The timer will be initialized with the initial value specified by the command (or the value in the control register) and will start counting down towards 0. If the auto-reload bit of the command is set to 0x1, the timer will restart with the initial value or the value from the control register after reaching 0. If the auto-reload bit of the command is set to 0x0, the timer will stop. If the timer is already running at the time of this command execution, it will be reset to the initial value and restart. Upon reaching 0, the timer can generate an interrupt signal.\nWait timer command # This command is used to wait for the timer to expire. This command will block the subsequent commands until the timer reaches the value specified in the command. If the “stop timer” bit is 1, the timer will stop counting when the timer reaches the expected value. If the “stop timer” bit is 0, the timer will continue counting after it reaches the expected value. It is strongly recommended that this command is NOT used in the highest priority queue as this command might delay the execution of all following triggers in the highest priority queue and also all triggers in the middle and lowest priority queues.\nRegister read and compare command # This command reads a value from a specific register, applies the mask on the read value and then compares the masked value to the expected value. When conditions fails, it can jump to another address to run command.\nRegister write command # This command write 32 bits value to register.\nRegister read and write command # The command reads the register value first and only update the bits to the write value where the corresponding bits in the mask is 1. The actual write value is computed as:\nactual_write_value = (read_value \u0026amp; ( ~ mask )) | (write_value \u0026amp; mask). Register copy command # This command will read the source register address value, and copy data to destination register.\nRegister copy with mask command. # This command will read the source register address value, apply the mask and write the masked value to the destination register address. The destination register value will also be read and the non-mask portion will be unchanged and written back to the destination register address together with the masked source register read value.\nwritten_value = (destination_read_value \u0026amp; (~ mask)) | (source_read_value \u0026amp; mask). Output command # This command output signal with ODC(output direct controls). Refer to enum trig_hdl_idx for specific signal details. Each output command contains an output signal index, a toggle enable and an output value. If the index is larger than 127, the specific ODC is disabled. It is recommended to write 0x7F to all unused output signal index. If the toggle bit is 1 for a given output index, the corresponding output value will be ignored and the corresponding output signal will toggle its current output value to an opposite polarity.\nNotice that we will use a control register to initialize the output port value which will be controlled by the trigger handler before the handler module is enabled. See hal_trig_hdl_gpio_out_en for reference.\nNull command # This command is just a placeholder in the memory and will not execute any operation.\n"},{"id":30,"href":"/docs/in6xxe/quick-start.html","title":"Quick Start","section":"IN6XXE","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_adv_conn\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/build/mdk/proj_ble_test.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN6XXE\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Click \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes.\nNote:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIn the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN6XX SPI FLASH \u0026ldquo;flm file, set start addres and size.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":31,"href":"/docs/in6xxe/getting-started/quick-start-with-gcc.html","title":"Quick Start with GCC","section":"Getting Started","content":" Quick Start Guide with GCC # Introduction # This document introduce how to use GCC for software development.\nPreparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install Arm GNU Toolchain (version \u0026ldquo;arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi\u0026rdquo; is recommended).\nInstall Make\nsudo apt-get update sudo apt-get install build-essential Generate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Use Wine to run it on Linux. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Unzip InPlay SDK to \u0026ldquo;~/inplay\u0026rdquo;. Open file \u0026ldquo;~/inplay/in-dev/proj/common/gcc/linux.mk\u0026rdquo;. Set \u0026ldquo;GNU_INSTALL_ROOT\u0026rdquo; to your GCC installation path. Build project \u0026ldquo;proj_ble_adv_conn\u0026rdquo;. cd ~/inplay/in-dev/proj/ble/proj_ble_adv_conn/build/gcc/ make all Use the following command to rebuild project: make cleanall make all "},{"id":32,"href":"/docs/in6xxe/development-guide/run-zephyr-on-in6xxe.html","title":"Run Zephyr on IN6XXE","section":"Development Guide","content":" Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.\nInplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.\nSetup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows. You can follow Zephyr Getting Started Guide to setup a Zephyr development environment under Windows, it can be divided into following steps:\n1.Install host dependencies, including cmake, Python, devicetree compiler, etc.\nThese are necessary host tools needed to build Zephyr.\n2.Install west and Python dependencies\nBecause IN6XXE support is not merged into the official Zephyr project repository now, you should init west using below command:\nwest init -m https://github.com/InPlay-Inc/zephyr zephyrproject To support IN6XXE, an external module named \u0026ldquo;hal_inplay\u0026rdquo; is added, when you run west update, it will be cloned to your zephyr working directory automatically.\n3.Install Zephyr SDK\nYou only need to install arm-zephyr-eabi cross tool to support IN6XXE.\nBuild the application # Board name of IN6XXE is \u0026lsquo;inplaydk_in612le\u0026rsquo;, you can start with a simple \u0026ldquo;blinky\u0026rdquo; sample:\ncd zephyrproject/zephyr\rwest build -p always -b inplaydk_in612le samples/basic/blinky Flash binary output # You should first refer to JFlash Download Guide to install InplayTools. After that, you can use Jlink to burn the binary output to the on-chip flash with command west flash.\nRun the sample # For the DK board, UART1 is configured as console in the source code, and the baud rate is 115200. There is an USB to UART chip(CH340) integrated on the board which is connected to UART1(GPIO21 as Tx, and GPIO27 as Rx), so you only need to connect the board to PC with USB Type-C cable to see logs or use shell. CH340 drivers should be installed first, you can download it from here. If the sample runs normally, you can see logs output to a serial terminal software like \u0026ldquo;putty\u0026rdquo;.\nSupported drivers # Only these drivers are supported now:\nGPIO pinctrl(partially implemented) UART(support tx and rx with interrupt, so you can use Zephyr shell) BLE hci driver "},{"id":33,"href":"/docs/in6xxe/getting-started/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"Getting Started","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and sync address. Each packet from the slave has its own preamble and sync address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. The data exchange can be configured to operate in three different modes between a master and multiple salves.\nPrivate data exchange mode The master can be configured to send each slave a private packet at each frame. Each slave can be configured to send the master a private packet at each frame. Private packet: There is acknowledgement between the sender and the recipient.\nPublic data exchange mode The master can be configured to send a public packet to all the slaves at each frame.\nPublic packet: Slaves do the acknowledgement. The master does not proceed to next public packet unless the current public packet is acknowledged by all the slaves.\nBroadcasting mode The master can be configured to send a broadcast packet to all the slaves at each frame.\nBroadcast packet: Slaves do not acknowledge the reception of a broadcast packet.\nOverview of transparent data transmission # Many modern applications rely on wireless data transmission; however, end-users often lack knowledge or interest in the underlying wireless technologies. Consequently, we have designed a mechanism that allows users to conveniently utilize the powerful data transfer capabilities provided by SMULL without the need to understand the details of this protocol. However, before starting the data transmission, it is necessary to configure the relevant parameters of SMULL to establish a network between the master and slave. By using the commands we provide, you can quickly establish the SMULL network. Please refer to the example provided below for more details. The schematic of the entire system, showing the connection between the host and IN618 module, is illustrated in Figure 3.\nTypically, the host refers to various devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default settings for the UART in our system are illustrated below.\nUART default settings # 115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # In order to facilitate software development with SMULL, we have designed a set of commands for programming. Users can effortlessly start the system by utilizing these commands.The command format is shown as following. Command Code Data Length Data 2 bytes 2 bytes variable bytes Get Slave Number: 0xA011 # This command gets the number of slaves in current network.\nSend: 0xA0 0x11 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x11 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Set Slave Number: 0xA012 # This command is used to configure the number of slaves.The slave number should be less than (or equal to) the maximum slave number (CFG_IPMAC_MAX_SLV_NUM).\nSend: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Response: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: the command sent is too short\nB0=0x02: number of slave is larger than the maximum value Notice:\nAfter successfully setting the slave number on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the slave number on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x13 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Sending this command to the master will not receive any response. Each slave in a network must have a unique ID.\nSend: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Response: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Slave ID is larger than or equal to the slave number which you set. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the slave ID will not be updated.\nGet SYNC Address (Network Address): 0xA015 # This command gets the SYNC address. Each established network should have a unique SYNC address (also known as network address).\nSend: 0xA0 0x15 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x15 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) SYNC Address = (B0 \u0026laquo; 24) | (B1 \u0026laquo; 16) | (B2 \u0026laquo; 8) | B3\nSet SYNC Address (Network Address): 0xA016 # This command can be used to set the SYNC address. The value 0x00000000 will be ignored and the address will not be updated. The value 0xFFFFFFFF also cannot be accepted.\nSend: 0xA0 0x16 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) Response: 0xA0 0x16 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: SYNC address is invalid. Notice:\nFor optimal performance, it is advisable to ensure that the SYNC address bit sequence does not contain four consecutive ones or zeros. Generally speaking, it is better to use a random value. For example,\n0x2954935B is a good value. There are no 4 consecutive ones or zeros in its bit sequence.\n0x10F10724 is not a good value. There are 4 consecutive ones or zeros in its bit sequence.\nAfter successfully setting the SYNC address on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the SYNC address on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet PHY Rate: 0xA017 # This command gets the PHY rate. The supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x17 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Set PHY Rate: 0xA018 # This command can be used to set the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Response: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: PHY Rate is invalid. Notice:\nAfter successfully setting the PHY rate on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the PHY rate on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x19 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x19 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: slave\nB0=0x01: master Set Mode: 0xA01A # This command is used to set the mode (master or slave) on the device. Each device will be configured as a master or a slave. In a network, only one device can be configured as a master.\nSend: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) B0 B0 should be 0 (slave) or 1 (master), other values are considered as invalid. Response: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Mode is invalid. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packet. Here, the downlink means the data are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1B 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Length = (B0 \u0026laquo; 8) | B1\nSet Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packet is 6 bytes. Ensure that the value you set is equal to or greater than 6.\nSend: 0xA0 0x1C 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Response: 0xA0 0x1C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00, success; B0=0x01, The command sent is too short; B0=0x02, Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of downlink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of downlink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Maximum Length of Uplink Private Packet: 0xA01D # the maximum length of uplink private packet. Here, the uplink means the data are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1D 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of uplink private packet (MSB) B1 maximum length of uplink private packet (LSB) Set Maximum Length of Uplink Private Packet: 0xA01E # Send: 0xA0 0x1E 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of uplink private packet (MSB) B1 maximum length of uplink private packet (LSB) Response: 0xA0 0x1E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of uplink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of uplink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Period of Heartbeat Packet: 0xA033 # In order to track the connection status of the network, heartbeat packet is periodically sent between the master and slave(s). Users can get the period of the heartbeat packet by issuing this command. The default value is 1000ms.\nSend: 0xA0 0x33 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x33 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) Set Period of Heartbeat Packet: 0xA034 # Users can change the period of the heartbeat packet by issuing this command.\nSend: 0xA0 0x34 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) If the period is zero, the default value (1000ms) will be used.\nResponse: 0xA0 0x34 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00:success\nB0=0x01:command sent is too short Notice:\nThe minimum heartbeat period is 500ms. Thus, the period you set should be larger than or equal to 500ms. If the period is less than 500ms, it will be automatically set to 500ms.\nBroadcast SMULL Settings: 0xA040 # With this command, the master can broadcast the SMULL settings. Once the network has been established, the master can use this command to broadcast the new SMULL-related parameters to all the slaves. The slave will update its settings and reset automatically upon receiving new settings broadcasted by the master.\nSend: 0xA0 0x40 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Broadcast Duration (MSB) B1 Broadcast Duration B2 Broadcast Duration B3 Broadcast Duration (LSB) The broadcast duration indicates the intended time period for the master to transmit new settings, measured in milliseconds. If this value is set to zero, the default value of 3000ms is utilized. To ensure successful reception by each slave, it is recommended to set this value to a minimum of 3000ms.\nResponse: 0xA0 0x40 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: The command sent is short\nB0=0x02: In slave mode, this command will be ignored Get SMULL status: 0xA041 # This command gets the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x41 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: it means the SMULL is successfully initialized\nB0=0xFF: it means the SMULL is not initialized. Notice:\nIf the initialization of SMULL fails, any SMULL related command that is issued will result in receiving the following response containing an error code 0xFF.\nCommand Code 0x00 0x01 0xFF\nRead SMULL settings: 0xA042 # The SMULL settings consist of 7 parameters: mode, slave number, slave ID, PHY rate, SYNC address, maximum length of downlink private packet and maximum length of uplink private packet. You can get all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) The length of data in successful response differs from that in failure response.\nSuccessful response: 0xA0 0x42 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that is used in your application. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Failure response: 0xA0 0x42 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Write SMULL settings: 0xA043 # As aforementioned, the SMULL settings include 7 parameters. You can set these parameters all at once by issuing this command.\nSend: 0xA0 0x43 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that may be used in your application. This number must be less than or equal to the value of CFG_IPMAC_MAX_SLV_NUM. As of the current firmware, CFG_IPMAC_MAX_SLV_NUM is set at 64. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Response: 0xA0 0x43 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: A general error\nB0=0x02: Command length is short\nB0=0x03: Invalid SMULL mode\nB0=0x04: Invalid slave number\nB0=0x05: Invalid slave Id\nB0=0x06: Invalid PHY Rate\nB0=0x07: Invalid SYNC address\nB0=0x08: Invalid downlink packet size\nB0=0x09: Invalid uplink packet size Query Connection Status of Each Slave: 0xA044 # The user can get the connection status of each slave by issuing this command on the master side.\nSend: 0xA0 0x44 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x44 0x00 0x10 B0~B15\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x10 Data Length (LSB) B0 The connection status of slave0 ~ slave7 \u0026hellip; \u0026hellip; B15 The connection status of slave120 ~ slave127 The byte sequence of data B0~B15 is a bit-map, each bit is associated with a slave. B0 is associated with slave0 to slave7, while B1 is associated with slave8 to slave15, and so on. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to show what a response might look like.\nExample1: Assuming that the maximum number of slaves is set to four and that all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00\u0026hellip;0x00. However, in the case where only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00\u0026hellip;0x00.\nExample2: Assuming that the maximum number of slaves is set to nine and that all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, in the case where only slaves 0, 1, 6, 7 and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00..0x00.\nIf this command is executed on the slave side, the response would be 0xA0 0x44 0x00 0x01 0x01.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packet. However, the slave can only trasmit private packets. Below, we will provide a detailed explanation on how to use this command for both the master and the slave.\n①Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively simple.\nSend: 0xA0 0x48 D0 D1 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long ②Master transmits data. The master can transmit three types of packets to the slave: private, public and broadcast. In current firmware, we only support private packet.\nSend: 0xA0 0x48 D0 D1 T0 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) T0 Packet type\n0x00: broadcast\n0x01: public\n0x02: private S0 Slave ID. If sending a private packet, it is necessary to specify which slave it is sent to. B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long\nB0=0x03: Invalid slave ID Receive Data: 0xA049 # When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the user in the following format.\n0xA0 0x49 D0 D1 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x49 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) S0 If data is received by the master, S0 denotes the slave ID.\nIf data is received by the slave, S0 denotes the packet type (0 = broadcast, 1 = public, 2 = private). B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Read UART Configuration: 0xA063 # This command read the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Successful Response: 0xA0 0x63 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control Response with errors: 0xA0 0x63 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control The maximum supported baud rate is 2000000.\nResponse: 0xA0 0x64 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x65 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Response: 0xA0 0x66 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Chip Reset: 0xA0E1 # Typically, when the SMULL parameters are updated, it is recommended to reset the chip by issuing this command.\nSend: 0xA0 0xE1 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xE1 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Example # Before the data transmission begins, it is essential to establish a network connection (also known as paring). In order to ensure successful network communication, the SMULL settings for both the master and each slave must be identical, with the exception of the mode and slave ID. Configuring the SMULL settings using UART can facilitate this consistency between the master and all slaves. To illustrate the process of setting up a network, we will provide an example. Each parameter for the network is presented below.\nMode: (master: 0x01, slave: 0x00) Slave number: 4 Slave Id: (0x00 ~ 0x03), master will ignore this value Phyrate: 2M Address: 0x2954935B Maximum length of downlink packet: 10bytes Maximum length of uplink packet: 100bytes Two methods can be used to achieve the configuration. Method 1 requires the use of command 0xA043,whereas method 2 entails a combination of commands 0xA01A, 0xA012, 0xA014, 0xA018, 0xA016, 0xA01C, 0xA01E. Once the configuration is completed successfully, it is necessary to execute the reset command.\nMethod1:\nThe command sequence issued by the master would be\n①0xA0 0x43 0x00 0x0C 0x01 0x04 0x00 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave (slave0~slave3) would be\n①0xA0 0x43 0x00 0x0C 0x00 0x04 ID 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nMethod2:\nThe command sequence issued by the master would be\n①0xA0 0x1A 0x00 0x01 0x01\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 0x00\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave would be\n①0xA0 0x1A 0x00 0x01 0x00\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 ID (different slave ID)\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nIn method2, the order of the command sequence is not mandatory. However, the command 0xA014 should be issued after 0xA012 and the reset command must be the final one.\n"}]