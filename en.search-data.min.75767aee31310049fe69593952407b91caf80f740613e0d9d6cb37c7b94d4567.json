[{"id":0,"href":"/docs/in6xxe/user-guides/nanosync-technology/advanced-timer-guide.html","title":"NanoSync Timer Guide","section":"NanoSync Technology","content":" NanoSync Timer Guide # Introduction # The NanoSync timers(Advanced Timer) are capable of capturing the times of multiple real-time triggers or events simultaneously. The NanoSync timers can be also used as trigger sources for the NanoSync engine(Trigger Handler). If the current time of a NanoSync timer equals to the programmed target time (called emit time), a trigger (We also call the trigger from SyncTimer as an emit) happens. Each SyncTimer supports up to 10 emit time target. The emits also support direct control of a GPIO output without any latency.\nBasic Timer # The timer0 to timer9 are basic timers, which support timeout functionality and manual counting.\nNanoSync Timer(Advanced Timer) # Timer 0, timer 1 and timer 6 are advanced timer, supporting capture and emit functionalities.\nCapture # Advanced timers can capture signals, obtaining timestamps of the signals\u0026rsquo; rising or falling edges. These signals can be GPIO inputs or BLE TRX signals, refer to the Trigger (NanoSync Engine) document for signal details. Each timer can capture up to 4 signals simultaneously.\nEmit # Advanced timers can emit a signal when they reach the target timestamp. The trigger handler can use this emitted signal as input. Each advanced timer can emit up to 10 signals.\nOutput emit signal on GPIO # Using testmux, it\u0026rsquo;s possible to output emitted signals on GPIO. Each advanced timer can output up to 10 emit signals and 5 toggle emit signals. The emit signal is a pulse signal, and two emit signals combine to produce one toggle emit signal, controlling both its rising and falling edges.\nCapture and Emit with Shared memory # Advanced timers can use shared memory to capture and emit signals. With shared memory, it can capture one signal and emit one signal simultaneously. For instance, it can capture signal 0 and write its timestamp to shared memory, and emitting signal 0 with the timestamp stored in shared memory.\nAPI # See Timer API Document for details.\n"},{"id":1,"href":"/docs/in6xxe/api-documatation.html","title":"API Documentation","section":"IN6XXE","content":"Please click the following link:\nAPI document link\n"},{"id":2,"href":"/docs/in6xxe/examples-and-use-case/debug-reference.html","title":"Debug Reference","section":"Examples and Use Case","content":" Debug Reference # Configuration and Connection during Debug # To connect with the IN628E, we should use a terminal emulator with following setting,\nPort: according to your device.\nBaud Rate: 115200.\nData bits: 8.\nStop bits: 1.\nParity: None.\nFlow control: None.\nUART Tx Pin: default is GPIO_2_1.\nUART Rx Pin: default is GPIO_2_7.\n"},{"id":3,"href":"/docs/in6xx/getting-started/testing/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Testing and Debuging","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:\nTerminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\\tools\\ InPlayToolsSetup.exe, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, JLink will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":4,"href":"/docs/in6xxe/getting-started/testing/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Testing and Debuging","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:\nTerminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\\tools\\ InPlayToolsSetup.exe, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, JLink will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":5,"href":"/docs/solutions/modbus/wireless-modbus-demo-guide.html","title":"Wireless Modbus Demo Guide","section":"Wireless Modbus Network","content":" Wireless Modbus Demo Guide # Demo Connections # This guide demonstrates connecting the Wireless Modbus Module, featuring a port with four pins: Vin, GND, A, and B.\nLikewise, the Sensor and Relay devices offer one or more similar ports, each with pins designated as A, B, GND, and VCC. The \u0026lsquo;A\u0026rsquo; and \u0026lsquo;B\u0026rsquo; pins facilitate RS485 connections, while VCC and GND pins cater to power connections, requiring a power supply voltage of 5V or greater.\nConnection Guidelines # Ensure the correct pins are connected as advised below:\nA to A B to B V to V (either Vcc or Vin) G to G (represents GND) Configuration # It is crucial that the RS485 baud rate be set correctly. For example, the sensors support only 4800 bps. The relay RS485, however, is compatible with 4800, 9600, and 91200 bps. Hence, we suggest configuring both the Wireless Module and the relay to 4800 bps for peak performance.\nDemo GUI Guide # Modbus RTU Serial Client GUI version: 0.8\nThe Demo GUI\u0026rsquo;s main window features three dock windows—Indicator, Sensor, Command—a toolbar with various control buttons, and a status bar at the bottom displaying serial connection states and settings.\nThe Toolbar has changed in version: 0.9\nOperations # Steps:\nConfirm Serial settings Ascertain Modbus request and response patterns of relay and sensor Connect COM port Scan devices Control devices Serial Configuration # Navigate to Setting/com to open a dialog window and modify serial settings parameters such as baud rate, data bits, stop bits, parity, and timeout. Click \u0026ldquo;confirm\u0026rdquo; to apply these settings.\nRelay Configuration # Access Setting/relay to open a dialog window and adjust the relay settings:\nSearch\nCount: Number of \u0026ldquo;relay\u0026rdquo; devices found. This parameter may be omitted. Maximum: The number of devices required. The search halts when the count meets this figure. Read Pattern: Triggers a search for relay devices upon clicking the toolbar\u0026rsquo;s Relay Search button. For instance, xx, 01, 0000, 0008 represents a Read Coils request in Modbus RTU format without crc16. Control\nWrite Pattern: Functions akin to Read Pattern; employs Function 05 (05hex) Write Single Coil. Response Pattern: Reactions following the requests. Sensor Configuration # Select Setting/sensor to amend sensor configurations:\nMonitor\nStart ID: Commencing address ID of the sensor device when monitoring is active. End ID: Terminal address ID of the sensor device when monitoring is active. Read Pattern: Command request for procuring sensor data, using function code 03. Value Upon receiving the slave\u0026rsquo;s response, the GUI parses the data list and employs formulas to calculate values.\nConnect and Run # Choose the appropriate COM Port and hit the Connect button in the toolbar. The status bar will exhibit the connection state.\nVersion 0.9 as below:\nVersion 0.8 as below:\nPressing the Network Scan Discovery (which is Start All in v0.8) button ignites the Relay Search and Sensor Monitor, proceeding as per the Settings to dispatch requests. The Command dock window relays messages of both requests and responses.\nShould relay or sensor devices be located, the Indicator and Sensor dock windows will relay pertinent information such as \u0026ldquo;lamp buttons,\u0026rdquo; alongside temperature and humidity graphs.\nVersion 0.8 as below: Indicator and Sensor sections incorporate selectors and buttons for demonstrating various actions.\nAnd in version 0.9 update the sensor\u0026rsquo;s dock window:\nSet \u0026ldquo;Temp upper\u0026rdquo; and \u0026ldquo;Temp lower\u0026rdquo; to adjust the temperature display limits on the graph.\nManual Command Input # Located at the Command dock window\u0026rsquo;s base, a manual command input area exists for entry of Modbus RTU requests (sans crc). Click Send Request post-entry to dispatch the command.\nStatus in Command # The Command dock window\u0026rsquo;s Status presents a tally of the requests and responses.\nAn input field is provided to insert metrics for computing the packet loss rate. When left blank or set to zero, all data is considered in the statistic.\nMenu # Additional operations within the menu are outlined here. Clicking File/Restore Setting regenerates a default setting.json file, which is then loaded by the Setting menu option.\nEditing the setting.json file can be accomplished with an external editor, replacing the same-name file in the GUI program\u0026rsquo;s directory.\nThe View menu permits modification of the GUI\u0026rsquo;s visual appeal, such as font selection, and toggles the display status of Dock Windows.\nIn version 0.9, View menu permit toggles the display of \u0026ldquo;other tools\u0026rdquo; in toolbar.\nThe Help menu grants access to assorted explanatory documents, including a GUI usage guide.\n"},{"id":6,"href":"/docs/solutions/modbus/wireless-modbus-module.html","title":"Wireless Modbus Module","section":"Wireless Modbus Network","content":" Introduction to the Wireless Modbus Module # Overview of the Modbus Protocol # Modbus is an application-layer messaging protocol, designed in 1979 by Modicon, which facilitates master/slave interaction between devices. A de facto communication standard in industrial electronics, it has the following features:\nMaster-Slave Architecture: One master device issues commands to one or more slave devices that respond in kind. Data Representation: Modbus categorizes data as either coils (binary) or registers (numeric), offering diverse data manipulation capabilities. Variants: Modbus has adapted to different environments with variants like Modbus RTU, Modbus ASCII, and Modbus TCP/IP. The RS485 Communication Standard # RS485, or EIA-485, prescribes electrical specifications for drivers and receivers in digital multipoint systems. It is characterized by:\nExtended Communication Range: Capable of transmitting data up to 4000 feet (~1200 meters). Noise Resistance: Differential signaling provides robustness against voltage fluctuations and electromagnetic interference. Multi-Drop Configurations: Supports up to 32 devices on a single bus network. RS485\u0026rsquo;s reliability is a cornerstone of industrial controls in leveraging Modbus protocol.\nConnection # RS485 Connection # A standard RS485 wiring diagram depicting a \u0026ldquo;daisy-chain\u0026rdquo; topology is shown:\nConnection of the Wireless Modbus # Replacement of wired RS485 connections with a wireless module:\nFeatures of the Wireless Modbus Module # Firmware version 0.2\nThe module supports baud rates [in bps]: 1200 to 1000000, including automatic master node baud rate detection and synchronization.\nCommunication Between Master and Slave # The interaction comprises the master\u0026rsquo;s request, the slave\u0026rsquo;s response, and the corresponding response times as shown:\nExample timing for a 69-byte request and 8-byte response Modbus RTU query. Response timing across UART and wireless PHY settings:\nUART Settings Net PHY Speed Response Time [ms] 4800-8-1-E 1M 222 9600-8-1-E 1M 127 14400-8-1-E 1M 94 19200-8-1-E 1M 76 115200-8-1-E 2M 28 500000-8-1-E 2M 17 Configurations and User Interface # Configuration channels include ATCMD, UART-based commands, physical interfacing (buttons/switches), and upcoming BLE.\nLED Indicators # Two LEDs (Blue and Red) denote operational states. Patterns of their light signify network status and the network node mode. It varies as follows - fast flash, slow flash, and constant on. For example:\nState LED Activity LED Interval Network Loss Fast flash: 100ms on/off 500ms off Network Sync Continuous: 3sec on 500ms off Network Wait Slow flash(500ms on/off) 500ms off Dip Switch Configuration # Settings like SW1 and SW2 determine network status and node mode, respectively.\nSetting RS485 parity with SW3 and SW4.\nSwitch Function Description SW1 Network start/config On: Activate; Off: Default. See below. SW2 Node mode On: Master; Off: Slave. SW3 RS485 parity enable On: Enable parity; Off: Disable parity SW4 RS485 parity mode On: ODD Parity; Off: EVEN parity SW1 Configuration Details\nON to OFF: Trigger reconfiguration; a fast flash indicates readiness to reconfigure. AT Commands # Each command starts with AT and ends with a terminator. The command and response bodies vary by read parameter or result code.\nNormal AT Commands # Command Response Description AT+MODE=?, +MODE=[m,1,0] Read the device Mode. m: 1, master; 0, slave. AT+STATE=?, +STATE=[x,p,ch] Read net state. x:1, sync; 0, loss. p: phy. ch：channels AT+UART=? +UART=[baud,data,stop,parity,th] Read RS485 UART setting. baud:baudrate; data:data bits(8); stop: stop bits(0: 1bit, 1: 2bits), parity:(0:disable, 1: odd, 2: even); th: internal threshold. AT+PKTL=?, +PKTL=[up,dn] Read data packege size. up: uplink size; dn: downlink size AT+PKTL=[up,dn], Result code Write data packege size. up: uplink size; dn: downlink size AT+LOG=x Result code Write Log enable level x: bit[0:2]. 3 levels AT+ADDR=? +ADDR=[xxyyxxyy] Read net address. xxyyxxyy: address AT+ADDR=[xxyyxxyy] Result code Write net address. xxyyxxyy: address. sendAT+SYSCMD=3save config and sendAT+SYSCMD=1 to apply AT+VER=? +VER=[xxH] Read firmware version AT+NET=? +NET=[p,t,d,u] Read net information. p:phy, t: type, d:downlink length; u:uplink length AT+SYSCMD=x Result code Send system command. x: 1, reset; 2, restore; 3, save config. Responses follow the \u0026lt;CR\u0026gt;\u0026lt;LF\u0026gt; structure.\nResult Codes # Result codes for command outcomes:\n0 for success, 0x1001 for\tCommand execution error 0x100A for\tBad command 0x100B for\tBad format 0x100D for\tBad parameter 0x100E for\tOvertime Others for\tProtocol stack error Advanced Commands # There are also advanced commands for specialized tasks.\nFor detailed information, consult the Engineer\u0026rsquo;s Manual.\n"},{"id":7,"href":"/docs/in6xxe/user-guides/driver-integration/adc-guide.html","title":"ADC Guide","section":"Driver Integration","content":" ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.\nKey Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.\nMode # There are two modes for the ADC:\nForce Mode In Force Mode, the ADC samples a single channel once and returns the result.\nAuto Mode Auto Mode allows the ADC to continuously sample multiple channels. It is capable of sequential sampling across several channels. The results will be put into shared memory through DMA.\nChannels # The ADC supports measurement from 15 channels, including:\n12 input channels (analog/digtal mixed pins) 1 analog input channel (ADC_CH_IN) 1 VBAT (Voltage Battery) channel 1 temperature sensor channel enum adc_ch{ ADC_CH0 = 0, ///\u0026lt;ADC_CH_IN ADC_CH1, ///\u0026lt;GPIO_2_9 ADC_CH2, ///\u0026lt;GPIO_2_8 ADC_CH3, ///\u0026lt;GPIO_2_7 ADC_CH4, ///\u0026lt;GPIO_2_6 ADC_CH5, ///\u0026lt;GPIO_2_5 ADC_CH6, ///\u0026lt;GPIO_2_4 ADC_CH7, ///\u0026lt;GPIO_2_3 ADC_CH8, ///\u0026lt;GPIO_2_2 ADC_CH9, ///\u0026lt;GPIO_2_1 ADC_CH10 = 10, ///\u0026lt;GPIO_2_0 ADC_CH11, ///\u0026lt;GPIO_3_1 ADC_CH12, ///\u0026lt;GPIO_3_0 ADC_CH14 = 14, ///\u0026lt;VBAT ADC_CH15 = 15, ///\u0026lt;temperature sensor }; Note:\nChannel 13 is only for internal usage.\nVref # The Vref (Reference Voltage) can be configured as either 1.0V or 1.5V. The ADC\u0026rsquo;s range is 2*Vref. And the maximum ADC sample value is 0xFFF. Note:\nDon’t input voltage higher than 2*Vref to ADC pin.\nChannel 14(VBAT) and channel 15(temperature) can only use 1.0V Vref.\nCapture clock # Should set capture clock base on input impedance.\nCaputure clock frequency = 1 / (14*Rs*C) Rs is input\u0026#39;s output resistance (Rs). C is internal capacitor, it is 11 pF. Note:\nIf use a lower capture clock, will get a lower ADC sample rate.\nIf use a higher capture clock, it may be necessary to discard the first few samples.\nGroup interval # The group interval refers to the sampling interval between groups of samples in auto mode. The unit is us (the ADC clock is set to 1MHz) with the range of 0~255, and the default value is 16us.\nConfigration # Configration tool\nSelect \u0026ldquo;SADC\u0026rdquo; in SwiftConfig tool peripheral tab. If use auto mode, select \u0026ldquo;Sensor ADC\u0026rdquo; in Misc tab. And set SMEM size. A single sample has 2 bytes, and the minimum required size can be calculated according to the number of needed samples. SMEM size = all channel samples * 2 Example code # Force Mode Sample channel 5 in force mode:\nadc_dev_t * dev = hal_adc_open(); hal_adc_force_mode_enable_ch(dev, ADC_CH5); uint16_t buff[16]; int res = hal_adc_force_mode_start(dev, ADC_CH5, buff, 16); Auto Mode Enable \u0026ldquo;ADC_CH1\u0026rdquo; and \u0026ldquo;ADC_CH2\u0026rdquo;, get 32 samples for each channel.\nThe sampling order is shown as follows,end after 32 cycles:\nCH1 CH2 CH1 CH2 CH1 CH2 …\nuint8_t buf1[32]={0}; uint8_t buf2[32]={0}; adc_dev_t * dev = hal_adc_open(); hal_adc_auto_mode_enable_ch(dev, ADC_CH1, buf1, 32); hal_adc_auto_mode_enable_ch(dev, ADC_CH2, buf2, 32); hal_adc_auto_mode_start(dev,32, osWaitForever); Convert data # Convert raw data to voltage and temperature.\nUse \u0026ldquo;hal_adc_sample_convert\u0026rdquo; to covert raw data to voltage for channel0 ~ channel 12. Use \u0026ldquo;hal_adc_vbat_sample_convert\u0026rdquo; for channel 14. Use hal_adc_temp_sample_convert\u0026quot; for channel 15. These API use calibration data for coverting.\n"},{"id":8,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/adc-sample.html","title":"ADC Sample","section":"Driver Examples","content":" ADC Sample # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_adc in-dev/proj/driver/proj_drv_adc Configuration # #define FORCE_MODE 1 //0: auto mode, 1: force mode Define whether choose force mode or not.\n#define FORCE_MODE_SAMPLE_NUM 16 #define AUTO_MODE_SAMPLE_NUM 16 Define the sample num in adc test.\n#define DISCARD_NUM 0 ///\u0026lt; skip adc sample number Define the sample num need to be discarded.\n#define CH_NUM 4 Define the adc test total channel num.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of sample value, test content and value according to UART Log. The following are samples: VBAT ch:14 =0xab3 3294.8mV,\ntest content: VBAT/Temperature/...\nchosen channel: ch:...\nmeasurement value: =0x...\nconverted value: here is 3294,8mV\nMore information may be found in debug guide page.\nTest Steps # force mode\nOpen Keil and set FORCE_MODE to be 1, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. auto mode\nOpen Keil and set FORCE_MODE to be 0, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. "},{"id":9,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/aes-sample.html","title":"AES Sample","section":"Driver Examples","content":" AES Sample # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.\nAES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted. AES encryption has three modes: ECB (Electronic Codebook), CBC (Cipher Block Chaining), and CFB (Cipher Feedback).\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_aes in-dev/proj/driver/proj_drv_aes Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of encryption to UART Log. If test pass, ...passed or ... successed will be shown on UART log.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil, download proj_drv_aes. Press the reset button and observe the log for the message main start.... The status of encryption will be shown on UART log. "},{"id":10,"href":"/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html","title":"Antenna Diversity","section":"Driver Integration","content":" Antenna Diversity # Overview # The antenna diversity engine supports signal RSSI evaluation and antenna switching, and it supports both dual and 4 antennas. Signal evaluation and antenna switching are performed in the background by the chip\u0026rsquo;s hardware modules.\nAPI # initialization. # int hal_ana_diversity_init(uint8_t num_ants, uint8_t frz_time, uint32_t agc_stable_time);\rvoid hal_ann_2diversity_gpio25_invgpio00_sw_init(void);\rvoid hal_ann_4diversity_gpio25_gpio26_sw_init(void); Example of Dual Antenna # int main(void)\r{\rint res;\ruint8_t tx_buf[16];\rsdr_mstr_scan_t scan_cfg;\rhal_global_post_init();\rPRINTD(DBG_TRACE, \u0026#34;%s %s\\r\\n\u0026#34;, __DATE__, __TIME__);\rPRINTD(DBG_TRACE, \u0026#34;CHIP ID = %08X\\r\\n\u0026#34;, chip_get_id());\rhal_ana_diversity_init(2, 40, 40); hal_ann_2diversity_gpio25_invgpio00_sw_init();\rres = in_sdr_init();\rif (SDR_ERR_OK != res)\r{ PRINTD(DBG_ERR, \u0026#34;in_sdr_init failed %d\\r\\n\u0026#34;, res);\rreturn 1;\r}\rscan_cfg.chn = 37;\rscan_cfg.txr = PHY_RATE_1M;\rscan_cfg.rxr = PHY_RATE_1M;\rscan_cfg.aa = 0x8E89BED6;\rscan_cfg.rxw_sz = 0x80ff;\rscan_cfg.rx_arg = NULL;\rscan_cfg.rx_callback = sdr_rx_callback;\rhw_ana_set_tx_power(TX_POWER_7);\rwhile (1) { res = in_sdr_mstr_scan(\u0026amp;scan_cfg, tx_buf, 0);\rif (SDR_ERR_OK != res)\r{\rPRINTD(DBG_ERR, \u0026#34;SDR scan failed %d\\r\\n\u0026#34;, res);\r}\r}\rreturn 1;\r} "},{"id":11,"href":"/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html","title":"AOA Antenna Guide","section":"Driver Integration","content":" AOA Antenna # Overview # AOA Antenna engine supports antenna switching and IQ capture,as shown in the following Figure.AOA Antenna engine supports IQ capture for constant tone inside the payload and attached to the packet after CRC.\nBelow are some key features of the AoA antenna switching IQ capture engine:\nProgrammable SYNC address (preamble is not programmable) Programmable channel index and frequency relationship The enable/disable of whitening is programmable (the whitening sequence is not programmable, it is decided by the channel index) Support up to 256 antenna patterns. The antenna pattern can be directly to control the outputs of 8 GPIOs. Programmable starting time for IQ capture and antenna switching (as shown in above figure) Programmable antenna switching pattern Programmable duration for each antenna (in terms of how many clock cycles of a 2MHz clock) 4 programmable capture speeds: 8, 4, 2 and 1 MSPS Capture length is up to 8192 IQ samples (For 8 MSPS IQ capture speed, it means we can capture IQ samples up to 1024 us). Two programmable raw IQ capture word length: 14-bit and 12-bit in 2’s complement. Readable IQ capture status: the starting address in capture memory and length Two AGC operation modes (SW programmable) Freeze after SYNC is found Always adjust the gain according to the input signal level IQ and Antenna switching for constant tone inside the payload (before CRC) or after CRC Design Details # The following Figure shows the AoA antenna switching and IQ capture scheme. The AoA captured is controlled by the AoA controller. Once the controller detects a valid special signal (by matching the sync address that user has programmed), the controller uses the SYNC valid signal to generate various RX antenna switching signals and automatically captures the IQ samples.\nAntenna Switch # AOA Antenna engine support a sequence of RX antenna switch signals as shown in the above figure, which have the following feature:\nThe sequence consists of multiple 8-bit patterns (up to 256 patterns). Each of bit of a pattern can be mapped to an GPIO output. The sequence can have up to 256 patterns. Each pattern has its own programmable duration (10-bit, unit 0.5us). The sequence consists of:\nPattern 0 and its duration Pattern 0 is the default antenna pattern, and it is used upon RX enabled. Pattern 0 duration: This duration is measured starting from SYNC found. Pattern 1 and Pattern 1 duration Pattern 2 and Pattern 2 duration …… The last pattern and the last pattern duration The last pattern duration is a don’t care, it means the pattern will be used until the end of the RX regardless of the time being programmed. All the above durations have a unit of 0.5us and can be up to 511.5 us. If the specified duration is 0, it means that the corresponding antenna will be used until the end of RX.In normal case, if SYNC is found, then the antenna switch will be always like (Pi denotes pattern i).P0, P1, P2, …, PN. If the received signal is not good (like SYNC is not found), the switching may end early and stop before PN where PN is the last pattern.\nIQ Data Capture # Once RX is enabled, IQ data along with the used antenna pattern are captured into memory if AoA is enabled. The captured data are written into memory in a circular way. If the address reaches its maximum, the address wraps around.\nOnce a SYNC is found, the address holds the captured data when SYNC found happens is written into a status register which user can access. The IQ capture keeps going until the IQ capture duration expires.The IQ capture can be captured starting from SYNC found or be captured since RX is enabled. In the first case, the memory with address offset of 0 holds the IQ capture when SYNC is found. In the second case, there is a status register which tells us the address offset of the IQ capture when SYNC is found.\nEach IQ capture occupies 4 bytes, the device supports up to 8192 IQ captures. The IQ capture can be captured at a speed of 8 MSPS, 4 MSPS, 2MSPS and 1 MSPS (user programmable).\nBit-patten match and mask # AOA Antenna engine also supports a feature that only if both SYNC match and some of bits in a 32-bit sequence match, the device starts to do AoA antenna switch and IQ capture.\nIf this feature is enabled, besides the SYNC, the AoA antenna switch and IQ capture also rely on the received bits. The user can program where the 32-bits starts (i.e., the bit position offset in following figure), the 32-bit pattern which user want to let the hardware to compare with the received bits. In addition, the user can program a mask in case only some selected bits in the 32-bit pattern need to be matched. API # initialization. # typedef struct aoa_cap_ant_pattern_s\r{\ruint16_t duration;\ruint8_t addr;\r} aoa_cap_ant_pattern_t;\rtypedef struct aoa_cap_filter_s\r{\rint8_t enable;\rint8_t channel;\ruint32_t bit_pattern; //B0 is header[0];B1 is header[1];B2 is address[0];B3 is address[1]\ruint32_t bit_mask;\r} aoa_cap_filter_t; const aoa_cap_ant_pattern_t *patterns is antenna switch pattern, int size is size of patterns, maximum is 256, aoa_cap_filter_t *filter is bit-patten match and mask void (*on_data)(uint32_t *data, uint16_t samples the callback function will be called when finish.\rvoid hal_ana_aoa_capture_init(const aoa_cap_ant_pattern_t *patterns, uint8_t pattern_size, aoa_cap_filter_t *filter, void (*on_data)(uint32_t *data, uint16_t samples)); "},{"id":12,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-advertising-sample.html","title":"BLE advertising Sample","section":"BLE Examples","content":" BLE Advertising Sample # Overview # Bluetooth advertising is based on the transmission of advertising packets. An advertising packet is a small amount of data that contains device identifiers and other relevant information. The transmission of advertising packets is connectionless, meaning that it does not require pairing or connection operations before establishing a Bluetooth connection.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_adv_conn in-dev/proj/BLE/proj_ble_adv_conn Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_adv_conn. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. We can search for the device with the corresponding address on a Bluetooth device. If we have two development boards, we can download the proj_ble_init project on another board. The board with proj_ble_init can automatically connect to the board with proj_ble_adv_conn. "},{"id":13,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-gatt-sample.html","title":"BLE GATT Sample","section":"BLE Examples","content":" BLE GATT Sample # Overview # GATT (Generic Attribute Profile) is a protocol introduced in Bluetooth that defines the communication rules between Bluetooth devices. It enables different types of Bluetooth devices to communicate and exchange data efficiently, particularly in Bluetooth Low Energy (BLE) devices such as smart bracelets, watches, and health monitoring devices.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_gatt_service\u0026amp;proj_ble_gatt_write in-dev/proj/BLE/proj_ble_gatt_service\u0026amp;proj_ble_gatt_write Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both central and peripheral according to Uart Log. The following are samples,\nCentral # start initiation process start init connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... Peripheral # start advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... More information may be found in debug guide page.\nTest Steps # Central Download and run the proj_ble_gatt_write project.\nThe Bluetooth device initiates a connection request.\nAfter a successful connection, central would enable peripheral notification and we can view the address information of the Bluetooth device on the Terminal Emulator.\nThe Bluetooth device sends a write request to the development board periodically.\nPeripheral Download and run the proj_ble_gatt_service project. The Bluetooth device starts advertising. After a successful connection, we can view the address information of the Bluetooth device on the Terminal Emulator. The Bluetooth device sends a notify request to the development board periodically. "},{"id":14,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-initiation-sample.html","title":"BLE Initiation Sample","section":"BLE Examples","content":" Ble Initiation Sample # Overview # The Bluetooth connection initiation mode refers to the method utilized by a Bluetooth device to proactively initiate a connection with other devices. Within Bluetooth communication, there are typically two connection modes: Central and Peripheral. The Central mode represents the party that takes the initiative in establishing the connection, whereas the Peripheral mode signifies the party that passively accepts the connection.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_init in-dev/proj/BLE/proj_ble_init Debug # We can get the status of development board according to Uart Log. The following are samples,\nCentral # start initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nPeripheral # start advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_init (Central), and on another development board, download proj_ble_adv_conn (Peripheral).\nPress the reset button on the central board and the peripheral board, observe the text CHIP ID = appear in the log, and begin scanning based on the settings in in_config.h.\nWhen scanning for devices with the Peripheral address, the Central will initiate a connection request to the Peripheral, and the Peripheral will accept the connection request, establishing a Bluetooth connection.\n"},{"id":15,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-keyboard-sample.html","title":"BLE Keyboard Sample","section":"BLE Examples","content":" BLE Keyboard Sample # Overview # Bluetooth is widely used in wireless mouse and keyboard, this is an example for chip to plays a role of keyboard using bluetooth.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_Keyboard in-dev/proj/BLE_no_os/proj_ble_Keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... send keyboard command report idx=0 More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_Keyboard. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. We can search for the device with the corresponding address on a Bluetooth device. Connect to the device and send bond request to the device. After that, we will get keyboard information a for 3 seconds. "},{"id":16,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-scan-sample.html","title":"BLE Scan Sample","section":"BLE Examples","content":" Bluetooth Scan Sample # Overview # In Bluetooth Low Energy (BLE), scanning is the process where a BLE central device (such as a smartphone or a BLE-enabled gateway) actively searches and listens for advertising packets from nearby BLE peripheral devices. The scanning process allows the central device to discover and connect to nearby peripherals.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_scan in-dev/proj/BLE/proj_ble_scan Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart scan process: start scan get advertising data from other BLE device: *** ADV DATA FROM...*** , ...means the address of other device. More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_scan. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. After device scanning start, we can get advertising data from other BLE device. "},{"id":17,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-transparent-transmission-sample.html","title":"BLE Transparent Transmission Sample","section":"BLE Examples","content":" BLE Transparent Transmission Sample # Overview # In Bluetooth data transparent transmission, the sending device packages the raw data into Bluetooth data packets and sends them to the receiving device through the Bluetooth connection. After receiving these data packets, the receiving device can directly read and parse the raw data without any decoding or processing.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_trx_clt\u0026amp;proj_ble_trx_svc in-dev/proj/BLE/proj_ble_trx_clt\u0026amp;proj_ble_trx_svc Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both central and peripheral according to Uart Log. The following are samples,\nCentral # start scan process Scan start\nstart initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nReceive data TRX RX: len=...\nPeripheral # start advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... More information may be found in debug guide page.\nTest Steps # Using a Single Development Board Download and run the proj_ble_trx_svc project. The development board starts Bluetooth broadcasting, allowing the Bluetooth device to search and find the broadcast data. The Bluetooth device initiates a connection request. After a successful connection, we can view the address information of the Bluetooth device on the Terminal Emulator. The Bluetooth device sends a write request to the development board. The developer inputs data on the Terminal Emulator and sends it. The development board transmits data to the Bluetooth device, which will display the same data content upon receiving it. Using Two Development Boards Central downloads the proj_ble_trx_clt, while Peripheral downloads the proj_ble_trx_svc. Reset Central device and Peripheral device. Peripheral development board starts Bluetooth broadcasting, allowing Central to search and find the broadcast data. Central initiates a connection request. After a successful connection, we can view the address information of the other party on Uart log. On the client side of the Uart, input data and send it. The client sends a write request to the server, and the server receives the same data. The developer on the Peripheral side inputs data and sends it. Peripheral transmits data to the Central, which will display the same data content upon receiving it. "},{"id":18,"href":"/docs/in6xxe/protocols-reference/ble/inplay-ble5.0-at-command-set.html","title":"BLE5.0 AT Command Set","section":"BLE","content":" Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.\nIN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.\nCONTROL INTERFACE # The AT commands are transmitted over standard UART interface. A terminal emulator, such as TeraTerm (Windows) or CoolTerm (Mac OS-X®), can be used to control the module from a computer, with the following default port settings:\n115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The serial port parameter configure command can modify the UART settings permanently.\nSYNTAX # The AT commands can be divided into 3 main categories: Command, Response and Event. The module receives Command and, after execution, sends back Response to the command initiator. When something happens in the module, such as an unexpected disconnection, receiving data from a remote device, etc., a corresponding Event is sent.\nCOMMAND SYNTAX # An AT command is composed of the Prefix, CommandID, CommandBody and Terminator as shown below.\nAT+\u0026lt;CommandID\u0026gt;=\u0026lt;CommandBody\u0026gt;\u0026lt;Terminator\u0026gt; The Prefix of each command is fixed ASCII string \u0026ldquo;AT\u0026rdquo; or \u0026ldquo;at\u0026rdquo;.\nCommandID is an ASCII string representing different command. It\u0026rsquo;s case sensitive.\nCommandBody can be either ASCII \u0026lsquo;?\u0026rsquo; if the command gets a parameter or parameters set if the command sets parameter. A parameter set is a collection of parameters surrounded by \u0026lsquo;[]\u0026rsquo;, each separated by \u0026lsquo;,\u0026rsquo;.\nTerminator of each command is carriage return (CR, \u0026lsquo;\\r\u0026rsquo;, \\x0d) and line feed (LF, \u0026lsquo;\\n\u0026rsquo;, \\x0a). Command is accepted and executed only when the Terminator is received.\nRESPONSE SYNTAX # After an AT command is executed, a response will be sent back. Response consists of corresponding CommandID, ResponseBody and Terminator as shown below.\n+\u0026lt;CommandID\u0026gt;=\u0026lt;ResponseBody\u0026gt;\u0026lt;Terminator\u0026gt; If command is to set parameter, the ResponseBody is either parameter set read or just a numerical error result code. The format of the read parameter set is same as the format of the set parameters of the corresponding command. Only result code is returned for set parameter commands.\nEVENT SYNTAX # An event is a message reported by the module initiatively, rather than a response obtained through the AT command. An event consists of EventID, EventBody and Terminator as shown in below.\n+\u0026lt;EventID\u0026gt;=\u0026lt;EventBody\u0026gt;\u0026lt;Terminator\u0026gt; EventID is an ASCII string representing different event. It\u0026rsquo;s case sensitive. EventBody is a parameter set and its format is same as CommandBody in AT command. Terminator is same as that in AT command response.\nPARAMETER VALUE # Parameter in parameter set supports numeric values, strings. There are three format of string: ASCII format string, Byte Array format string and Base64 encoding format string.\nEXAMPLES # The below table lists some examples of AT commands and their responses and events.\nCommand/Event Function Response AT+DEVCFG=[10,\"112222222211\",0,\"Slave\",1] Set device general configuration +DEVCFG=0000H AT+DEVCFG=? Get device general configuration +DEVCFG=[10,\"112222222211\",0,\"Slave\",1] AT+CFGADVACTV=[1,0,1,500,0,\"BwlJbnBsYXk=\"] Create legacy connectable advertising in 500ms interval. The payload is local name \"Inplay\" +CFGADVACTV=0000H: successful\n+CFGADVACTV=0043H: error advertising can't be create -EVTCONN=[1,\"EFBBCCCCDDEF\",1,1] Connected with device \"EF:DD:CC:CC:BB:EF\" on 1M PHY COMMAND REFERENCE # This section describes AT commands in detail and provides examples. Those parameter surrounded by \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; brackets are optional in some cases. If an optional parameter needs to be set, all optional parameters prior to that optional parameter must also be provided.\nSince the responseBody of the response returned by the get command is the same as the CommandBody of the corresponding set command, for simplicity, only the format of the get command is listed.\nGet Module State # This command gets the current status of the module.\nCommand: AT+STATE=?\nResponse: +STATE=[sys_state,pair_state,conn_state,scan_state,adv_state]\nParameter Type Value sys_state Number 0: Not ready;\n1: Ready pair_state Number 0: Not paired;\n1: Paired conn_state Number 0: Unconnected\n1: Connecting 2: Connected scan_state Number 0: Scanning Stopped;\n1: Scanning Started adv_state Number 0: Advertising Stopped;\n1: Advertising Started Example:\n→AT+STATE=?\n←+STATE=[1,0,0,0,0]\nGet Version # This command gets the version of the module including chip version, sdk version and firmware version\nCommand: AT+VER=?\nResponse: +VER=[chip_ver,sdk_ver,fw_ver]\nParameter Type Value chip_ver String Chip version sdk_ver String SDK version fw_ver String Firmware version Example:\n→AT+VER=?\n←+VER=[\u0026ldquo;602F0100\u0026rdquo;,\u0026ldquo;3.0.0\u0026rdquo;,\u0026ldquo;xxxx\u0026rdquo;]\nUART Configuration # This command sets UART parameters. Once UART parameter is changed, module will automatically reset and all parameters configured before will be lost.\nCommand: AT+CFGUART=[baud_rate,\u0026lt;data_bit\u0026gt;,,\u0026lt;stop_bit\u0026gt;]\nResponse: +CFGUART=err_code\nParameter Type Value baud_rate Number Standard UART baud rate value data_bit Number 5 - 8 bits polarity Number 0：No polarity\n1：Odd polarity\n2：Even polarity\nOther: invalid value stop_bit Number 0: 1 stop bits\n1: 2 stop bits Example:\n→AT+CFGUART=[921600,8,0,1]\n←+CFGUART=0000H\nDevice General Configuration # This command gets or sets the general parameters of the module.\nCommand: AT+CFGDEV=[role,dev_addr,addr_type,dev_name,phy]\nResponse: +CFGDEV=err_code\nParameter Type Value role Number 1 Observer 2 Broadcaster 5 Central 10 Peripheral 15 All Role dev_addr String Byte Array format string representing MAC address of device in little-endian mode addr_type Number 0: Public address;\n1: Static random address dev_name String ASCII phy Number 0 Random 1 1M Phy 2 2M Phy 4 Coded Phy Example:\n//Set device as BLE Peripheral, device public MAC address is 11-22-22-22-22-11, device name is \u0026ldquo;Slave\u0026rdquo; and prefered PHY is 1M PHY\n→AT+CFGDEV=[10,\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,1]\n←+CFGDEV=0000H\n//Set device as All role and prefered PHY is Coded Phy\n→AT+CFGDEV=[15,\u0026ldquo;AABB0101BBAA\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,4]\n←+CFGDEV=0000H\nData Transparent Transmission Service Configuration # This command gets or sets parameters of Inplay private data transparent tranmission service as GATT server, including service UUID, maximum data transmission size etc. After the execution of the command, the service with specified parameters will be created. It MUST be sent after +CFGDEV\nIt is only allowed by device with \u0026lsquo;Peripheral role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXSVC=[start_hdl,svc_uuid,max_data_sz]\nResponse: +CFGTRXSVC=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically created\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied max_data_sz Number Maximum data transmission size\n0: Default 20 bytes\n1 - 1024: Maximum data size Example:\n//Set service UUID as 1122b4f8-cdf3-11e9-a32f-2a2ae2dbcce4 and the maximum transmission data as 512 bytes.\n→AT+CFGTRXSVC=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;,512]\n←+CFGTRXSVC=0000H\n//Set service UUID by default. Fixed service start handle to 20\n→AT+CFGTRXSVC=[20,\u0026quot;\u0026quot;,0]\n←+CFGTRXSVC=0000H\nData Transparent Transmission Client Configuration # This command gets or sets parameter of Inplay private data transparent tranmission service as GATT client. If parameters are not set or parameter \u0026lsquo;start_hdl\u0026rsquo; is set to 0, device will initiate a Service Discovery Process (SDP) to find remote service after connection.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXCLT=[start_hdl,svc_uuid]\nResponse: +CFGTRXCLT=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically get by SDP\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied Example:\n//Set to discover service by SDP.\n→AT+CFGTRXCLT=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;]\n←+CFGTRXCLT=0000H\n//Set specific start handle and leave other in default, so that SDP is not necessary.\n→AT+CFGTRXCLT=[20,\u0026quot;\u0026quot;]\n←+CFGTRXCLT=0000H\nRF Configuration # This command gets or sets RF related parameter.\nCommand: AT+CFGRF=[tx_power]\nResponse: +CFGRF=err_code\nParameter Type Value tx_power Number TX power: 0Max TX power (~8dBm) 1-157dBm to 0dBm with step 0.5dBm 16-22-1dBm to -7dBm with step -1dBm Example:\n//Set TX power +3dBm\n→AT+CFGRF=[9]\n←+CFGRF=0000H\nSMP Configuration # This command gets or sets security parameters of the module.\nCommand: AT+CFGSMP=[smp,dev_io_cap,pairing_code]\nResponse: +CFGSMP=err_code\nParameter Type Value smp Number (1 byte) - - - - LE Secure Connection MITM - Encryption - - - - Bit3 Bit2 - Bit0 0: false; 1: true dev_io_cap Number 0 Display Only 1 Display Yes No 2 Keyboard Only 3 Keyboard Display 4 No Input No Output pairing_code String ASCII Paring code Example:\n//Set SMP to MITM security and encryption, with ability of keyboard input. The corresponding MITM pairing code is 012345\n→AT+CFGSMP=[5,2,\u0026ldquo;012345\u0026rdquo;]\n←+CFGSMP=0000H\nTarget Device Configuration # This command gets or sets the target devices that are allowed to connect or scan. If initiating activity is configured as direct connection type, only first device in the device list is the target. Maximum 25 target devices can be set.\nIt is only allowed by device with ‘Central role’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGTARGET=[dev1_addr,dev1_addr_type,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_addr_type\u0026gt;,\u0026hellip;]\nResponse: +CFGTARGET=err_code\nParameter Type Value dev_addr String Byte Array format string representing MAC address of target device in little-endian mode dev_addr_type Number 0: Public address;\n1: Static random address Example:\n→AT+CFGTARGET=[\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;AABBCCCCDDEE\u0026rdquo;,0]\n←+CFGTARGET=0000H\nAdvertising Activity Configuration # This command sets parameter to create BLE advertising activity. Maximum 2 advertising activities can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Peripheral’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGADVACTV=[actv_id,adv_type,connectable,intv,chn,payload]\nResponse: +CFGADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity adv_type Number 0: Legacy Advertise 1: Extended Advertise connectable Number 0: Unconnectable 1: Connectable intv Number 20-10240ms chn Number 0: all BLE advertising channel\n37-39: Fixed channel payload String BLE standard advertising data format in base64 encoding\nLength (1 byte) + Type (1 byte) + Content (length -1 byte) Example:\n//Set legacy connectable advertising in 500ms interval. The payload is local name \u0026ldquo;Inplay\u0026rdquo;\n→AT+CFGADVACTV=[1,0,1,500,0,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n//Successfully set\n←+CFGADVACTV=0000H\nScan Activity Configuration # This command sets parameter to create BLE scan activity. Only one scan activity can be created.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGSCANACTV=[actv_id,type]\nResponse: +CFGSCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity type Number 2: Observer\n3: Selective observer. Only devices configured by +CFGTARGET will be reported Example:\n//Set scan activity\n→AT+CFGSCANACTV=[20,3]\n//Successfully set\n←+CFGSCANACTV=0000H\nInitiating Activity Configuration # This command sets parameter to create BLE initiating activity to establish connections with the target device. Only one initiating activity can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Central\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGINITACTV=[actv_id,type]\nResponse: +CFGINITACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity type Number 0: Direct connect\n1: Auto connect. Only devices configured by +CFGTARGET can be connected Example:\n//Create initiating activity to auto connect with target devices.\n→AT+CFGINITACTV=[10,1]\n//Successfully set\n←+CFGINITACTV=0000H\n//Create initiating activity to direct connect with remote device.\n→AT+CFGINITACTV=[10,0]\n//Successfully set\n←+CFGINITACTV=0000H\nStart Advertising Activity # This command start advertising activity that is created by previous +CFGADVACTV command.\nCommand: AT+ADVACTV=[actv_id,op,\u0026lt;duration\u0026gt;]\nResponse: +ADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activities op Number 0: Stop Activity\n1: Start Activity duration Number 0: Forever\n10-65535: Actual duration (in unit of 10ms)\nDefault 0 Example:\n//Start advertising activty permanently\n→AT+ADVACTV=[1,1,0]\n//Successfully set\n←+ADVACTV=0000H\n//Stop advertising activity\n→AT+ADVACTV=[1,0]\n←+ADVACTV=0000H\nStart Scan Activity # This command start scan activity that is created by previous +CFGSCANACTV command. If target devices are not configured by +CFGTARGET command, advertisement from any devices scaned will be reported.\nCommand: AT+SCANACTV=[actv_id,op,\u0026lt;intv\u0026gt;,\u0026lt;wnd\u0026gt;,\u0026lt;chn\u0026gt;,\u0026lt;duration\u0026gt;,\u0026lt;dup_filter\u0026gt;]\nResponse: +SCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity op Number 0: Stop Activity\n1: Start Activity intv Number Scan activity interval 3-40959 ms\nDefault 200ms wnd Number Scan running time, must be less than intv\nDefault 100ms chn Number 0: Scan on three channel alternately\n37-39: Scan on fixed channel\nDefault 0 duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 dup_filter Number 0: No filtering\n1: Filter duplicates within the duration\nDefault 0 Example:\n//Start scan activty permanently\n→AT+SCANACTV=[20,1,200,100,0,0,1]\n//Successfully set\n←+SCANACTV=0000H\n//Stop scan activity\n→AT+SCANACTV=[20,0]\n←+SCANACTV=0000H\nStart Initiating Activity # This command start initiating activity that is created by previous +CFGINITACTV command. If target devices are not configured by +CFGTARGET command, activity cann\u0026rsquo;t be started and retures error response. When it is started permanently, it will end until all target devices configured are connected.\nCommand: AT+INITACTV=[actv_id,op,\u0026lt;conn_intv\u0026gt;,\u0026lt;latency\u0026gt;,\u0026lt;sup_tmo\u0026gt;,\u0026lt;duration\u0026gt;]\nResponse: +INITACTV=err_code\nParameter Type Value actv_id Number Unique ID for initiating activity op Number 0: Stop Activity\n1: Start Activity conn_intv Number Connection interval: 8 - 4800 ms\nDefault 100 ms latency Number 0 - 499\nDefault 0 sup_tmo Number 100 - 32000 ms\nDefault 20000 ms duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 Example:\n//Start initiating activty\n→AT+INITACTV=[10,1,200,0,20000,0]\n//Successfully set\n←+INITACTV=0000H\n//Stop initiating activity\n→AT+INITACTV=[10,0]\n←+INITACTV=0000H\nGet current connection list # This command gets a list of currently connected devices.\nCommand: AT+CONNLST=?\nResponse: +CONNLST=[\u0026lt;dev1_addr\u0026gt;,\u0026lt;dev1_role\u0026gt;,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_role\u0026gt;,\u0026hellip;]\nParameter Type Value dev_addr String The Byte Array format string representing MAC address of peer device in little-endian mode dev_role Number 0: Peer device as Master role;\n1: Peer device as Slave role Example:\n→AT+CONNLST=?\n//Connect to master device \u0026ldquo;66-55-44-33-22-11\u0026rdquo; and a peripheral device \u0026ldquo;FF-EE-DD-CC-BB-AA\u0026rdquo;\n←+CONNLST=[\u0026ldquo;112233445566\u0026rdquo;,0,\u0026ldquo;AABBCCDDEEFF\u0026rdquo;,1]\nStart Pairing # This command start operation of BLE pairing with connected device.\nCommand: AT+BOND=[op,dest_addr,\u0026lt;pairing_code\u0026gt;]\nResponse: +BOND=err_code\nParameter Type Value op Number 0: Cancel pairing\n1: Start pairing dest_addr String The Byte Array format string representing MAC address of connected device in little-endian mode pairing_code String 6 bytes ASCII pairing code Example:\n→AT+BOND=[1,\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;012345\u0026rdquo;]\n←+BOND=0000H\n//Stop pairing\n→AT+BOND=[0,\u0026ldquo;112233445566\u0026rdquo;]\n←+BOND=0000H\nData Transmit # This command transmit data via Inplay private transparent transmission service.\nCommand: AT+DATATX=[dest_addr,data]\nResponse: +DATATX=err_code\nParameter Type Value dest_addr String The Byte Array format string representing MAC address of destination connected device in little-endian mode data String Base64 encoding string representing binary data to transmit Example:\n//Send data \u0026ldquo;0x0001020304050607080910\u0026rdquo; to remove device \u0026ldquo;66-55-44-33-22-11\u0026rdquo;\n→AT+DATATX=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n←+DATATX=0000H\nReset # This command causes the system to reset. While execution, application can choose whether to save or clear current configured parameters permanently. This command don\u0026rsquo;t have any response. The application determines whether reset is complete or not by receiving the +EVTREADY event.\nCommand: AT+SYSRST=[op]\nResponse: N/A\nParameter Type Value op Number 0: Reset module\n1: Reset after saving current parameters to Flash\n2: Reset after clearing current parameter from Flash Example:\n→AT+SYSRST=[1]\nWatchdog # This command set up watch dog.\nCommand: AT+SYSWDT=[wdt_enable,wdt_int_pol,wdt_tmo]\nResponse: +SYSWDT=err_code\nParameter Type Value wdt_enable Number 0: Disable\n1: Enable wdt_int_pol Number 0: Low level trigger interrupt\n1: High level trigger interrupt wdt_tmo Number 1 - 65536 seconds Example:\n→AT+SYSWDT=[1,0,60]\n←+SYSWDT=0000H\nEVENT REFERENCE # -EVTREADY # This event indicates module is ready to accept AT commands. It is usually received after power on reset or +SYSRST command is executed.\nEvent: -EVTREADY=[prev_state]\nParameter Type Value prev_state Number 0 Power on reset or reset command with op 0 1 Reset command with op 1 2 Reset command with op 2 3 Watch dog reset Example:\n-EVTREADY=[1]\n-EVTCONN # This event indicates device has been connected or disconnected.\nEvent: -EVTCONN=[state,peer_addr,role,phy]\nParameter Type Value state Number 0: Disconnect\n1: Connect peer_addr String Byte Array format string representing MAC address of peer device in little role Number 5: Device is connected as Master role;\n10: Device is connected as Slave role phy Number Phy that connection on. Please refer to PHY parameter in command +DEVCFG Example:\n//Successfully connected with remote Master device \u0026ldquo;EF:DD:CC:CC:BB:EF\u0026rdquo; on 1M PHY.\n-EVTCONN=[1,\u0026lsquo;EFBBCCCCDDEF\u0026rsquo;,1,1]\n-EVTDATA # This event indicates the data reception from peer device.\nEvent: -EVTDATA=[peer_addr,data]\nParameter Type Value peer_addr String Byte Array format string representing MAC address of peer device in little-endian mode data String Base64 encoding format string representing binary data received Example:\n//Data \u0026ldquo;0x0001020304050607080910\u0026rdquo; received from remove device \u0026ldquo;66-55-44-33-22-11”\n-EVTDATA=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n-EVTADV # This event indicates that an advertising signal has been scanned.\nEvent: -EVTADV=[dev_addr,addr_type,connectable,rssi,payload]\nParameter Type Value dev_addr String Byte Array format string representing MAC address of advertising device in little-endian mode addr_type Number 0: Public\n1: Static random connectable Number 0: Unconnectable\n1: Connectable rssi Number Signed integer in dBm payload String Base64 encoding format string representing advertising payload binary data Example:\n//A connectable ad with local name \u0026lsquo;Inplay\u0026rsquo; as payload from device \u0026lsquo;66-55-44-33-22-11\u0026rsquo; is scanned. RSSI is -80dBm.\n-EVTADV=[\u0026ldquo;112233445566\u0026rdquo;,0,1,-80,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n-EVTACTVEND # This event indicates the termination of the command +SCANACTV, +ADVACTV, +INITACTV and +BOND, whether the commands are terminated automatically or manually.\nEvent: -EVTACTVEND=[actv_type,actv_id]\nParameter Type Value actv_type Number 0 Advertising activity 1 Scan activity 2 Initiating activity 3 Bond actv_id Number Unique ID for activity Example:\n//Advertising activity 1 has ended\n-EVTACTVEND=[0,1]\n//Scan activity has ended\n-EVTACTVEND=[1,20]\nERROR CODE # The ERROR CODE is returned as a hexadecimal value. Please refer to following table for details.\n0000H Command executed successfully 1001H Wrong command execution 100AH Wrong CommandID 100BH Wrong format 100DH Wrong parameter 100EH Execution overtime Others BLE error. Refer to in_ble_error.h in SDK "},{"id":19,"href":"/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html","title":"Counter Guide","section":"Driver Integration","content":" Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.\nThe 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.\nFor details, please refer to:\nHal_cnt_pwm.c Hal_cnt_timer.c Hal_ir.c Hal_sync7816.c Counter Mode # The counter supports four modes:\nCapture Mode: In Capture Mode, the counter captures waveforms on din A and din B. It detects falling edge and rising edge, records the timestamp into corresponding registers.\nCapture Register 0: Stores the counter value at the first event trigger(falling edge or rising edge).\nCapture Register 1: Stores the counter value at the second event trigger(falling edge or rising edge).\nCapture Register 2: Stores the counter value at the third event trigger(falling edge or rising edge). Subsequent event triggers will overwrite Capture Registers 0, 1, and 2.\nWaveform Mode: In Waveform Mode, the counter outputs signals on \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; based on the values stored in the target registers.\nTarget Register 0: Outputs 0 when the counter reaches the specified value. Target Register 1: Outputs 1 when the counter reaches the specified value. Target Register 2: Stops output when the counter reaches the specified value. Shift In Mode: In Shift In Mode, the counter reads signals from \u0026ldquo;Din A\u0026rdquo; and \u0026ldquo;Din B\u0026rdquo; on every clock cycle, capturing one bit at a time.\nShift Out Mode: In Shift Out Mode, the counter outputs signals to \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; on every clock cycle, transmitting one bit at a time.\nMode Switching: When automatic mode switching is enabled, Capture Mode and Waveform Mode can automatically switch. Similarly, Shift In Mode and Shift Out Mode can also automatically switch.\nConfiguration # Each counter has two input signals: \u0026ldquo;din A\u0026rdquo; and \u0026ldquo;din B\u0026rdquo;, as well as two output signals: \u0026ldquo;dout A\u0026rdquo; and \u0026ldquo;dout B\u0026rdquo;. These internal signal can be configured to connect to external pins. Specifically, these pins are represented as PIN0 to PINI7 (GPIO21 to GPIO28) on the diagram. Select \u0026ldquo;Counter\u0026rdquo; in config tool and select the corresponding pin according to the actual circuit.\nRefer to:\nint hal_cnt_internal_din_pinmux(int inner_pin, int ext_pin) int hal_cnt_internal_dout_pinmux(int inner_pin, int ext_pin) EXT_DIN is from PIN0~PIN7.\nINNTER_DIN is internal din signal from four counters.\nInterrupt # Interrupt status. Each bit is represented as follows:\nCNT_A_UPDATE 1\tcapture register a0 a1 a2 all updated CNT_B_UPDATE 0x2\tcapture register b0 b1 b2 all updated CNT_OVERFLOW 0x4\tcounter overflow the counting will restart CNT_SHIFTIN_COMPLETE 0x8 shift in completed CNT_SHIFTOUT_COMPLETE 0x10\tshift out completed CNT_WAVEFORM_STOP 0x20\twaveform stop, the counter has reached the value of register a2/b2 CNT_SHIFTIN_CAPTURE_END 0x40\tin the automatic switching mode, capture or shift in is completed CNT_SHIFTOUT_WAVEFORM_END 0x80 in the automatic switching mode, waveform or shift out is completed API # Set the callback of the interrupt. # The callback fun will be called during the interrupt.\nvoid hal_cnt_set_handler(cnt_dev_t *dev, CNT_ISR_FUN fun, void *arg) Mask/unmask interrupt # int hal_cnt_intr_unmask(cnt_dev_t* dev) int hal_cnt_intr_mask(cnt_dev_t* dev) Enable/Disable # void cnt_enable(uint32_t base) void cnt_disable(uint32_t base) Trigger and signal source # The counter can be set to be triggered by signal or manually.\nSet the signal source and edge\nvoid cnt_set_src_edge(uint32_t base, uint32_t src_edge)\nSignal source:\n#define CNT_EXT_DIN_A 1 #define CNT_EXT_DIN_B 2 #define CNT_GLOBAL_START_TRIGGER 3 #define CNT_SINGLE_START_TRIGGER 4 #define CNT_GLOBAL_STOP_TRIGGER 5 #define CNT_SINGLE_STOP_TRIGGER 6 #define CNT_INNER_DIN0 11 #define CNT_INNER_DIN1 12 #define CNT_INNER_DIN2 13 #define CNT_INNER_DIN3 14 Global trigger will trigger all four counters, single trigger will only trigger one counter.\nEdge\n#define CNT_RISING_EDGE 0 #define CNT_FALLING_EDGE 0x10UL #define CNT_BOTH_EDGE 0x20UL Signal\nStart signal\n#define CNT_START_SIGNLE_SHIFT 0 Stop signal\n#define CNT_STOP_SIGNLE_SHIFT 8 Din 0 signal\n#define CNT_DIN0_SHIFT 16 Din 1 signal\n#define CNT_DIN1_SHIFT 24 Example # Set the external DIN A as the start signal. Double edge trigger. The DIN0 signal is the external DIN A. Double edge trigger.\ncnt_set_src_edge(cnt_dev-\u0026gt;base, (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_START_SIGNLE_SHIFT | (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_DIN0_SHIFT); Manual trigger # void cnt_trigger_start (uint32_t base) void cnt_trigger_stop (uint32_t base) Set the internal signal # void cnt_set_input_mux(uint32_t base, uint32_t val) Parameter Val, bus A by default\n#define CNT0_BUS_B 0x1 #define CNT1_BUS_B 0x2 #define CNT2_BUS_B 0x4 #define CNT3_BUS_B 0x8 Target control # void cnt_set_target_ctrl (uint32_t base, uint32_t ctrl) The behavior when the counter reaches register A2.\nKeep or reset value. Reset value by default.\n#define CNT_A2_KEEP_VALUE 0x1UL #define CNT_A2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_A2_STOP_COUNTER 0x2UL #define CNT_A2_RESTART_COUNTER 0x0UL The behavior when the counter reaches register B2\nKeep or reset value. Reset value by default.\n#define CNT_B2_KEEP_VALUE 0x4UL #define CNT_B2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_B2_STOP_COUNTER 0x8UL #define CNT_B2_RESTART_COUNTER 0x0UL Set the value when resetting\n#define CNT_DOUT_A_RESET_VALUE_SHIFT 4 #define CNT_DOUT_B_RESET_VALUE_SHIFT 5 Example: # B2 is to hold and stop counter, while A2 resets value and stops counter. The reset values are both set to 0.\ncnt_set_target_ctrl(dev-\u0026gt;base, CNT_B2_KEEP_VALUE|CNT_B2_STOP_COUNTER |CNT_A2_RESET_VALUE|CNT_A2_STOP_COUNTER|(0\u0026lt;\u0026lt;CNT_DOUT_A_RESET_VALUE_SHIFT)|(0\u0026lt;\u0026lt;CNT_DOUT_B_RESET_VALUE_SHIFT)); Set output bypass # void cnt_set_out_bypass(uint32_t base, uint32_t val) Bypass A or B. A and B will perform the bit operation by default\n#define CNT_OUT_BYPASS_A 0x10000UL #define CNT_OUT_BYPASS_B 0x20000UL Set the logical operation of A, and the result of dout A is the result of the related bit operation of A and B.\n#define CNT_OPT_A_AND\t0x0 #define CNT_OPT_A_OR\t0x1 #define CNT_OPT_A_XOR\t0x2 Set the logical operation of B, and the result of dout B is the result of the related bit operation of A and B\n#define CNT_OPT_B_AND\t0x0 #define CNT_OPT_B_OR\t0x10 #define CNT_OPT_B_XOR\t0x20 "},{"id":20,"href":"/docs/in6xxe/user-guides/driver-integration/crc-guide.html","title":"CRC Guide","section":"Driver Integration","content":" CRC Guide # Overview # CRC (Cyclic Redundancy Check) is a widely used error-detecting code in digital communication networks and storage devices. It is a mathematical algorithm that calculates a checksum based on the data being transmitted or stored, which can then be used to detect errors during transmission or storage.\nFeatures # Support calculate fix length data or variable length data Support DMA(need occupy one I2C DMA channel) Support configuare parameters such as polynomial selection, initial value, XOR output and so on. API # CRC API\n"},{"id":21,"href":"/docs/in6xx/getting-started/testing/debug-guide.html","title":"Debug Guide","section":"Testing and Debuging","content":" Debug Guide # Introduction # Arm Keil MDK (Microcontroller Development Kit) provides robust debugging capabilities that are essential for efficient software development targeting Arm Cortex-M based microcontrollers. This document provides instructions on using the debugging features in Keil.\nDebug Step: # Enter debugging and run to main funtion # Enter debug mode, run program from flash to main function.\nOpen project, double click \u0026ldquo;proj_ble_lp.uvmpw\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click project option button, select \u0026ldquo;J-Link\u0026rdquo; in \u0026ldquo;Debug\u0026rdquo; page. Check the \u0026ldquo;Load Application at Startup\u0026rdquo; and \u0026ldquo;Run to main()\u0026rdquo; option. Click \u0026ldquo;\u0026hellip;\u0026rdquo; button, select script \u0026ldquo;jlink_flash_setup.ini\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click \u0026ldquo;Setting\u0026rdquo; button, select “SW” (single-wire interface) from the drop-down menu of “Port.” Then click “OK” to apply changes. Note:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the “SW Device” column, as illustrated below. If Keil can’t find device, reset DK and click “Scan” to rescan device.\nIf a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nClick \u0026ldquo;start debug\u0026rdquo; button to start debug session. Entering debugging while the program is running # When the program is running, enter debug mode, then halt the CPU at the current instruction.\nClick \u0026ldquo;Setting\u0026rdquo; button, uncheck \u0026ldquo;Reset afger Connect\u0026rdquo;, \u0026ldquo;Verify code Download\u0026rdquo; and \u0026ldquo;Download to Flash\u0026rdquo; option. Click \u0026ldquo;OK\u0026rdquo; button. Uncheck the \u0026ldquo;Load Application at Startup\u0026rdquo; option. Click \u0026ldquo;Edit\u0026rdquo; button, commit out this line \u0026ldquo;Setup_giga();\u0026rdquo; Click \u0026ldquo;OK\u0026rdquo; button. Click \u0026ldquo;start debug\u0026rdquo; button to start debug session. "},{"id":22,"href":"/docs/in6xxe/getting-started/testing/debug-guide.html","title":"Debug Guide","section":"Testing and Debuging","content":" Debug Guide # Introduction # This document provides a guide on how to use keil to debug project to the IN6XXE chip.\nDebug Step: # Enter Debugging # Copy jlink_flash_setup.ini file in in-dev\\proj\\common\\JLINK to project directory\nEdit .ini file with following steps (1) change the setting in jlink_flash_setup.ini according to the in_config.h. (2)change the setup mode according to in_config.h Follow these steps to select the .ini file. Click the debug button. Enter debugging mode, where you can perform simulation debugging. Entering Debugging While the Program Is Running # To enter debugging mode during program execution, please follow these steps:\nRemove the options at 1 and 2, and click Confirm. Remove the options at 1 and 2, and click OK. Edit .ini file. Comment out the Setup section. Click the debug button. Enter debugging mode, where you can see the program\u0026rsquo;s execution position and perform simulation debugging. Note: # Setting breakpoints: Breakpoints are crucial tools in the debugging process, as they allow you to pause execution at specific locations in the program. In Keil, you can set breakpoints by clicking on the line number of the code. When the program reaches the breakpoint, it will automatically pause, enabling you to observe the current variable values and program state.\nStep-by-step execution: Step-by-step execution is a common operation in debugging, allowing the program to execute one line of code at a time. In Keil, you can perform step-by-step execution by clicking the \u0026ldquo;Step\u0026rdquo; button on the toolbar. This helps you observe the execution of the program line by line, identifying potential issues.\nObserving variable values: Observing variable values is crucial during debugging. Keil provides an \u0026ldquo;Watch Window\u0026rdquo; to display variable values in real-time. You can add the variables you want to observe to the Watch Window to view their value changes anytime during debugging.\nRight-click on the variable you need to observe, and click \u0026ldquo;Add to Watch1\u0026rdquo; as shown in the figure. This will allow you to view or modify the value of the variable you are observing in the designated box. Setting a while(debug) {} loop at the beginning of the main function:When the debug variable is set to a non-zero value (in this case, 1), the while(debug) {} loop creates an infinite loop, suspending further program execution. This allows developers to inspect the initial state of the program, including memory contents, register values, peripheral states, and more.\n"},{"id":23,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/ecc-sample.html","title":"ECC Sample","section":"Driver Examples","content":" ECC Sample # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_ECC in-dev/proj/drv/proj_drv_ECC Debug # We can get the status of development board according to Uart Log. The following are samples,\nverify success: Verify OK More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_drv_ECC\nPress the reset button on the board and the peripheral board, observe the text CHIP ID = appear in the log.\nVerify the data using ECC. If verify success, text Verify OK will appear in the log.\n"},{"id":24,"href":"/docs/in6xxe/user-guides/driver-integration/gpio-guide.html","title":"GPIO Guide","section":"Driver Integration","content":" GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:\nDigital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to \u0026ldquo;proj_drv_gpio\u0026rdquo;.\nConfigure GPIO to output and output high/low:\nint level = 0; hal_gpio_cfg_output(port, poin); hal_gpio_output(port, poin, level); Configure GPIO to input and get input value:\nint level; hal_gpio_cfg_input(port, poin, GPIO_PULL_UP); level = hal_gpio_input_status(port, poin); Interrupt # Each pin in one group share the same interrupt. Supports falling edge, rising edge and both edge.\nRefer to \u0026ldquo;proj_drv_gpio_interrupt\u0026rdquo;.\nConfigure interrupt for falling edge and rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_NO_PULL); hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 1, 1, 0); Wake up # All pins can be configured to wake up the chip by high level, low level, falling edge, rising edge, and both edges.\nRefer to \u0026ldquo;proj_drv_gpio_wup\u0026rdquo;.\nConfigure to wake up by rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_PULL_DOWN); hal_gpio_cfg_wup_edge(port, pin, 1, 0); To output in sleep mode, set latch to 1:\n//output high in deep sleep and wake up hal_gpio_cfg_output(port, pin); hal_gpio_output(port, pin, 1); hal_gpio_sleep_pad_latch(port, pin, 1, 0); Wake up and get interrupt # After waking up, it can generate interrupt.\nRefer to \u0026ldquo;proj_drv_gpio_wup_interrupt\u0026rdquo;\n/// interrupt /// falling edge , wake up en hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 0, 1, 1); /// wake up by edge ///\tfalling edge hal_gpio_cfg_wup_edge(port, pin, 0, 1); Reset chip/CPU # GPIO pin can be configured to reset the chip/CPU by falling edge or rising edge.\nRefer to \u0026ldquo;proj_drv_gpio_reset\u0026rdquo;.\nReset chip by falling edge\nhal_gpio_cfg_input(port, pin, GPIO_PULL_UP); hal_gpio_reset_chip(port, pin, port, pin, 1, 16); "},{"id":25,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-interrupt-sample.html","title":"GPIO Interrupt Sample","section":"Driver Examples","content":" GPIO Interrupt Sample # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.\n#define GPIO_INTERRUPT_EDGE RISE_EDGE Define the edge-trigger signal for GPIO interrupts, including RISE_EDGE and FALL_EDGE. RISE_EDGE represents an interrupt when the GPIO input has a rising edge, while FALL_EDGE represents an interrupt when the GPIO input has a falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur rise:... fall:... wup:... mains the gpio interrupt source. More information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO interrupt pin. Download the proj_drv_gpio_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, rise:... fall:... wup:... will be printed. In this example, due to the presence of the mask function in the callback, the interrupt will only be triggered once. "},{"id":26,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-reset-sample.html","title":"GPIO Reset Sample","section":"Driver Examples","content":" GPIO Reset Sample # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_reset in-dev/proj/driver/proj_drv_gpio_reset Configuration # #define GPIO_RESET_TEST_PORT 1 #define GPIO_RESET_TEST_PIN 2 Define the GPIO reset port and pin.\n#define RESET_EDGE RISING_EDGE Define the triggering of a GPIO reset signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. 1 means rising edge, 0 means falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nWaiting for reset signals: Input pin is GPIO1_2 Wait for falling edge to trigger PD1 reset reset success:CHIP ID = ...\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO reset pin and edge, then download proj_drv_GPIO_RESET. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that we reset development board suceess. "},{"id":27,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-sample.html","title":"GPIO Sample","section":"Driver Examples","content":" GPIO Sample # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.\nIn this example, we can achieve basic input and output functionality using GPIO.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.\n#define KEY_PORT 2 #define KEY_PIN 3 Define the GPIO input port and pin.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nLED cycle flashing when the GPIO_2_3 put up, the message KEY up will be printed. More information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO output pin and input pin, then download proj_drv_GPIO. Press the reset button and observe the log for the message CHIP ID =. Repeat the LED on/off cycle. If the GPIO input pin is high, the message KEY up will be printed. "},{"id":28,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-interrupt-sample.html","title":"GPIO Wake Interrupt Sample","section":"Driver Examples","content":" GPIO Wake Interrupt Sample # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk_interrupt in-dev/proj/driver/proj_drv_gpio_wuk_interrupt Configuration # #define PORT 2 #define PIN 3 Define the port and pin for testing GPIO wake-up and interrupts.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur interrupt occur\nWake up power up src=\nPower down power down\nMore information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO wake-up and interrupt pin. Download the proj_drv_gpio_wuk_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, power up src=andinterrupt occur will be printed. "},{"id":29,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-sample.html","title":"GPIO Wake Sample","section":"Driver Examples","content":" GPIO Wake Sample # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.\n#define WUP_TRIGGER FALLING_EDGE // wake up source Define the triggering of a GPIO wake signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. The following enum is the mode can be chosen\nenum{ HIGH, LOW, RISING_EDGE, FALLING_EDGE, BOTH_EDGE, }; Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nPower down: power down Wake up:power up src=23. number 23 means wake-up source, we can find its meaning in pm_ws.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO wake-up pin and edge, then download proj_drv_gpio_wuk. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that development board wake up successfully. "},{"id":30,"href":"/docs/in6xx/getting-started/testing/hci_command.html","title":"HCI Command","section":"Testing and Debuging","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Command Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # Table 1\npacket type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 2\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding HCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,0x04, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 0x06, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 2\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x04, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: Don\u0026rsquo;t change TX power setting. 0x1 ~ 0x7F: PA gain. Note:\nSuggest set TX gain to 0x0, and use \u0026quot;Set TX Power\u0026quot; command to set TX power. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x05, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x08, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;, \u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\npacket number: TX packet number, 0 is TX forever. Note: If packet number is not 0, current is a little higher.\nComplete Event:0x04, 0x0E, 0x04, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nVendor TX end # Stop TX and send back TX packets, Command: 0x01, 0x53, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x53, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\npacket number: TX packet number Set Cap # Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3.\nCommands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 01, 0x04, 0x07, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number Set TRX Enable Pin # Command: 0x01, 0x44, 0xFC, 0x06, \u0026lt;bias port\u0026gt; \u0026lt;bias pin\u0026gt;, \u0026lt;tx en port\u0026gt;, \u0026lt;tx en pin\u0026gt;,\u0026lt;rx en port\u0026gt;, \u0026lt;rx en pin\u0026gt;\nbias port: PA bias port, set to 0xFF if it is invaild bias pin: PA bias pin, set to 0xFF if it is invaild tx en port: TX enable port tx en pin: TX enable pin rx en port: RX enable port rx en pin: RX enable pin Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x44, 0xFC, \u0026lt;status\u0026gt; GPIO Output # Command: 0x01, 0x0B, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;output\u0026gt;\nport: GPIO port pin: GPIO pin output: GPIO output, 1 is high and 0 is low Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0B, 0xFC, \u0026lt;status\u0026gt; GPIO input # Command: 0x01, 0x0C, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;pull\u0026gt;\nport: GPIO port pin: GPIO pin pull: 0 is no pull up/down, 1 is pull up and 2 is pull down Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0C, 0xFC, \u0026lt;status\u0026gt; \u0026lt;GPIO input\u0026gt;\nGPIO input: 1 is high and 0 is low Get ADC sample # Command: 0x01, 0x43, 0xFC, 0x02, \u0026lt;ADC channel\u0026gt;, \u0026lt;parameter\u0026gt;\nADC channel: ADC channel\nparameter: If ADC channel is not 13, set this to 0x0. If ADC channel is 13, this value is register pmu_test_mux_ctrl[0:7]. Complete Event: 0x04, 0x0E, 0x08, 0x01, 0x43, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;Sample raw data byte 0\u0026gt;, \u0026lt;Sample raw data byte 1\u0026gt; \u0026lt;Sample converted data byte 0\u0026gt;, \u0026lt;Sample converted data byte 1\u0026gt;\nSample raw data: 16 bits ADC sample raw data.\nSample converted data: 16 bits converted data in millivolt.\nStart PWM # Command: 0x01, 0x09, 0xFC, 0x01, \u0026lt;pwm id\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Command: 0x01, 0x0A, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;\nSet RTC32K Output # Command: 0x01, 0x46, 0xFC, 0x03, \u0026lt;enable\u0026gt;, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt; Output RTC32K signal on specail GPIO. Available pins are GPIO_0_2, GPIO_0_6, GPIO_1_0, GPIO_1_4, GPIO_1_8, GPIO_3_3 and GPIO_4_3.\nenable: 1 is enable, and 0 is disable\nport: GPIO port\npin: GPIO pin\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x46, 0xFC, \u0026lt;status\u0026gt;\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt; The following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x05, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x06, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq offset code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x42, 0xFC, \u0026lt;status\u0026gt;\n"},{"id":31,"href":"/docs/in6xxe/getting-started/testing/hci_command.html","title":"HCI Command","section":"Testing and Debuging","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Command Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # Table 1\npacket type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 2\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding Table 3\ntx power: Value TX Power 0x00 Max Power 0x01 7dBm 0x02 6.5dBm 0x03 6dBm 0x04 5.5dBm 0x05 5dBm 0x06 4.5dBm 0x07 4dBm 0x08 3.5dBm 0x09 3dBm 0x0A 2.5dBm 0x0B 2dBm 0x0C 1.5dBm 0x0D 1dBm 0x0E 0.5dBm 0x0F 0dBm 0x10 -1dBm 0x11 -2dBm 0x12 -3dBm 0x13 -4dBm 0x14 -5dBm 0x15 -6dBm 0x16 -8dBm 0x17 -10dBm 0x18 -12dBm 0x19 -16dBm 0x1A -20dBm 0x1B -43dBm HCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,0x04, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 0x06, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 2\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x04, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: Don\u0026rsquo;t change TX power setting. 0x1 ~ 0x7F: PA gain. Note:\nSuggest set TX gain to 0x0, and use \u0026quot;Set TX Power\u0026quot; command to set TX power. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x05, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x08, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;, \u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\npacket number: TX packet number, 0 is TX forever. Note: If packet number is not 0, current is a little higher.\nComplete Event:0x04, 0x0E, 0x04, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nVendor TX end # Stop TX and send back TX packets, Command: 0x01, 0x53, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x53, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\npacket number: TX packet number Set Cap # Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap to Flash # Command: 0x01, 0x08, 0xFC, 0x01, \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3.\nCommands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 to 0x1A. Please refer to Table 3. Complete Event: 0x04, 0x0E, 01, 0x04, 0x07, 0xFC, \u0026lt;status\u0026gt;\nSet TX Gain # Command: 0x01, 0x51, 0xFC, 0x00, \u0026lt;TX Gain\u0026gt;\nTX Gain: TX gain, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power Table # Command: 0x01, 0x52, 0xFC, 0x00, \u0026lt;TX Power Table\u0026gt;\nTX Power Table: Range is 0x01 ~ 0x04. Default is 0x1. Table 1 is for low power mode. And table 4 is for high power mode. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number Set TRX Enable Pin # Command: 0x01, 0x44, 0xFC, 0x06, \u0026lt;bias port\u0026gt; \u0026lt;bias pin\u0026gt;, \u0026lt;tx en port\u0026gt;, \u0026lt;tx en pin\u0026gt;,\u0026lt;rx en port\u0026gt;, \u0026lt;rx en pin\u0026gt;\nbias port: PA bias port, set to 0xFF if it is invaild bias pin: PA bias pin, set to 0xFF if it is invaild tx en port: TX enable port tx en pin: TX enable pin rx en port: RX enable port rx en pin: RX enable pin Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x44, 0xFC, \u0026lt;status\u0026gt; GPIO Output # Command: 0x01, 0x0B, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;output\u0026gt;\nport: GPIO port pin: GPIO pin output: GPIO output, 1 is high and 0 is low Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0B, 0xFC, \u0026lt;status\u0026gt; GPIO input # Command: 0x01, 0x0C, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;pull\u0026gt;\nport: GPIO port pin: GPIO pin pull: 0 is no pull up/down, 1 is pull up and 2 is pull down Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0C, 0xFC, \u0026lt;status\u0026gt; \u0026lt;GPIO input\u0026gt;\nGPIO input: 1 is high and 0 is low Get ADC sample # Command: 0x01, 0x43, 0xFC, 0x02, \u0026lt;ADC channel\u0026gt;, \u0026lt;parameter\u0026gt;\nADC channel: ADC channel\nparameter: If ADC channel is not 13, set this to 0x0. If ADC channel is 13, this value is register pmu_test_mux_ctrl[0:7]. Complete Event: 0x04, 0x0E, 0x08, 0x01, 0x43, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;Sample raw data byte 0\u0026gt;, \u0026lt;Sample raw data byte 1\u0026gt; \u0026lt;Sample converted data byte 0\u0026gt;, \u0026lt;Sample converted data byte 1\u0026gt;\nSample raw data: 16 bits ADC sample raw data.\nSample converted data: 16 bits converted data in millivolt.\nStart PWM # Command: 0x01, 0x09, 0xFC, 0x01, \u0026lt;pwm id\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Command: 0x01, 0x0A, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;\nSet RTC32K Output # Command: 0x01, 0x46, 0xFC, 0x03, \u0026lt;enable\u0026gt;, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt; Output RTC32K signal on specail GPIO. Available pins are GPIO_0_2, GPIO_0_6, GPIO_1_0, GPIO_1_4, GPIO_1_8, GPIO_3_3 and GPIO_4_3.\nenable: 1 is enable, and 0 is disable\nport: GPIO port\npin: GPIO pin\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x46, 0xFC, \u0026lt;status\u0026gt;\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt; The following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x05, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x06, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq offset code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x42, 0xFC, \u0026lt;status\u0026gt;\n"},{"id":32,"href":"/docs/in6xxe/examples-and-use-case/misc/hci-sample.html","title":"HCI Sample","section":"Misc Examples","content":" HCI Sample # Overview # HCI, as the Host Controller Interface, is a crucial component of the Bluetooth protocol stack. This interface lies within the hardware section of the Bluetooth communication module, providing a standardized communication mechanism between the host and controller elements of a Bluetooth device.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ate_test_hci proj_ate_test_hci_no_os in-dev/proj/misc/proj_ate_test_hci in-dev/proj/misc/proj_ate_test_hci_no_os Configuration # #define EXT_PA 0 ///\u0026lt; 0: diable external PA, 1: enable external PA Define if use PA control. 0: diable external PA, 1: enable external PA\n#define BIAS_PORT 1 ///\u0026lt; external PA bias port #define BIAS_PIN 3 ///\u0026lt; external PA bias pin Define the Bias pin. If don\u0026rsquo;t use Bias pin, set it to 0xff\n#define TX_EN_PORT 1 ///\u0026lt; external PA TX EN port #define TX_EN_PIN 4 ///\u0026lt; external PA TX EN pin Define the Tx_en pin.\n#define RX_EN_PORT 2 ///\u0026lt; external PA RX EN port #define RX_EN_PIN 3 ///\u0026lt; external PA RX EN pin Define the Rx_en pin.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can enter command on GPIO_2_7, and get the status on GPIO_2_1. **Remember to set hex send and receive when testing HCI command.**The following are samples:\ncommand sent: 01030c00\nstatus received: 04 0E 04 01 03 0C 00\nMore information may be found in debug guide page. More information and command can be found in HCI Command.\nTest Steps # Open Keil and set EXT_PA to be 1 if needed, download proj_ate_test_hci_no_os. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. Send HCI command and we can get status on UART1. "},{"id":33,"href":"/docs/in6xxe/user-guides/driver-integration/i2c-guide.html","title":"I2C Communication","section":"Driver Integration","content":" I2C Guide # Overview # I2C (Inter-Integrated Circuit) is a simple serial communication protocol commonly used to connect microcontrollers with various electronic devices such as sensors and memories. It utilizes only two wires: a clock line (SCL) for synchronizing data transfer and a data line (SDA) for sending and receiving data. Key Features # Multi-Master Capability: Multiple masters can be connected to the same bus and communicate with different slave devices. Hardware Address Detection: Each device on the I2C bus has a unique address, allowing for easy identification and communication. Arbitration and Synchronization: The I2C protocol includes mechanisms for arbitration and synchronization, ensuring reliable data transfer even when multiple masters are present on the bus. Software Addressable: The I2C protocol supports software-addressable devices, allowing for flexible configuration and dynamic address assignment. I2C Bus Topology # The I2C bus consists of two main components:\nMaster Device: The master device initiates and controls the communication on the I2C bus. It generates the clock signal and determines which slave device to communicate with. Slave Device: Slave devices are peripheral devices that respond to requests from the master device. They can transmit or receive data based on the master\u0026rsquo;s instructions. The SDA (Serial Data) line is used for bidirectional data transfer, while the SCL (Serial Clock) line is used for synchronizing the data transfer between the master and slave devices.\nInitialization # Refer to \u0026ldquo;proj_drv_I2C_master/proj_drv_I2C_slave\u0026rdquo;.\nConfigure I2C settings according to the i2c_init_t struct.\ni2c_init_t init = {0}; init.prio = IRQ_PRI_Normal; /**\u0026lt; Interrupt priority */ init.speed = I2C_SPEED_100K; /**\u0026lt; I2C speed (more selections can be found in i2c_speed) */ init.arg = NULL; /**\u0026lt; Argument to be used in the callback */ init.callback = I2C_cb; /**\u0026lt; I2C callback after I2C operation is finished */ i2c_dev = hal_i2c_open(I2C0_ID, \u0026amp;init); /**\u0026lt; I2C0_ID can be replaced with I2C1_ID. If changed, update the setting in config.h */ I2C Master # Clock Generation: The master is responsible for generating the SCL (Serial Clock) signal, which synchronizes data transmission. Data Transfer Control: The master controls the start and end of data transmission by sending START and STOP signals. Device Addressing: Before data transmission, the master sends a 7-bit or 10-bit device address along with a read/write bit (R/W=1 for read, R/W=0 for write) to specify the intended operation. Master Read # res = hal_mi2c_read(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C master read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_mi2c_read_dma(hdl, tar, buffer, cmd_buf, buffer_len, poll, tmo); /** * @brief I2C master read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ Master Write # res = hal_mi2c_write(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C master write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_mi2c_write_dma(hdl, tar, buffer, buffer_len, cmd_buf, poll, tmo); /** * @brief I2C master write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ I2C Slave # Data Reception and Transmission: Once addressed by the master, the slave receives or transmits data based on the master\u0026rsquo;s instructions. Slave Read # res = hal_si2c_read(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_si2c_read_dma(hdl, tar, buffer, cmd_buf, buffer_len, poll, tmo); /** * @brief I2C slave read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ Slave Write # res = hal_si2c_write(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_si2c_write_dma(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ "},{"id":34,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/i2c-sample.html","title":"I2C Sample","section":"Driver Examples","content":" I2C Sample # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.\nThis routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication. It enables serial communication of data between different development boards. The UART port prints the LOG, showing the data transmission and retrieval between the I2C Master and I2C Slave.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_I2C in-dev/proj/driver/proj_drv_I2C Configuration # #define TEST_CASE I2C_TEST_MASTER_XFER_BLOCKING_READ You can change the operation mode.\nAvailable modes for Master # I2C_TEST_MASTER_XFER_BLOCKING_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_READ I2C_TEST_MASTER_XFER_POLL_READ I2C_TEST_MASTER_XFER_BLOCKING_WRITE I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE I2C_TEST_MASTER_XFER_POLL_WRITE I2C_TEST_MASTER_XFER_BLOCKING_WRITE_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE_READ I2C_TEST_MASTER_XFER_POLL_WRITE_READ I2C_TEST_MASTER_XFER_ASYNC Slave mode # I2C_TEST_SLAVE_XFER #define I2C_SLAVE_ADDR 0x14 Set the address of the slave device in I2C communication.\n#define I2C_SPEED I2C_SPEED_100K Set the speed of the I2C communication.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both master and slave according to Uart Log and LED.\nWhen we transmit or receive data, we can get information on uart log. More information may be found in debug guide page.\nTest Steps # Master Setup and Download Open Keil, change the selected mode to master, compile, and download the project. Press the reset button and observe the LOG to see the text \u0026ldquo;master_xfer_blocking_read dma_en=0\u0026rdquo;, which represents the selected mode. Slave Setup and Download Open Keil, change the selected mode to slave, compile, and download the project. Press the reset button and observe the LOG to see the text which represents the selected mode., Testing Reset the slave first, then reset the master. We can see the data appearing in the LOG based on the selected mode of the master. After resetting both the slave and the master, we can observe the data appearing in the LOG based on the selected mode of the master. "},{"id":35,"href":"/docs/in6xxe/dk/introduction-to-in6xxe-dk.html","title":"Introduction to IN6XXE DK","section":"Development Kits","content":" Overview # IN6XXE DK is a development board for IN6XXE series chips. You can download the schematics:\nSCH_IN612LE-QFN48-DK-ver1.1\nSCH_IN612LE-QFN56-DK-ver1.1\nHardware description # Component Description 1 RF Connector 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.8V Power 5V to 1.8V 10 ADC port 11 Cortex_debug Debug port 12 Power ON Power switch of the 5V supply from USB 13 Jlink+UART0 JLINK and UART0, UART0 Tx is GPIO_0_2, Rx is GPIO_1_0 14 1.2V Test point 15 LEDs LEDs connected to GPIO,on when GPIO drives HIGH. LED1:GPIO_2_8, LED2:GPIO_3_2, LED3:GPIO_3_3 16 GPIO Test Pin GPIO pins 17 GPIO Test Hole GPIO pins 18 GPIO Button+Reset One reset button, other buttons are LOW active(when pressed, GPIO input LOW) 19 UART Jumper Control power supply of USB to UART chip; Control which GPIOs are connected to the USB to UART chip, default is UART1: GPIO_2_1:TX GPIO_2_7:RX GPIO_1_5:RTS GPIO_1_6:CTS see UART Configuration 20 UART to USB USB to UART chip 21 3.3V Power 5V to 3.3V 22 Type-C Power supply and connect to PC for UART port 23 External VBAT External supply to VBAT 24 External VDDIO External supply to VDDIO These components will be refered as \u0026ldquo;Component_xx\u0026rdquo;(xx is the component number) in this page.\nPower Supply # When the board is connected with USB and the switch is turned on, 5V, 3.3V and 1.8V power source will be valid, and 3 LEDs will indication the status:\nLED4: 5V LED5: 3.3V LED6: 1.8V However, how these power sources will supply IN6XXE chip is configured with Power Jumper(Component_7):\nCHIP_EN can always be connected to VBAT to reset the chip when powered on. VDDIO and VBAT are connected directly to the chip. VDDIO is power supply of IN6XXE\u0026rsquo;s IO, and the voltage level can be different with VBAT. These are confguration examples:\nConnections Description CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;3.3V,VBAT\u0026lt;-\u0026gt;3.3V Both VDDIO and VBAT are 3.3V, supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;1.8V,VBAT\u0026lt;-\u0026gt;3.3V VDDIO is 1.8V, VBAT is 3.3V, both supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;VBAT VBAT and VDDIO are powered by external power source, can be used when measuring power consumption of the chip Debug Port # There are three connectors(component 8, 11, 13) can be used as debug port, usually connected to J-Link.\nUART configuration # IN6XXE has two UART ports, UART0 and UART1. You can connect external USB to UART module to Component_13 if you use UART0.\nYou can also use the on board USB to UART chip, configured with Component_19:\nIf you want to use on board USB to UART chip, 1\u0026lt;-\u0026gt;2 should be connected.\nIf you want to use UART1(GPIO_2_1 as Tx, and GPIO_2_7 as Rx):\n3\u0026lt;-\u0026gt;4, 5\u0026lt;-\u0026gt;6 should be connected for UART Rx and Tx.\n7\u0026lt;-\u0026gt;8, 9\u0026lt;-\u0026gt;10 should be connected for flow control.\nYou can connect 4, 6 to other GPIOs if you use other GPIOs as UART port pins.\nCurrent measurement # If you want to measure current of IN6XXE, all pins of Component_19 should be disconnected.\nFor the Power Jumper, CHIP_EN\u0026lt;-\u0026gt;VBAT and VDDIO\u0026lt;-\u0026gt;VBAT should be connected.\nThen you can connect external power source to VBAT(Component_24) and GND(Component_6) to supply power to IN6XXE and measure the current.\n"},{"id":36,"href":"/docs/in6xx/getting-started/download/jflash-download-guide.html","title":"JFlash Programming","section":"Download Image","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XX chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XX series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay IN6XX_C0_GIGA device Open the Bin file\nClick the file menu, select “Open data file”, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":37,"href":"/docs/in6xxe/getting-started/download/jflash-download-guide.html","title":"JFlash Programming","section":"Download Image","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XXE series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nCopy files:\nCopy IN6XXE to \u0026ldquo;C:\\Users\u0026lt;USER\u0026gt;\\AppData\\Roaming\\SEGGER\\JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nUbuntu # Copy IN6XXE to \u0026ldquo;$HOME/.config/SEGGER/JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nmacOS # Copy IN6XXE to \u0026ldquo;$HOME/Library/Application Support/SEGGER/JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay IN6XXE device Open the Bin file\nClick the file menu, select “Open data file”, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":38,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/keyboard-sample.html","title":"Keyboard Sample","section":"Driver Examples","content":" Keyboard Sample # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_keyboard in-dev/proj/driver/proj_drv_keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of keyboard on uart log.\npress button: press key: row:... col:... release button: release row:... col:... More information may be found in debug guide page.\nTest Steps # Open Keil and download the proj_drv_keyboard project. Press the reset button and observe the log for the text CHIP ID =. Press the button, we will get the status press button . After that, we release the button, we will get the status release button "},{"id":39,"href":"/docs/in6xxe/user-guides/nanosync-technology/trigger-handler-guide.html","title":"NanoSync Engine Guide","section":"NanoSync Technology","content":" NanoSync Engine Guide # Introduction # NanoSync engine(trigger handler block) which can be used to perform many real-time events or tasks without the CPU’s intervention.\nThe NanoSync engine operates based on triggers and handlers. When a trigger (also called an event) happens, a handler will be invoked. A handler consists of a sequence of hardware actions (also called hardware tasks), which can be automatically executed by the hardware without the CPU intervention. Typical triggers include GPIO input status change, timer time out, CPU interrupts etc.\nTerminology # Priority Queues # NanoSync engine supports three priority queues:\nHigh Priority Queue:\nSupports up to 8 defined triggers. Dedicated memory of 512 words. Middle Priority Queue:\nSupports up to 8 defined triggers. Use shared memory, maximum memory usage is 512 words. Low Priority Queue:\nSupports up to 16 defined triggers. Use shared memory, maximum memory usage is 512 words. Higher priority queue can preempt lower priority queue.\nTrigger id # In each queue, there are multiple triggers. And each trigger is assined a unique trigger id. The high priority and middle priority queues have 8 triggers, with trigger id ranging from 0 to 7. The low priority queue has 16 triggers, with trigger id ranging from 0 to 15.\nWhen multiple triggers within the same queue are triggered simultaneously, the trigger with the smallest trigger id will be executed first.\nTrigger Header # Every trigger has a header. Trigger headers are located at beginning of queue memory.\nTrigger Signals # There are 255 trigger signals. And 0xFF is invalid trigger signal(refer to enum trig_cond_idx for details). Each trigger signal corresponds to an external or internal signal. When receive the signal(rising edge/failling edge), it triggers the corresponding trigger and executing the corresponding trigger command.\nTrigger Command # A trigger can have multiple trigger commands. When activated, these commands will be executed sequentially.\nODC(output direct controls) # Used by output command. Has 127 output direct controls(refer to enum trig_odc_idx for details).\nMemory # High priority queue has 512 words(2KB) dedicated memory(trig memory). Middle and low priority queue use shared memory.\nTimer # Each priority queue has its own 24-bit timer.\nAHB/APB bus # Trigger handler can use APB or AHB bus to access peripheral registers.\nAHB bus: CPU can access register with AHB bus. Read and write opertations don\u0026rsquo;t have a fix lantency. The deviation is about 3us.\nAPB bus: CPU can\u0026rsquo;t access register with APB bus. Has fix latency, The deviation is less than 0.1us.\nTrigger Address # All trigger API use word address offset, not byte address. Address offset is start from 0x0.\nTrigger configuration # Enable HW trigger in share memory configuration. The size is low priority queue memory size plus middle priority queue memory size. Maximum size is 4K(0x1000). If enable sleep, should select \u0026ldquo;Reten Mem\u0026rdquo; to retention shared memory and trigger memory.\nTrigger command # Set timer command # This commamnd is used to config the timer.The timer will be initialized with the initial value specified by the command (or the value in the control register) and will start counting down towards 0. If the auto-reload bit of the command is set to 0x1, the timer will restart with the initial value or the value from the control register after reaching 0. If the auto-reload bit of the command is set to 0x0, the timer will stop. If the timer is already running at the time of this command execution, it will be reset to the initial value and restart. Upon reaching 0, the timer can generate an interrupt signal.\nWait timer command # This command is used to wait for the timer to expire. This command will block the subsequent commands until the timer reaches the value specified in the command. If the “stop timer” bit is 1, the timer will stop counting when the timer reaches the expected value. If the “stop timer” bit is 0, the timer will continue counting after it reaches the expected value. It is strongly recommended that this command is NOT used in the highest priority queue as this command might delay the execution of all following triggers in the highest priority queue and also all triggers in the middle and lowest priority queues.\nRegister read and compare command # This command reads a value from a specific register, applies the mask on the read value and then compares the masked value to the expected value. When conditions fails, it can jump to another address to run command.\nRegister write command # This command write 32 bits value to register.\nRegister read and write command # The command reads the register value first and only update the bits to the write value where the corresponding bits in the mask is 1. The actual write value is computed as:\nactual_write_value = (read_value \u0026amp; ( ~ mask )) | (write_value \u0026amp; mask). Register copy command # This command will read the source register address value, and copy data to destination register.\nRegister copy with mask command. # This command will read the source register address value, apply the mask and write the masked value to the destination register address. The destination register value will also be read and the non-mask portion will be unchanged and written back to the destination register address together with the masked source register read value.\nwritten_value = (destination_read_value \u0026amp; (~ mask)) | (source_read_value \u0026amp; mask). Output command # This command output signal with ODC(output direct controls). Refer to enum trig_hdl_idx for specific signal details. Each output command contains an output signal index, a toggle enable and an output value. If the index is larger than 127, the specific ODC is disabled. It is recommended to write 0x7F to all unused output signal index. If the toggle bit is 1 for a given output index, the corresponding output value will be ignored and the corresponding output signal will toggle its current output value to an opposite polarity.\nNotice that we will use a control register to initialize the output port value which will be controlled by the trigger handler before the handler module is enabled. See hal_trig_hdl_gpio_out_en for reference.\nNull command # This command is just a placeholder in the memory and will not execute any operation.\n"},{"id":40,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/pwm-sample.html","title":"PWM Sample","section":"Driver Examples","content":" PWM Sample # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.\nThis routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_pwm in-dev/proj/driver/proj_drv_pwm Configuration # #define PWM0_PERIOD_USEC 10000 Define the PWM period for PWM0.\n#define PWM0_HIGH_USEC 5000 Define the duration of the high level for PWM0.\n#define PWM4_PERIOD_USEC 10000 Define the PWM period for PWM4.\n#define PWM4_HIGH_USEC 3000 Define the duration of the high level for PWM4.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to terminal emulator.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;input any key to pause PWM\u0026rdquo; appearing in the log. This indicates that the PWM has started. Use a logic analyzer or an oscilloscope to connect to GPIO_0_0 (pwm0) and GPIO_1_8 (pwm4) to observe the corresponding square waves with the specified period and duty cycle. "},{"id":41,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/qdec-sample.html","title":"QDEC Sample","section":"Driver Examples","content":" QDEC Sample # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.\nThis routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).\nThe LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_qdec in-dev/proj/driver/proj_drv_qdec Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # The LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nMore information may be found in debug guide page.\nConnection # Connect the VCC and GND of IN6xxE to the qdec board. Then, connect GPIO_1_3 to cha-x-0, GPIO_1_6 to chb-x-0, and GPIO_2_3 to idx-x-0.\nTest Steps # Open Keil and download the proj_drv_qdec project. Press the K1 button and observe the text main start... appearing in the log. Rotate the rotary encoder in the forward direction. The count will increase, and the text cnt is 0x... will be displayed. Note: Connecting GP13 to chb_x_0 and GP16 to cha_x_0 will not affect the program\u0026rsquo;s operation but will change the direction determination during the rotary encoder rotation.\n"},{"id":42,"href":"/docs/in6xx/getting-started/installation/quick-start.html","title":"Quick Start","section":"Installation","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_find_my\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/build/mdk/proj_ble_lp.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN6XXE\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Click \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes.\nNote:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIf Keil displays the following warning dialog, please click the OK button and then select Cortex-M4 on the next page. In the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN602C0 GD25WD40C SPI FLASH \u0026ldquo;flm file by click \u0026ldquo;Add\u0026rdquo; button. Then set start addres to 0x210000 and set size to 0x1000.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":43,"href":"/docs/in6xxe/getting-started/installation/quick-start.html","title":"Quick Start","section":"Installation","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_adv_conn\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/build/mdk/proj_ble_test.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN6XXE\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Click \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes.\nNote:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIf Keil displays the following warning dialog, please click the OK button and then select Cortex-M4 on the next page. In the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN6XX SPI FLASH \u0026ldquo;flm file, set start addres and size.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":44,"href":"/docs/in6xxe/getting-started/installation/quick-start-with-gcc.html","title":"Quick Start with GCC","section":"Installation","content":" Quick Start Guide with GCC # Introduction # This document introduce how to use GCC for software development.\nPreparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install Arm GNU Toolchain (version \u0026ldquo;arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi\u0026rdquo; is recommended).\nInstall Make\nsudo apt-get update sudo apt-get install build-essential Generate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Use Wine to run it on Linux. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Unzip InPlay SDK to \u0026ldquo;~/inplay\u0026rdquo;. Open file \u0026ldquo;~/inplay/in-dev/proj/common/gcc/linux.mk\u0026rdquo;. Set \u0026ldquo;GNU_INSTALL_ROOT\u0026rdquo; to your GCC installation path. Build project \u0026ldquo;proj_ble_adv_conn\u0026rdquo;. cd ~/inplay/in-dev/proj/ble/proj_ble_adv_conn/build/gcc/ make all Use the following command to rebuild project: make cleanall make all "},{"id":45,"href":"/docs/in6xxe/getting-started/installation/run-zephyr-on-in6xxe.html","title":"Run Zephyr on IN6XXE","section":"Installation","content":" Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.\nInplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.\nSetup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows. You can follow Zephyr Getting Started Guide to setup a Zephyr development environment under Windows, it can be divided into following steps:\n1.Install host dependencies, including cmake, Python, devicetree compiler, etc.\nThese are necessary host tools needed to build Zephyr.\n2.Install west and Python dependencies\nBecause IN6XXE support is not merged into the official Zephyr project repository now, you should init west using below command:\nwest init -m https://github.com/InPlay-Inc/zephyr zephyrproject To support IN6XXE, an external module named \u0026ldquo;hal_inplay\u0026rdquo; is added, when you run west update, it will be cloned to your zephyr working directory automatically.\n3.Install Zephyr SDK\nYou only need to install arm-zephyr-eabi cross tool to support IN6XXE.\nBuild the application # Board name of IN6XXE is \u0026lsquo;inplaydk_in612le\u0026rsquo;, you can start with a simple \u0026ldquo;blinky\u0026rdquo; sample:\ncd zephyrproject/zephyr west build -p always -b inplaydk_in612le samples/basic/blinky Flash binary output # You should first refer to JFlash Download Guide to install InplayTools. After that, you can use Jlink to burn the binary output to the on-chip flash with command west flash.\nRun the sample # For the DK board, UART1 is configured as console in the source code, and the baud rate is 115200. There is an USB to UART chip(CH340) integrated on the board which is connected to UART1(GPIO21 as Tx, and GPIO27 as Rx), so you only need to connect the board to PC with USB Type-C cable to see logs or use shell. CH340 drivers should be installed first, you can download it from here. If the sample runs normally, you can see logs output to a serial terminal software like \u0026ldquo;putty\u0026rdquo;.\nSupported drivers # Only these drivers are supported now:\nGPIO pinctrl(partially implemented) UART(support tx and rx with interrupt, so you can use Zephyr shell) BLE hci driver "},{"id":46,"href":"/docs/in6xxe/examples-and-use-case/sdr/sdr-1-master-to-multiple-slave-sample.html","title":"SDR 1 to n Sample","section":"SDR Examples","content":" SDR 1 to n Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. In SDR broadcast systems, signal processing and transmission are both accomplished through software. This allows SDR broadcast equipment to support multiple modulation methods, coding techniques, and transmission protocols, thus achieving compatibility with various broadcast standards. Whether it\u0026rsquo;s the high-quality audio transmission of high-definition broadcasting or the extensive coverage of digital audio broadcasting, SDR delivers excellent performance.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_SDR_1_mst_to_N_slave_master proj_SDR_1_mst_to_N_slave_slave in-dev/proj/SDR/proj_SDR_1_mst_to_N_slave_master in-dev/proj/SDR/proj_SDR_1_mst_to_N_slave_slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nSDR TX success [TX]actual tx bytes=%d\nSDR RX success \u0026quot;[RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d,\u0026quot;\nMore information may be found in debug guide page.\nTest Steps # MASTER\nOpen Keil and download **proj_SDR_1_mst_to_N_slave_master **. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr master process according to the settings in sdr_mstr_trx_t. When the development board received , we will receive log like [TX]actual tx bytes=%d and [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, SLAVE\nOpen Keil and download proj_SDR_1_mst_to_N_slave_slave. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr slave process according to the settings in sdr_slv_trx_t. When the development board received , we will receive log like [TX]actual tx bytes=%d and [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, "},{"id":47,"href":"/docs/in6xxe/examples-and-use-case/sdr/sdr-broadcast-sample-.html","title":"SDR Broadcast Sample","section":"SDR Examples","content":" SDR Broadcast Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. The Master device typically plays a central role in control and management, while multiple Slave devices serve as nodes performing specific communication tasks.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_SDR_Broadcast_Mode_Master proj_SDR_Broadcast_Mode_Slave in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Master in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nSDR TX success [TX]actual tx bytes=%d\nSDR RX success \u0026quot;[RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d,\u0026quot;\nMore information may be found in debug guide page.\nTest Steps # Master\nOpen Keil and download proj_SDR_Broadcast_Mode_Master. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr broadcast process according to the settings in sdr_mstr_trx_t. In broadcast mode, master don\u0026rsquo;t receive. Slave\nOpen Keil and download proj_SDR_Broadcast_Mode_Slave. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr addressless process according to the settings in sdr_slv_trx_t. When sdr communication astablished, we will receive log like [TX]actual tx bytes=%dand [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, "},{"id":48,"href":"/docs/in6xxe/protocols-reference/smull/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"SMULL","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and sync address. Each packet from the slave has its own preamble and sync address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. The data exchange can be configured to operate in three different modes between a master and multiple salves.\nPrivate data exchange mode The master can be configured to send each slave a private packet at each frame. Each slave can be configured to send the master a private packet at each frame. Private packet: There is acknowledgement between the sender and the recipient.\nPublic data exchange mode The master can be configured to send a public packet to all the slaves at each frame.\nPublic packet: Slaves do the acknowledgement. The master does not proceed to next public packet unless the current public packet is acknowledged by all the slaves.\nBroadcasting mode The master can be configured to send a broadcast packet to all the slaves at each frame.\nBroadcast packet: Slaves do not acknowledge the reception of a broadcast packet.\nOverview of transparent data transmission # Many modern applications rely on wireless data transmission; however, end-users often lack knowledge or interest in the underlying wireless technologies. Consequently, we have designed a mechanism that allows users to conveniently utilize the powerful data transfer capabilities provided by SMULL without the need to understand the details of this protocol. Before starting the data transmission, it is necessary to configure the relevant parameters of SMULL to establish a network between the master and slave. By using the commands we provide, you can quickly establish the SMULL network. Please refer to the example provided below for more details. The schematic of the entire system, showing the connection between the host and IN618 module, is illustrated in Figure 3.\nTypically, the host refers to various devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default settings for the UART in our system are illustrated below.\nUART default settings # 115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # In order to facilitate software development with SMULL, we have designed a set of commands for programming. Users can effortlessly start the system by utilizing these commands.The command format is shown as following. Command Code Data Length Data 2 bytes 2 bytes variable bytes Get Slave Number: 0xA011 # This command gets the number of slaves in current network.\nSend: 0xA0 0x11 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x11 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Set Slave Number: 0xA012 # This command is used to configure the number of slaves.The slave number should be less than (or equal to) the maximum slave number (CFG_IPMAC_MAX_SLV_NUM).\nSend: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Response: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: the command sent is too short\nB0=0x02: number of slave is larger than the maximum value Notice:\nAfter successfully setting the slave number on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the slave number on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x13 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Sending this command to the master will not receive any response. Each slave in a network must have a unique ID.\nSend: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Response: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Slave ID is larger than or equal to the slave number which you set. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the slave ID will not be updated.\nGet SYNC Address (Network Address): 0xA015 # This command gets the SYNC address. Each established network should have a unique SYNC address (also known as network address).\nSend: 0xA0 0x15 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x15 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) SYNC Address = (B0 \u0026laquo; 24) | (B1 \u0026laquo; 16) | (B2 \u0026laquo; 8) | B3\nSet SYNC Address (Network Address): 0xA016 # This command can be used to set the SYNC address. The value 0x00000000 will be ignored and the address will not be updated. The value 0xFFFFFFFF also cannot be accepted.\nSend: 0xA0 0x16 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) Response: 0xA0 0x16 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: SYNC address is invalid. Notice:\nFor optimal performance, it is advisable to ensure that the SYNC address bit sequence does not contain four consecutive ones or zeros. Generally speaking, it is better to use a random value. For example,\n0x2954935B is a good value. There are no 4 consecutive ones or zeros in its bit sequence.\n0x10F10724 is not a good value. There are 4 consecutive ones or zeros in its bit sequence.\nAfter successfully setting the SYNC address on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the SYNC address on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet PHY Rate: 0xA017 # This command gets the PHY rate. The supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x17 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Set PHY Rate: 0xA018 # This command can be used to set the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Response: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: PHY Rate is invalid. Notice:\nAfter successfully setting the PHY rate on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the PHY rate on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x19 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x19 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: slave\nB0=0x01: master Set Mode: 0xA01A # This command is used to set the mode (master or slave) on the device. Each device will be configured as a master or a slave. In a network, only one device can be configured as a master.\nSend: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) B0 B0 should be 0 (slave) or 1 (master), other values are considered as invalid. Response: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Mode is invalid. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packet. Here, the downlink means the data are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1B 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Length = (B0 \u0026laquo; 8) | B1\nSet Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packet is 6 bytes. Ensure that the value you set is equal to or greater than 6. This length should be less than 200.\nSend: 0xA0 0x1C 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Response: 0xA0 0x1C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00, success; B0=0x01, The command sent is too short; B0=0x02, Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of downlink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of downlink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Maximum Length of Uplink Private Packet: 0xA01D # the maximum length of uplink private packet. Here, the uplink means the data are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1D 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Set Maximum Length of Uplink Private Packet: 0xA01E # This length should be less than 200.\nSend: 0xA0 0x1E 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Response: 0xA0 0x1E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of uplink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of uplink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Period of Heartbeat Packet: 0xA033 # In order to track the connection status of the network, heartbeat packet is periodically sent between the master and slave(s). Users can get the period of the heartbeat packet by issuing this command. The default value is 1000ms.\nSend: 0xA0 0x33 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x33 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) Set Period of Heartbeat Packet: 0xA034 # Users can change the period of the heartbeat packet by issuing this command.\nSend: 0xA0 0x34 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) If the period is zero, the default value (1000ms) will be used.\nResponse: 0xA0 0x34 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00:success\nB0=0x01:The command is too short Notice:\nThe minimum heartbeat period is 500ms. Thus, the period you set should be larger than or equal to 500ms. If the period is less than 500ms, it will be automatically set to 500ms.\nBroadcast SMULL Settings: 0xA040 # With this command, the master can broadcast the SMULL settings. Once the network has been established, the master can use this command to broadcast the new SMULL-related parameters to all the slaves. The slave will update its settings and reset automatically upon receiving new settings broadcasted by the master.\nSend: 0xA0 0x40 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Broadcast Duration (MSB) B1 Broadcast Duration B2 Broadcast Duration B3 Broadcast Duration (LSB) The broadcast duration in milliseconds indicates how long the broadcast will last. If this value is set to zero, the default value of 3000ms is utilized. To ensure successful reception by each slave, it is recommended to set this value to a minimum of 3000ms.\nResponse: 0xA0 0x40 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: The command is too short\nB0=0x02: In slave mode, this command will be ignored Get SMULL status: 0xA041 # This command gets the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x41 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: It means the SMULL is successfully initialized\nB0=0xFF: It means the SMULL is not initialized. Notice:\nIf the initialization of SMULL fails, any SMULL related command that is issued will result in receiving the following response containing an error code 0xFF.\nCommand Code 0x00 0x01 0xFF\nGet SMULL configurations: 0xA042 # The SMULL configurations consist of 7 parameters: mode, slave number, slave ID, PHY rate, SYNC address, maximum length of downlink private packet and maximum length of uplink private packet. You can get all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) The length of data in successful response differs from that in failure response.\nSuccessful response: 0xA0 0x42 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that is used in your application. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Failure response: 0xA0 0x42 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Set SMULL configurations: 0xA043 # As aforementioned, the SMULL configurations include 7 parameters. You can set these parameters all at once by issuing this command.\nSend: 0xA0 0x43 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that may be used in your application. This number must be less than or equal to the value of CFG_IPMAC_MAX_SLV_NUM. As of the current firmware, CFG_IPMAC_MAX_SLV_NUM is set at 64. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Response: 0xA0 0x43 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: A general error\nB0=0x02: Command length is short\nB0=0x03: Invalid SMULL mode\nB0=0x04: Invalid slave number\nB0=0x05: Invalid slave Id\nB0=0x06: Invalid PHY Rate\nB0=0x07: Invalid SYNC address\nB0=0x08: Invalid downlink packet size\nB0=0x09: Invalid uplink packet size Query Connection Status of Each Slave: 0xA044 # The user can get the connection status of each slave by issuing this command on the master side.\nSend: 0xA0 0x44 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x44 0x00 0x10 B0~B15\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x10 Data Length (LSB) B0 The connection status of slave0 ~ slave7 \u0026hellip; \u0026hellip; B15 The connection status of slave120 ~ slave127 The byte sequence of data B0~B15 is a bit-map, each bit is associated with a slave. B0 is associated with slave0 to slave7, while B1 is associated with slave8 to slave15, and so on. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to show what a response might look like.\nExample1: Assuming that the maximum number of slaves is set to four and that all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00\u0026hellip;0x00. However, in the case where only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00\u0026hellip;0x00.\nExample2: Assuming that the maximum number of slaves is set to nine and that all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, in the case where only slaves 0, 1, 6, 7 and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00..0x00.\nIf this command is executed on the slave side, the response would be 0xA0 0x44 0x00 0x01 0x01.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packet. However, the slave can only trasmit private packets. Below, we will provide a detailed explanation on how to use this command for both the master and the slave.\n①Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively simple.\nSend: 0xA0 0x48 D0 D1 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long ②Master transmits data. The master can transmit three types of packets to the slave: private, public and broadcast. In current firmware, we only support private packet.\nSend: 0xA0 0x48 D0 D1 T0 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) T0 Packet type\n0x00: broadcast\n0x01: public\n0x02: private S0 Slave ID. If sending a private packet, it is necessary to specify which slave it is sent to. B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long\nB0=0x03: Invalid slave ID Receive Data: 0xA049 # When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the user in the following format.\n0xA0 0x49 D0 D1 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x49 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) S0 If data is received by the master, S0 denotes the slave ID.\nIf data is received by the slave, S0 denotes the packet type (0 = broadcast, 1 = public, 2 = private). B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Get UART Configuration: 0xA063 # This command read the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Successful Response: 0xA0 0x63 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control Response with errors: 0xA0 0x63 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control The maximum supported baud rate is 2000000.\nResponse: 0xA0 0x64 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x65 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Response: 0xA0 0x66 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Chip Reset: 0xA0E1 # Typically, when the SMULL parameters are updated, it is recommended to reset the chip by issuing this command.\nSend: 0xA0 0xE1 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xE1 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Example # Before initiating data transmission, it is crucial to set up a network connection - a process also referred to as pairing. To guarantee effective network communication, it is imperative that the SMULL configurations of both the master and each slave must be identical, with the exception of the mode and slave ID. Employing UART for SMULL configuration paves the way for this essential uniformity between the master and all slave devices. To elucidate this setup procedure, we will walk through an illustrative example. The specifications for each network parameter are detailed hereinbelow.\nMode: (master: 0x01, slave: 0x00) Slave number: 4 Slave Id: (0x00 ~ 0x03), master will ignore this value Phyrate: 2M Address: 0x2954935B Maximum length of downlink packet: 10bytes Maximum length of uplink packet: 100bytes Two methods can be used to complete the configuration. Method 1 requires the use of command 0xA043, whereas method 2 entails a combination of commands 0xA01A, 0xA012, 0xA014, 0xA018, 0xA016, 0xA01C, 0xA01E. Once the configuration is completed successfully, it is necessary to execute the reset command.\nMethod1:\nThe command sequence issued by the master would be\n①0xA0 0x43 0x00 0x0C 0x01 0x04 0x00 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave (slave0~slave3) would be\n①0xA0 0x43 0x00 0x0C 0x00 0x04 ID 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nMethod2:\nThe command sequence issued by the master would be\n①0xA0 0x1A 0x00 0x01 0x01\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 0x00\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave would be\n①0xA0 0x1A 0x00 0x01 0x00\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 ID (different slave ID)\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nIn method2, the order of the command sequence is not mandatory. However, the command 0xA014 should be issued after 0xA012 and the reset command must be the final one.\n"},{"id":49,"href":"/docs/solutions/smull/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"SMULL Pass-through Network","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and sync address. Each packet from the slave has its own preamble and sync address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. The data exchange can be configured to operate in three different modes between a master and multiple salves.\nPrivate data exchange mode The master can be configured to send each slave a private packet at each frame. Each slave can be configured to send the master a private packet at each frame. Private packet: There is acknowledgement between the sender and the recipient.\nPublic data exchange mode The master can be configured to send a public packet to all the slaves at each frame.\nPublic packet: Slaves do the acknowledgement. The master does not proceed to next public packet unless the current public packet is acknowledged by all the slaves.\nBroadcasting mode The master can be configured to send a broadcast packet to all the slaves at each frame.\nBroadcast packet: Slaves do not acknowledge the reception of a broadcast packet.\nOverview of transparent data transmission # Many modern applications rely on wireless data transmission; however, end-users often lack knowledge or interest in the underlying wireless technologies. Consequently, we have designed a mechanism that allows users to conveniently utilize the powerful data transfer capabilities provided by SMULL without the need to understand the details of this protocol. Before starting the data transmission, it is necessary to configure the relevant parameters of SMULL to establish a network between the master and slaves. By using the commands we provide, you can quickly establish the SMULL network. Please refer to the example provided below for more details. The schematic of the entire system, showing the connection between the host and IN618 module, is illustrated in Figure 3.\nTypically, the host refers to various devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default settings for the UART in our system are illustrated below.\nUART default settings # 115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # In order to facilitate software development with SMULL, we have designed a set of commands for programming. Users can effortlessly start the system by utilizing these commands.The command format is shown as following. Command Code Data Length Data 2 bytes 2 bytes variable bytes Get Slave Number: 0xA011 # This command gets the number of slaves in current network.\nSend: 0xA0 0x11 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x11 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Set Slave Number: 0xA012 # This command is used to configure the number of slaves.The slave number should be less than (or equal to) the maximum slave number (CFG_IPMAC_MAX_SLV_NUM). In current firmware, the value of CFG_IPMAC_MAX_SLV_NUM is 64.\nSend: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Response: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: the command sent is too short\nB0=0x02: number of slave is larger than the maximum value Notice:\nAfter successfully setting the slave number on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the slave number on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x13 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Sending this command to the master will not receive any response. Each slave in a network must have a unique ID.\nSend: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Response: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Slave ID is larger than or equal to the slave number which you set. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1 or pressing the reset button, otherwise, the slave ID will not be updated.\nGet SYNC Address (Network Address): 0xA015 # This command gets the SYNC address. Each established network should have a unique SYNC address (also known as network address).\nSend: 0xA0 0x15 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x15 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) SYNC Address = (B0 \u0026laquo; 24) | (B1 \u0026laquo; 16) | (B2 \u0026laquo; 8) | B3\nSet SYNC Address (Network Address): 0xA016 # This command can be used to set the SYNC address. The value 0x00000000 will be ignored and the address will not be updated. The value 0xFFFFFFFF also cannot be accepted.\nSend: 0xA0 0x16 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) Response: 0xA0 0x16 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: SYNC address is invalid. Notice:\nFor optimal performance, it is advisable to ensure that the SYNC address bit sequence does not contain four consecutive ones or zeros. Generally speaking, it is better to use a random value. For example,\n0x2954935B is a good value. There are no 4 consecutive ones or zeros in its bit sequence.\n0x10F10724 is not a good value. There are 4 consecutive ones or zeros in its bit sequence.\nAfter successfully setting the SYNC address on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the SYNC address on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet PHY Rate: 0xA017 # This command gets the PHY rate. The supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x17 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Set PHY Rate: 0xA018 # This command can be used to set the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Response: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: PHY Rate is invalid. Notice:\nAfter successfully setting the PHY rate on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the PHY rate on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x19 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x19 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: slave\nB0=0x01: master Set Mode: 0xA01A # This command is used to set the mode (master or slave) on the device. Each device will be configured as a master or a slave. In a network, only one device can be configured as a master.\nSend: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) B0 B0 should be 0 (slave) or 1 (master), other values are considered as invalid. Response: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Mode is invalid. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packet. Here, the downlink means the data are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1B 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Length = (B0 \u0026laquo; 8) | B1\nSet Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packet is 6 bytes. Ensure that the value you set is equal to or greater than 6. This length should be less than 200.\nSend: 0xA0 0x1C 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Response: 0xA0 0x1C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00, success; B0=0x01, The command sent is too short; B0=0x02, Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of downlink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the maximum length of downlink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet Maximum Length of Uplink Private Packet: 0xA01D # Get the maximum length of uplink private packet. Here, the uplink means the data are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1D 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Set Maximum Length of Uplink Private Packet: 0xA01E # This length should be less than 200.\nSend: 0xA0 0x1E 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Response: 0xA0 0x1E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of uplink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the maximum length of uplink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet Maximum Length of Broadcast Packet: 0xA01F # Get the maximum length of broadcast packet.\nSend: 0xA0 0x1F 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1F Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1F 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1F Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of broadcast packet (MSB) B1 Maximum length of broadcast packet (LSB) Set Maximum Length of Broadcast Packet: 0xA020 # This length should be less than 200.\nSend: 0xA0 0x20 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x20 Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of broadcast packet (MSB) B1 Maximum length of broadcast packet (LSB) Response: 0xA0 0x20 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x20 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of broadcast packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1 or pressing the reset button.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip immediately by issuing the command 0xA0E1 or pressing the reset button.\nAfter successfully setting the maximum length of broadcast packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1 or pressing the reset button.\nGet the Interval of Sending Heartbeat Packet: 0xA033 # In order to track the connection status of the network, heartbeat packet is periodically sent between the master and slave(s). Users can get the interval of the heartbeat packet by issuing this command. The default value is 1000ms.\nSend: 0xA0 0x33 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x33 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Interval (MSB) B1 Interval B2 Interval B3 Interval (LSB) Set the Interval of Sending Heartbeat Packet: 0xA034 # Users can change the interval of sending the heartbeat packet by issuing this command.\nSend: 0xA0 0x34 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Interval (MSB) B1 Interval B2 Interval B3 Interval (LSB) Response: 0xA0 0x34 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00:success\nB0=0x01:The command is too short Notice:\nThe minimum heartbeat period is 500ms. Thus, the period you set should be larger than or equal to 500ms. If the period is less than 500ms, it will be automatically set to 500ms.\nGet Superframe Duration: 0xA03A # This command can be used to get the superframe duration in slots. Figure2 illustrates what the superframe is.\nSend: 0xA0 0x3A 0x00 0x00\nResponse: 0xA0 0x3A 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x3A Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Superframe Duration (MSB) B1 Superframe Duration (LSB) Successful Pairing Notification: 0xA03B # This command indicates that all slaves are successfully paired with the master. This is a notification command on the master side, which will be automatically sent to the host when all slaves are successfully paired with the master.\nNotification: 0xA0 0x3B 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x3B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Slave Connection Status Notification: 0xA03C # This command indicates the connection status between the slave and the master. This is a notification command on the slave side, which will be automatically sent to the host when the status of the slave changes.\nNotification: 0xA0 0x3C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x3C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 status: 1-The slave connects to the master, 2-The slave disconnects to the master. Broadcast SMULL Settings: 0xA040 # With this command, the master can broadcast the SMULL settings. Once the network has been established, the master can use this command to broadcast the new SMULL-related parameters to all the slaves. The slave will update its settings and reset automatically upon receiving new settings broadcasted by the master.\nSend: 0xA0 0x40 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Broadcast Duration (MSB) B1 Broadcast Duration B2 Broadcast Duration B3 Broadcast Duration (LSB) The broadcast duration in milliseconds indicates how long the broadcast will last. If this value is set to zero, the default value of 3000ms is utilized. To ensure successful reception by each slave, it is recommended to set this value to a minimum of 3000ms.\nResponse: 0xA0 0x40 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: The command is too short\nB0=0x02: In slave mode, this command will be ignored Get SMULL status: 0xA041 # This command gets the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x41 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: It means the SMULL is successfully initialized\nB0=0xFF: It means the SMULL is not initialized. Notice:\nIf the initialization of SMULL fails, any SMULL related command that is issued will result in receiving the following response containing an error code 0xFF.\nCommand Code 0x00 0x01 0xFF\nGet SMULL configurations: 0xA042 # The SMULL configurations consist of 8 parameters: mode, slave number, slave ID, PHY rate, SYNC address, maximum length of downlink private packet, maximum length of uplink private packet and maximum length of broadcast packet. You can get all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) The length of data in successful response differs from that in failure response.\nSuccessful response: 0xA0 0x42 0x00 0x0E B0~B13\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x0E Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that is used in your application. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) B12 Maximum Length of Broadcast Packet (MSB) B13 Maximum Length of Broadcast Packet (LSB) Failure response: 0xA0 0x42 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Set SMULL configurations: 0xA043 # As aforementioned, the SMULL configurations include 8 parameters. You can set these parameters all at once by issuing this command.\nSend: 0xA0 0x43 0x00 0x0E B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x0E Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that may be used in your application. This number must be less than or equal to the value of CFG_IPMAC_MAX_SLV_NUM. As of the current firmware, CFG_IPMAC_MAX_SLV_NUM is set at 64. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) B12 Maximum Length of Broadcast Packet (MSB) B13 Maximum Length of Broadcast Packet (LSB) Response: 0xA0 0x43 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: A general error\nB0=0x02: Command length is short\nB0=0x03: Invalid SMULL mode\nB0=0x04: Invalid slave number\nB0=0x05: Invalid slave Id\nB0=0x06: Invalid PHY Rate\nB0=0x07: Invalid SYNC address\nB0=0x08: Invalid downlink packet size\nB0=0x09: Invalid uplink packet size\nB0=0x0A: Invalid broadcast packet size Query Connection Status of Each Slave: 0xA044 # The user can get the connection status of each slave by issuing this command on the master side.\nSend: 0xA0 0x44 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x44 0x00 0x10 B0~B15\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x10 Data Length (LSB) B0 The connection status of slave0 ~ slave7 \u0026hellip; \u0026hellip; B15 The connection status of slave120 ~ slave127 The byte sequence of data B0~B15 is a bit-map, each bit is associated with a slave. B0 is associated with slave0 to slave7, while B1 is associated with slave8 to slave15, and so on. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to show what a response might look like.\nExample1: Assuming that the maximum number of slaves is set to four and that all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00\u0026hellip;0x00. However, in the case where only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00\u0026hellip;0x00.\nExample2: Assuming that the maximum number of slaves is set to nine and that all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, in the case where only slaves 0, 1, 6, 7 and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00..0x00.\nIf this command is executed on the slave side, the response would be 0xA0 0x44 0x00 0x01 0x01.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packet. However, the slave can only trasmit private packets. Below, we will provide a detailed explanation on how to use this command for both the master and the slave.\n①Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively simple.\nSend: 0xA0 0x48 D0 D1 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long\nB0=0x04:Fail to allocate memory for transmitting data ②Master transmits data. The master can transmit three types of packets to the slave: private, public and broadcast. In current firmware, we only support private packet and broadcast packet.\nSend: 0xA0 0x48 D0 D1 T0 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) T0 Packet type\n0x00: broadcast\n0x01: public\n0x02: private S0 If the packet type is private, this byte represents the ID of the slave.\nIf the packet type is broadcast, 0 indicates to stop broadcasting, while 1 indicates to continuously broadcast this data packet. B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail to transmit data\nB0=0x02: The length of transmitted data is too long\nB0=0x03: Invalid slave ID\nB0=0x04:Fail to allocate memory for transmitting data Receive Data: 0xA049 # This is a notification command. When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the host in the following format.\n0xA0 0x49 D0 D1 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x49 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) S0 If data is received by the master, S0 denotes the slave ID.\nIf data is received by the slave, S0 denotes the packet type (0 = broadcast, 1 = public, 2 = private). B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Get slave connection status: 0xA04B # This command can be used to get the connection status on the slave side.\nSend: 0xA0 0x4B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x4B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x4B 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x4B Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Idle, B0=0x01: connect, B0=0x02: disconnect Slave GPIO Configuration: 0xA04E # This command can be used to configure the slave\u0026rsquo;s GPIO on the master side. When the master receives this command, it will send these configurations to the slave.\nSend: 0xA0 0x4E 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x4E Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Slave ID B1 GPIO Port B2 GPIO Pin B3 GPIO Direction. 0x00:default, 0x01:output, 0x02:input, 0x03: disable input and output B4 Pull. 0x00:default, 0x01:pull-up, 0x02:pull-down, 0x03: disable pull-up and pull-down B5 Latch. 0x01:GPIO latch during deep sleep, others:disable latch B6 Config GPIO pin to level wake up. 0x00:default, 0x01:high, 0x02:low B7 Config GPIO pin to edge wake up. 0x00:default, 0x01:rising edge, 0x02:falling edge, 0x03:rising and falling edge Response: 0xA0 0x4E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x4E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success, B0=0x01: Invalid Command length Configure the GPIO output level of one slave: 0xA04F # This command can be used to configure the output level of slave\u0026rsquo;s GPIO on the master side. When the master receives this command, it will send this configuration to specific slave.\nSend: 0xA0 0x4F 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x4F Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Slave ID B1 GPIO Port B2 GPIO Pin B3 Output level. 0x00:low, 0x01:high Response: 0xA0 0x4F 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x4F Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success, B0=0x01: Invalid Command length Open a PWM of one slave: 0xA052 # This command can be used to open a PWM of one slave on the master side. When the master receives this command, it will send this information to specific slave.\nSend: 0xA0 0x52 0x00 0x02 B0~B1\nByte Comment 0xA0 Command Code (MSB) 0x52 Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Slave ID B1 PWM ID. In current firmware, the available PWM IDs are 0, 1, 5, 6, 7. Response: 0xA0 0x52 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x52 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success, B0=0x01: Invalid Command length, B0=0x02: Invalid PWM ID, B0=0x03: This PWM is not supported in this firmware. Set the duty cycle of slave\u0026rsquo;s PWM and start this PWM: 0xA053 # This command can be usd to set the duty cycle of slave\u0026rsquo;s PWM and start this PWM on the master side. When the master receives this command, it will send this information to specific slave.\nSend: 0xA0 0x53 0x00 0x0B B0~B10\nByte Comment 0xA0 Command Code (MSB) 0x53 Command Code (LSB) 0x00 Data Length (MSB) 0x0B Data Length (LSB) B0 Slave ID B1 PWM ID. In current firmware, the available PWM IDs are 0, 1, 5, 6, 7. B2 PWM start. 0x00: Stop, 0x01: Start B3 PWM period in microseond. (MSB) B4 PWM period in microseond. B5 PWM period in microseond. B6 PWM period in microseond. (LSB) B7 PWM high in microseond. (MSB) B8 PWM high in microseond. B9 PWM high in microseond. B10 PWM high in microseond. (LSB) Response: 0xA0 0x53 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x53 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success, B0=0x01: Invalid Command length, B0=0x02: Invalid PWM ID, B0=0x03: This PWM is not supported in current firmware. Get UART Configuration: 0xA063 # This command read the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Successful Response: 0xA0 0x63 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control Response with errors: 0xA0 0x63 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control The maximum supported baud rate is 2000000.\nResponse: 0xA0 0x64 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x65 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Response: 0xA0 0x66 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Chip Reset: 0xA0E1 # Typically, when the SMULL parameters are updated, it is recommended to reset the chip by issuing this command.\nSend: 0xA0 0xE1 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xE1 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get Firmware Version Number: 0xA0EB # This command is used to get the firmware version.\nSend: 0xA0 0xEB 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xEB Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xEB 0x00 0x06 B0~B5\nByte Comment 0xA0 Command Code (MSB) 0xEB Command Code (LSB) 0x00 Data Length (MSB) 0x06 Data Length (LSB) B0~B5 Firmware Version. This version number is a string: \u0026ldquo;vX.X.X\u0026rdquo; Example # Before initiating data transmission, it is crucial to set up a network connection - a process also referred to as pairing. To guarantee effective network communication, it is imperative that the SMULL configurations of both the master and each slave must be identical, with the exception of the mode and slave ID. Employing UART for SMULL configuration paves the way for this essential uniformity between the master and all slave devices. To elucidate this setup procedure, we will walk through an illustrative example. The specifications for each network parameter are detailed hereinbelow.\nMode: (master: 0x01, slave: 0x00) Slave number: 4 Slave Id: (0x00 ~ 0x03), master will ignore this value Phyrate: 2M Address: 0x2954935B Maximum length of downlink packet: 10bytes Maximum length of uplink packet: 100bytes Two methods can be used to complete the configuration. Method 1 requires the use of command 0xA043, whereas method 2 entails a combination of commands 0xA01A, 0xA012, 0xA014, 0xA018, 0xA016, 0xA01C, 0xA01E. Once the configuration is completed successfully, it is necessary to execute the reset command.\nMethod1:\nThe command sequence issued by the master would be\n①0xA0 0x43 0x00 0x0C 0x01 0x04 0x00 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave (slave0~slave3) would be\n①0xA0 0x43 0x00 0x0C 0x00 0x04 ID 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nMethod2:\nThe command sequence issued by the master would be\n①0xA0 0x1A 0x00 0x01 0x01\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 0x00\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave would be\n①0xA0 0x1A 0x00 0x01 0x00\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 ID (different slave ID)\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nIn method2, the order of the command sequence is not mandatory. However, the command 0xA014 should be issued after 0xA012 and the reset command must be the final one.\n"},{"id":50,"href":"/docs/in6xxe/user-guides/driver-integration/spi-guide.html","title":"SPI Communication","section":"Driver Integration","content":" SPI Guide # Overview # SPI, which stands for Serial Peripheral Interface, is a high-speed, full-duplex, synchronous communication bus that allows data transmission between a microcontroller and peripheral devices. It utilizes a master-slave model, with the master device controlling a set of slave devices. SPI requires four signal lines:\nSCLK for synchronization\nMOSI for data transmission from master to slave\nMISO for data transmission from slave to master\nSSN for selecting the slave device to communicate with.\nInit # Master # Refer to \u0026ldquo;proj_drv_spi_master\u0026rdquo;.\nConfigure spi master:\nspi_config_t config = {0}; config.dfs = SPI_DFS_8_BITS; //data frame size config.cs = 0; //slave select, only available for master SPI config.phase = 1; //phase config.polarity = 1; //polarity config.speed = 100000; //speed in Hz, only available for master SPI config.intr_prio = IRQ_PRI_Normal; //interrupt priority config.arg = NULL; //The variables needed in callback config.callback = spi_callback; //when spi process finished, callback set here will be invoked void *hdl = hal_spi_open(MSPI_ID, \u0026amp;config); //use MSPI_ID when it play the role as spi master Slave # Refer to \u0026ldquo;proj_drv_spi_slave\u0026rdquo;.\nConfigure spi slave:\nspi_config_t config = {0}; config.dfs = SPI_DFS_8_BITS; //data frame size config.phase = 1; //phase config.polarity = 1; //polarity config.intr_prio = IRQ_PRI_Normal; //interrupt priority config.arg = NULL; //The variables needed in callback config.callback = spi_callback; //when spi process finished, callback set here will be invoked config.trig_queue = TRIG_HP_QUEUE; //trigger queue void *hdl = hal_spi_open(SSPI1_ID, \u0026amp;config); Output(TX) # If data needs to be transferred from MOSI(when using master tx) or MISO(when using slave tx), we can use hal_spi_tx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nIf we want a faster speed, we can use the DMA mode, that is, replacing hal_spi_tx with hal_spi_tx_dma.\nstatic uint8_t tx_buf[256]; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_tx(hdl, tx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len); /* int hal_spi_tx(void *hdl, void *buffer, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *buffer: buffer need to tx buffer_len: tx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process. *actual_size: actual tx size. */ Input(RX) # If data needs to be received from MOSI(when using master tx) or MISO(when using slave tx), we can use hal_spi_rx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nIf we want a faster speed, we can use the DMA mode, that is, replacing hal_spi_rx with hal_spi_rx_dma.\nstatic uint8_t rx_buf[256]; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_rx(hdl, rx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len);\t/* int hal_spi_Rx(void *hdl, void *buffer, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *buffer: buffer recived buffer_len: rx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process *actual_size: actual rx size */ TRX # If bidirectional data transmission is required, we can use hal_spi_trx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nstatic uint8_t tx_buf[256]; static uint8_t rx_buf[256]; uint16_t trx_len = 0; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_trx(hdl, tx_buf, rx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len);\t/* int hal_spi_trx(void *hdl, void *wbuf, void *rbuf, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *wbuf: buffer need to transfer *rbuf: buffer received buffer_len: rx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process *actual_size: actual rx size */ Cancel SPI process # when we want to stop and cancel spi process, we can use hal_spi_cancel.\nint ret = hal_spi_cancel(hdl); //hdl: handle return when we use hal_spi_open Close SPI # when SPI case finished, we can close SPI device with hal_spi_close.\nint ret = hal_spi_close(hdl); //hdl: handle return when we use hal_spi_open "},{"id":51,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/spi-sample.html","title":"SPI Sample","section":"Driver Examples","content":" SPI Sample # Overview # SPI (Serial Peripheral Interface) communication is a synchronous serial transmission specification typically used for communication between microprocessing control units (MCUs) and peripheral devices. This communication method is characterized by its high speed, full-duplex, and synchronous nature, achieving data transmission through four wires (MISO, MOSI, SCLK, CS/SS) on chip pins.\nSPI communication consists of a master device and one or more slave devices. The master device initiates synchronized communication with the slave devices to complete data exchange. During the communication process, the master device configures and generates clock signals, which are used to synchronize data transmission. Each clock cycle transmits one bit of data, so the speed of data transmission is determined by the frequency of the clock signal.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_SPI in-dev/proj/driver/proj_drv_SPI_master in-dev/proj/driver/proj_drv_SPI_slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both master and slave according to Uart Log and LED.\nWhen we transmit or receive data, we can get information on uart log. More information may be found in debug guide page.\nTest Steps # Master Setup and Download Open proj_drv_SPI_master, compile, and download the project. Press the reset button. Slave Setup and Download Open proj_drv_SPI_slave, compile, and download the project. Press the reset button. Testing Reset the slave first, then reset the master. We can see the data appearing in the LOG based on the selected mode of the master. master exchange data with slave. Each time the SPI master and slave receive data, the values range from 0x00 to 0xFF. "},{"id":52,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/timer-sample.html","title":"Timer Sample","section":"Driver Examples","content":" Timer Sample # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.\nThis routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_timer in-dev/proj/driver/proj_drv_timer Configuration # #define TEST_CASE SIMPLE_TIMER_ONCE After displaying \u0026ldquo;Select a number to test:\u0026rdquo; on the log, you can input a number between 0 and 2 to select a mode, including:\nenum { SIMPLE_TIMER_ONCE = 0, SIMPLE_TIMER_RELOAD, TIMER_EMIT, TIMER_CAPTURE, TIMER_MANUAL, };\tSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\n#define TMR_ID TMR0_ID Select the TMR ID to be used. This configuration is only effective for SIMPLE_TIMER_ONCE and SIMPLE_TIMER_RELOAD in the TEST CASE.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log.\nSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text test case: %d on the log, where %d represents the selected mode. Simple Timer Example: Depending on whether it is RELOAD or not, the callback may or may not appear repeatedly. If it is ONCE, it will stop after tmr cb. Emit \u0026amp; Capture: Two IN628E boards are required for testing. Download the emit program to Board 1 and the capture program to Board 2. After downloading, connect the signal pins (GPIO_2_7, GPIO_2_8, or GPIO_2_2) of Board 1 to the receiving signal pin (GPIO_0_3) of Board 2. Reset both boards simultaneously to receive signals on Board 2. "},{"id":53,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/trigger-example-guide.html","title":"Trigger Sample","section":"Driver Examples","content":" Trigger Sample # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger. Three types of priority can be chosen, TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE.\n#define OUTPUT_PORT 0 #define OUTPUT_PIN 1 define the output pin.\n#define TIRG_COND_PORT 0 #define TIRG_COND_PIN 3 define the trigger condition pin.\n#define DEBUG_PORT 0 #define DEBUG_PIN 4 define the debug pin.\n#define TEST_OUTPUT_CMD 0 //test output #define TEST_REG_WR_CMD 0 //test register write #define TEST_TIMER_CMD 1 //test set timer and wait timer #define TEST_REG_CP_CMD 0 //test compare the value in register #define TEST_REG_MASK_CP_CMD 0 //test mask compare the value in register #define TEST_REG_RW_CMD 0 //test register read and write #define TEST_RD_CMP_CMD_WAIT 0 // //test read and compare the value in register(wait) #define TEST_RD_CMP_CMD_NO_WAIT 0 //test read and compare the value in register(not wait) Change the operation mode.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the trigger interrupt status on UART log.\nTEST_OUTPUT_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, it will output a high or low voltage level on the output pin based on whether it\u0026rsquo;s a rising or falling edge.\nTEST_REG_WR_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, value set will be written to register.\nTEST_TIMER_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, timer will be set, start and then stop.\nTEST_REG_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address.\nTEST_REG_MASK_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address with mask.\nTEST_REG_RW_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, read and write the register.\nTEST_RD_CMP_CMD_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nTEST_RD_CMP_CMD_NO_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nMore information may be found in debug guide page.\n​\nTest Steps # Open Keil and select the desired functionality, then download proj_drv_trig. Press the K1 button and observe the text \u0026ldquo;main start\u0026rdquo; appearing in the log. When the trigger pin is triggered, you will see something like \u0026ldquo;irq 0x5\u0026rdquo; in Figure 1-1, where 5 represents the status. At the same time, the corresponding functionality will be implemented based on the selected option. "},{"id":54,"href":"/docs/in6xxe/user-guides/driver-integration/uart-guide.html","title":"UART Communication","section":"Driver Integration","content":" UART Guide # Overview # The Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol that enables serial data transmission between devices. It is widely used for communication between microcontrollers and various peripherals, such as computers, sensors, and other embedded systems.\nInitialization # Before using the UART interface, it needs to be properly initialized. Configure the UART settings according to the uart_init_t struct:\nuart_init_t init = {0}; init.baud_rate = 115200; /**\u0026lt; Baud rate (e.g., 9600, 115200, etc.) */ init.data_len = 8; /**\u0026lt; Data length (5, 6, 7, or 8 bits) */ init.stop_bit = 1; /**\u0026lt; Stop bit (1 or 2 bits) */ init.parity_en = 0; /**\u0026lt; Enable parity bit (0: disabled, 1: enabled) */ init.even_parity = 0; /**\u0026lt; Parity type (0: odd, 1: even) */ init.fc = 0; /**\u0026lt; Flow control (0: disabled, 1: enabled) */ init.no_intr = 0; /**\u0026lt; Interrupt mode (0: enabled, 1: disabled) */ init.prio = IRQ_PRI_Normal; /**\u0026lt; Interrupt priority */ init.rx_arg = NULL; /**\u0026lt; Argument for RX callback */ init.rx_cb = rx_cb; /**\u0026lt; RX callback function */ init.tx_arg = NULL; /**\u0026lt; Argument for TX callback */ init.tx_cb = tx_cb; /**\u0026lt; TX callback function */ uart_hdl = hal_uart_open(UART0_ID, \u0026amp;init); UART Transmission # UART TX by Interrupt # res = hal_uart_tx(hdl, buffer, buffer_len, poll); /** * @brief UART TX by interrupt * @note This function can be in either block or non-block mode. If TX completion callback function is not specified, this function will be blocked until TX completed. Otherwise, this function will return (non-block) without waiting for the TX completion. Later on, the TX completion callback function will be called from the driver\u0026#39;s interrupt service routine to indicate transfer completed, the exact transmit bytes, and any errors. * * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer to TX * @param[in] buffer_len Data buffer length * @param[in] poll 0: interrupt mode, 1: polling mode. * * @return Driver error return code, @see enum uart_err */ UART TX by DMA # res = hal_uart_tx_dma(hdl, buffer, buffer_len, poll); /** * @brief UART TX by DMA * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer pointer for TX * @param[in] buffer_len Data buffer length. Max 2047 for DMA transmission. * @param[in] poll 0: interrupt mode, 1: polling mode, disable interrupt in polling mode. * * @return Driver error return code, @see enum uart_err */ UART Reception # UART RX by Interrupt # res = hal_uart_rx(hdl, buffer, buffer_len, poll, tmo, actual_rx_len); /** * @brief UART RX by interrupt * @note This function can be in either block or non-block mode. If RX completion callback function is not specified, this function will be blocked until RX completed. Otherwise, this function will return (non-block) without waiting for the RX completion. Later on, the RX completion callback function will be called from the driver\u0026#39;s interrupt service routine to indicate transfer completed, the exact receive bytes, and any errors. * * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer to RX * @param[in] buffer_len Data buffer length * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout for block call. 0: means non-block call, need to set callback function. * @param[out] actual_rx_len Blocking call return the exact RX bytes * * @return Driver error return code, @see enum uart_err */ UART RX by DMA # res = hal_uart_rx_dma(hdl, buffer, buffer_len, poll, tmo, actual_rx_len); /** * @brief UART RX by DMA * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer pointer for RX * @param[in] buffer_len Data buffer length. Max 2047 for DMA transmission. * @param[in] poll 0: interrupt mode, 1: polling mode, disable interrupt in polling mode. * @param[in] tmo Timeout for block call, 0: means non-block call, need to set callback function. * @param[out] actual_rx_len Blocking call return the exact RX bytes * * @return Driver error return code, @see enum uart_err */ Cancel UART RX # res = hal_uart_cancel_rx(hdl); /** * @brief Cancel UART RX * @note This function is used for both DMA and non-DMA modes. * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @return Driver error return code, @see enum uart_err */ "},{"id":55,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/uart-sample-guide.html","title":"UART Sample","section":"Driver Examples","content":" UART Sample # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.\nIn this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_UART in-dev/proj/driver/proj_drv_UART Configuration # #define MODE 2 Change the operating mode by replacing the number 2 with 0, 1, or 2.\n0 is POLL mode, 1 is INTR mode, and 2 is DMA mode.\n#define EN_FLOW_CTRL 0 0 indicates disabled flow control, 1 indicates enabled flow control.\n#define UART_BAUDRATE 115200 Set the baud rate for UART.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get information simply on UART log.\nMore information may be found in debug guide page.\nTest Steps # Without Flow Control Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;use poll mode\u0026rdquo; on the log, where \u0026ldquo;poll\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. With Flow Control Use the in_config tool to open the inc/in_config.h file in the corresponding project folder, check GPIO 1-5 and GPIO 1-6 under the peripheral section for MUX1, and connect them to CTS and RTS, respectively. Save the changes and open Keil to download the project. Open the debugger, check RTS or other flow control switches, and observe the text \u0026ldquo;use DMA mode\u0026rdquo; on the log, where \u0026ldquo;DMA\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. "},{"id":56,"href":"/docs/solutions/stellar/stellar-gateway-wireless-communication-protocol-implementation-guide.html","title":"Wireless Communication Protocol","section":"Stellar","content":" Stellar Gateway Wireless Communication Protocol Implementation Guide # Purpose # This guide offers a comprehensive overview of the Stellar Gateway Wireless Communication Protocol, focusing on its practical implementation. Covering the design, functional operation, command structure, and safety precautions, it is tailored for developers, system integrators, and technical professionals who seek a deep understanding of how to effectively employ and optimize devices using the Stella Gateway Wireless Protocol.\nDefinition Glossary # BLE (Bluetooth Low Energy): A power-efficient version of the classic Bluetooth wireless technology. It\u0026rsquo;s designed for short bursts of long-range radio connection, making it perfect for IoT (Internet of Things) applications.\nSDR (Software Defined Radio): A radio communication system where traditional hardware components like modulators, demodulators, and tuners are instead implemented in software. This allows for more flexibility and adaptability in handling various frequencies and communication types.\nGATT (Generic Attribute Profile): A specification that describes in detail how attributes (data) are transferred once devices have connected using BLE.\nGATT Handler: Refers to the specific GATT characteristic or descriptor handle, which identifies a particular piece of data on a BLE device.\nBLE Peripheral: Refer to BLE standard Peripheral devices that gateway supports. It can be either BLE advertiser only (BLE beacon) or connectable peripheral devices.\nBLE Data Exchange: Refers to BLE data transmission and reception with connectable BLE Peripheral following standard BLE GATT protocol.\nSDR Network Address: InPlay SDR devices use two-layer addressing to support network communications. There are network address and device address. The network address is shared by all the devices in an SDR basic network.\nSDR Device Address: Each InPlay SDR device is assigned to have a 16-bit address. This address can be used to facilitate private data communication in a network with multiple SDR devices.\nSDR Broadcast: A kind of wireless signal transmission by SDR on broadcast channel, which does not concern if signals are actually received no not. In this case, SDR Device Address is not necessary.\nSDR Private Data Exchange: A kind of wireless signals transmission by SDR on non-broadcast channel between given SDR node and Stellar Gateway. If acknowledgement is not received from peer, communication is considered failed. In this case, SDR Device Address is necessary for both two sides of communication, in Stellar world, Stellar Gateway and SDR Node.\nSDR Node: Refer to slave devices by SDR in the Stellar Gateway network. It can be device that transmit SDR Broadcast only, or one that support SDR Private Data Exchange simultaneously.\nScanner Module: A functional component of Stellar Gateway that actively searches for available devices or signals of either SDR Broadcast or BLE advertisement within its vicinity.\nTransceiver Module: A functional component of Stellar Gateway that can transmit and receive signals of either SDR Private Data Exchange or BLE Data Exchange.\nController: Refers to the dedicated hardware or software component responsible for overseeing, managing, and directing the operations and data flow of the unit. It ensures that signals are received, processed, and transmitted appropriately, interfacing with both the Scanner Module and the Transceiver Module to achieve optimal performance.\nError Code: A system-defined numeric value that signifies a specific type of error or issue encountered during command execution.\nIntroduction # The Stellar Gateway Wireless Communication Protocol Implementation Guide delves deep into the Stellar Gateway Wireless Module\u0026rsquo;s practical use. This module is an integral component in today\u0026rsquo;s wireless communication ecosystems. It effectively integrates the Scanner and Transceiver modules, with the Controller MCU as the primary interface and managerial component.\nSystem Diagram # The Stellar Gateway system block diagram is shown in Figure1. The Stella Gateway contains 4 IN612Ls as key parts of Stella Gateway Wireless Modules. From the functional point of view, they can be subdivided into Scanner and Transceiver Module. Also present in the gateway is the Controller module, which serves as the connection between these two wireless modules and an interaction with the host.\nScanner Module: # Its primary function is to scan SDR Broadcasts or BLE Advertisements. It incorporates three IN612Ls, with each one designated to scan a specific channel.\nTransceiver Module: # One IN612L is in this module which dedicated on SDR P2P Data Exchange or BLE Data Exchange with connectable BLE Peripheral.\nController: # A third-party MCU typically processes commands from the host. Upon receiving these commands, it interprets them and sends the relevant data structure to both the Scanner and Transceiver for radio activities. Furthermore, this Controller acquires advertising or broadcasting reports from the Scanner, filters these reports, and subsequently sends a singular event to the Host. In Stella Gateway, the Controller uses AT32F413 and its development is beyond the scope of this document. Please visit ARTERY website for AT32F413 SDK and any reference development documents. This document aims to explain the data exchange protocols between the Controller and the Scanner/Transceiver.\nFigure 1: Stella Gateway diagram\nCommunication Interface # The interface between each IN612L and the Controller is USART bus. For AT32F413 controller, the USART ports with 612Ls are USART1, USART2, USART3, UART4.\nThe default USART parameters are as follows:\n921600 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled For interface between Controller and Host, Please refer to Stella Gateway Hardware User Guide for more details.\nCommand Description # Data exchanged between the Controller and Scanner/Transceiver is formatted as a byte array. All values follow the Big-endian convention (MSB first).\nModule Reset # This command is used to reset any IN612L in Scanner or Transceiver. It is essential for system maintenance and troubleshooting. The Reset command is unique in that no response is returned upon its execution.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 1 Command Id for \"Reset\" 1 Reset Option 1 1 System Reset Response: N/A\nExample:\n→01 01\nModule Configure # This command configures the type of IN612L, either as Scanner or Transceiver, as well as the SDR Broadcast access address and SDR P2P Data Exchange access address. It’s core setting command that must be executed first for system initialization. Once executed, it should NOT be called again unless the “Reset” command is issued.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 2 Command Id for \"Configure\" 1 Module 1 0: Scanner\n1: Transceiver Module type that IN612L configures to 2 SDR broadcast network address 4 32 bit Number Network address of SDR broadcast. If 0, SDR broadcast is not available 6 SDR private network address 4 32 bit Number Network address of SDR private data exchange. If 0, SDR private data exchange is not available 10 SDR address 2 0x0001 - 0xFF SDR address for gateway when SDR private data exchange. Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 2 Command Id for \"Configure\" 1 Result 2 Error Code Command Error Code Example:\n//Configure 612L as Scanner. SDR Broadcast on netword address 0x11223344, SDR Private Data Exchange on network address 0x33445566, and gateway\u0026rsquo;s SDR address is 1.\n→02 00 44 33 22 11 66 55 44 33 01 00\n//Configure 612L as Transceiver. SDR Broadcast on netword address 0x11223344, SDR Private Data Exchange on network address 0x33445566, and gateway\u0026rsquo;s SDR address is 1.\n→02 01 44 33 22 11 66 55 44 33 01 00\n//Command successful.\n←02 00 00\nModule Start Control # This command provides dynamic operational control (start or stop) of the Scanner or Transceiver. Only IN612L with same Module type which is set via “Configure” command can accept this command with same “Module” parameters.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 3 Command Id for \"Module Start Control\" 1 Module 1 0 , 1 0: Scanner\n1: Transceiver 2 SDR Channel 1 1 - 40 Channel SDR broadcast on. Available only for \"Scanner\" module. 3 SDR Window 2 0 - 4000 SDR broadcast scan time in microseconds. Available only for \"Scanner\" module. 0 to stop SDR scan. If SDR is not supported, its value is skipped. 5 BLE Channel 1 0 , 37 - 39 If 0, scan in turn on all three BLE advertising channel; or else scan on fixed channel. 6 BLE Window 2 0 - 4000 BLE advertising scan time in microseconds. Available only for \"Scanner\" module. 0 to stop BLE scan. 2 Sync Interval 2 0 , 100 - 60000 The time interval at which the Transceiver will transmit a synchronization signal. 0 to stop synchronization signal transmission. The shorter synchronize interval is, the more frequently SDR nodes wake up to exchange data with gateway and raise date rate of SDR Private Data Exchange accordingly. The cost is power consumption of the node. Available only for \"Transceiver\" module. If SDR is not supported, its value is skipped. Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 3 Command Id for \"Module Start Control\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Start SDR broadcast only scan every 1000ms on channel 15.\n→03 00 0F E8 03 00 00 00\n//Start BLE advertising only scan every 1000ms on all 37 to 39 channels.\n→03 00 00 00 00 00 E8 03\n//Start Transceiver with sync interval 100ms.\n→03 01 64 00\n//Error Scanner parameter not set (0x0111).\n←03 11 01\nSet Scan Filter # This command allows setting a filter for the Scanner based on specific criteria to help in narrowing down and focusing on specific data while scanning. This command is allowed be executed dynamically while Scanner has started. Another way is to stop Scanner first, set the filter and start again, which makes scan report more clear and accurate. This command is acceptable for Scanner only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 4 Command Id for \"Set Scan Filter\" 1 Len 1 0 - 10 Filter bytes array length 2 Filter \u0026lt;Len\u0026gt; Bytes array Filter raw bytes array Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 4 Command Id for \"Set Scan Filter\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Set filter manufacturer ID 0x004c (Apple Inc).\n→04 02 4C 00\n//Command successful.\n←04 00 00\nSDR Multicast Data # This command initiates SDR multicast data to SDR nodes. Multicast data is transmitted over synchronizing signals in Transceiver as a result all kinds of SDR nodes can receive data. But it’s up to SDR node’s implementation (group id match etc.) whether data is acceptable. This command is acceptable for Transceiver module only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 5 Command Id for \"SDR Multicast Data\" 1 Group Id 1 0 - 255 Group Id that SDR node belongs to 2 Duration 2 unsigned short Time that the command executes in ms. 0 to stop. 4 Len 1 1 - 251 SDR multicast data length 5 Date \u0026lt;Len\u0026gt; - Multicast data Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 5 Command Id for \"Set Scan Filter\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Send multicast data \u0026ldquo;00 01\u0026rdquo; to SDR nodes with group id 1 for 1000ms\n→05 01 03 e8 02 00 01\n*//Command completes successfully\n←05 00 00\nSDR Private Data Exchange # This command initiates SDR Private Data Exchange between Transceivers and single SDR nodes that support private data exchange. It’s direct, private two-way communication between node and gateway. This command is acceptable for Transceiver only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 6 Command Id for \"SDR Private Data Exchange\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 6: SDR Node that support Private Data Exchange 7 Len 1 1 - 251 SDR Private Data length 8 Data \u0026lt;Len\u0026gt; byte array SDR Private Data Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 6 Command Id for \"SDR Private Data Exchange\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 4: SDR Broadcast only Node 6: SDR Node that support Private Data Exchange 7 Result 2 16bits unsigned integer Command Error Code Example:\n//Send data \u0026ldquo;00 01\u0026rdquo; to SDR node [0x01, 0x01, 0x06]\n→06 01 00 00 00 01 06 02 00 01\n*//Command completes successfully\n←06 01 00 00 00 01 06 00 00\nBLE Connection # TBD\nBLE GATT Service Discovery # TBD\nBLE GATT Read # TBD\nBLE GATT Write # TBD\nEvent Description # When scanning, due to high-capacity nodes that gateway supports and limited resources of 612L, SDR Broadcast Report and BLE Advertising Report are dispatched in a structured manner, where the data frame is of a fixed size of 39 bytes. In this context:\nAn SDR broadcast signifies a method by which a software-defined radio sends information.\nA BLE advertisement indicates that a Bluetooth Low Energy device is publicly broadcasting data, often for discovery by other devices.\nFor this notification, if payload of an SDR broadcast or BLE advertisement exceeds 31 bytes, scanner will discard the rest and hense the payload is not complete.\nDuring private data exchange, transceivers are devices that both transmit and receive data. In this context, Transceiver event may be either data from given SDR node when engaged in SDR Private Data Exchange or BLE GATT Notification Data from BLE connectable peripheral.\nSDR Broadcast Report # The SDR Broadcast Report is an event in which the Scanner notifies the system when it captures an SDR broadcast. The detailed information about this broadcast is tabulated in the format mentioned, which includes the event ID, virtual ID of the SDR node, the group ID of the SDR node, etc. The event example demonstrates the structure in which the data is presented.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x64 Event Id for \"SDR Broadcast Report\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 4 4: SDR Broadcast only Node 6: SDR Node that support Private Data Exchange 7 Time Stamp 2 unsigned short Time stamp in 10ms unit when SDR broadcast is captured 9 RSSI 1 signed char Received Signal Strength Indicator in dBm 10 Len 1 1 - 27 SDR broadcast payload length 11 Payload \u0026lt;Len\u0026gt; byte array SDR broadcast payload Example:\n//SDR Broadcast from node [0x44,0x01,0x04], RSSI is 0xB6 (-74dBm), payload \u0026ldquo;D4 0A\u0026rdquo;\n←64 44 00 00 00 01 04 51 86 B6 02 D4 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nBLE Advertising Report # The BLE Advertising Report is an event when the Scanner captures a BLE advertisement. Information related to this event includes the event ID, BLE Mac Address, timestamp of the event, Received Signal Strength Indicator (RSSI), and other relevant data. An example to depict this structure is also provided.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x65 Event Id for \"BLE Advertising Report\" 1 MAC Adddress 6 - MAC Address of BLE advertiser (Beacon) 7 Time Stamp 2 unsigned short Time stamp in 10ms unit when advertisement is captured 9 RSSI 1 signed char Received Signal Strength Indicator in dBm 10 Flag 1 - Bit 7:1 Reserved Bit 0 0: Non-connectable\n1: Connectable 11 Len 1 1 - 27 BLE advertisement payload length 12 Payload \u0026lt;Len\u0026gt; byte array BLE advertisement payload Example:\nBLE advertising from 00:01:02:03:04:AB, RSSI is 0xAC (-84dBm), payload \u0026ldquo;07 09 49 6E 50 6C 61 79\u0026rdquo;\n←65 AB 04 03 02 01 00 94 C1 AC 01 07 09 49 6E 50 6C 61 79 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSDR Private Data Reception # The SDR Private Data Reception event signifies the reception of data directly from given SDR node. This event captures the essence of the data being transmitted from given SDR node that support private data exchange, which include details such as the virtual ID, group ID, type of SDR node, and the data itself. The accompanying example provides clarity on the data structured representation.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x66 Event Id for \"SDR Private Data Recepiton\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 4: SDR Broadcast only Node (Beacon)\n6: SDR Node that support Private Data Exchange 7 Len 1 unsigned char Data Length 8 Data \u0026lt;Len\u0026gt; byte array Data Example:\n//SDR private data reception from node [0x44,0x01,0x06], data \u0026ldquo;D4 0A\u0026rdquo;\n←66 44 00 00 00 01 06 02 D4 0A\nBLE Data Reception # The BLE Data Reception is an event where the Transceiver receives data from BLE connectable node via GATT notification/indication method. The specifics of this event encapsulate the event ID, BLE peripheral\u0026rsquo;s MAC Address, and the data length received, along with the actual data payload. An example is provided to elucidate the structured format of the received data.\nEvent:\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x67 Event Id for \"BLE Data Recepiton\" 1 BLE MAC Address 6 - MAC address of peer BLE peripheral 7 Handle 2 unsigned short Handle of GATT characteristic that notify or indicate 9 Len 1 0 - 255 Data length 10 Data \u0026lt;Len\u0026gt; byte array Data Example:\n//BLE notify data from 11:22:33:44:55:66, handle is 0x0010, data is \u0026ldquo;D4 0A\u0026rdquo;.\n←67 66 55 44 33 22 11 10 00 02 D4 0A\nError Code # The error codes serve as a standardized way of communicating issues or successes between a device or system and its user or another system. Recognizing and understanding these codes can assist in diagnosing problems, troubleshooting, and ensuring smoother operations.\nError Code Description 0 Command was executed correctly 0x1001 Command was executed with error 0x0111 Not Ready 0x100A Error Command ID 0x100B Error Busy 0x100D Error Parameter 0x100E Error Timeout Others BLE error "}]