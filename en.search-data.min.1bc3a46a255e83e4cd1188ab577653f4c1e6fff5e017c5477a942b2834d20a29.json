[{"id":0,"href":"/docs/in6xxe/tools/ota-app-develop-guide.html","title":"InPlay OTA App Development Guide","section":"Tools","content":" OTA App Development Guide # Overview # This document provides a comprehensive guide for implementing OTA (Over-The-Air) upgrades using an Android application. It details the OTA service structure, command protocols, error handling, and firmware file format required to upgrade the device software reliably.\nOTA Service # UUID:\nOTA Service: f95a48e6-a721-11e9-a2a3-022ae2dbcce4\nNote: All data bytes are in little-endian format.\nCharacteristics # Name Property Max Length UUID Description SW/HW Version Read 8 f95a4b66-a721-11e9-a2a3-022ae2dbcce4 Contains the software and hardware version info OTA CMD Write 524 f95a5034-a721-11e9-a2a3-022ae2dbcce4 Command structure for OTA operations OTA Error Notify 8 ec4cff6d-81fc-4e5b-91e0-8103885c9ae3 Notifies error codes during OTA SW/HW Version # SW Version (4 bytes) HW Version (4 bytes) This characteristic reports the current software and hardware versions from the device, which helps determine whether an update is needed.\nOTA CMD # Command Structure # Field Size (bytes) Description CMD 4 Command code Data 0–520 Variable-length data payload Result Notification:\nThe command execution result is sent via GATT Notify using the OTA Error characteristic.\nCommand List # Prepare Command (0x06) # Description: Prepares the device for OTA. This command must be issued before any other OTA commands. Format: CMD:0x06 (4 bytes) Configure Command (0x00) # Description: Configures OTA parameters such as firmware size and update flags.\nFormat:\nCMD:0x00 (4 bytes) Firmware Size (4 bytes) Flag (4 bytes) Parameters:\nFirmware Size: Total size of the upgrade file. Flag: Configuration flags (see table below). Flag Values:\nName Bit Description Reserve 0 Reserved (should be set to 0) HASH 1 Set to 1 to enable hash verification (only for IN6XX) Flash Verify 2 Set to 1 to enable flash verification Force Erase Flash 3 Set to 1 to force erase the flash CRC 4 Set to 1 to enable CRC checking (only for IN6XXE) Note: It is recommended to set the flag to 0x1A (CRC | HASH | Force Erase Flash).\nSignature Command (0x08) # Description: Sends the upgrade file’s signature. Format: CMD:0x08 (4 bytes) Signature (64 bytes) Note: If the device does not support signature checking, this command may return an OTA_ERR_INVALID_PARAM error, which can be safely ignored. Software Version Command (0x09) # Description: Sends the software version to the device. If an error is returned, cancel the OTA process. Format: CMD:0x09 (4 bytes) SW Version (4 bytes) Hardware Version Command (0x0A) # Description: Sends the hardware version to the device. If an error is returned, cancel the OTA process. Format: CMD:0x0A (4 bytes) HW Version (4 bytes) Write Command (0x01) # Description: Writes firmware data to the device’s flash memory. Format: CMD:0x01 (4 bytes) Address (4 bytes) Data (4–512 bytes) Parameters: Address: Flash offset address (starting at 0). Data: Data payload (must be 4-byte aligned). Note: If this command completes successfully, it will not send a GATT notify through the OTA error characteristic. A GATT notify is only sent in case of an error.\nDone Command (0x02) # Description: Finalizes the OTA process and write the configuration to flash memory.\nFormat:\nCMD:0x02 (4 bytes) optional Hash Value(32 bytes) Note: The 32-bytes hash value is optional and is only available when the Hash bit is set to 1 in the Configure Command. Compute the hash value using SHA-256 on the application data.\nCancel Command (0x03) # Description: Cancels the current OTA process and resets the device state. Format: CMD:0x03 (4 bytes) Note: After cancellation, issue a Prepare Command to restart the OTA process. Reset Command (0x04) # Description: Resets the device. Format: CMD:0x04 (4 bytes) Update Command (0x05) # Description: Updates BLE connection parameters. Format: CMD:0x05 (4 bytes) Interval Min (4 bytes) Interval Max (4 bytes) Latency (4 bytes) Timeout (4 bytes) Parameters: Interval Min: Minimum connection interval (N × 1.25ms). Interval Max: Maximum connection interval (N × 1.25ms). Latency: Number of connection events that can be skipped. Timeout: Supervision timeout (N × 10ms). Usage Notes: Set a long connection interval (e.g., \u0026gt;500ms) before sending the Configure Command. After configuration, reduce the connection interval (e.g., to 30ms) to accelerate the OTA data transfer. OTA Error # The OTA Error characteristic notifies the application of errors that occur during the OTA process.\nField Size (bytes) Description Command 1 OTA Command Error Code 1 Identifier for the error Reserved 2 Reserved data Data 4 Additional error data Error Codes # Error Code Description 0x00 No error 0x01 Wrong status (device is busy) 0x02 Invalid parameter 0x03 Flash write error 0x04 Flash erase error 0x05 Initialization error 0x06 Memory error 0x07 AES error 0x08 Hash error 0x09 Flash verification error 0x0A Signature error 0x0B Software version error 0x0C Hardware version error 0x0D Hardware error 0x0E CRC error 0x0F Timeout error 0x10 All devices timeout error Upgrade BIN File Format # The upgrade binary file is divided into up to three sections, as described in the table below:\nSection Size (bytes) Description OTA Header (Optional) 128 Contains metadata for the upgrade. This section is optional and its presence is determined by checking a magic word. Bootram (Optional) 16K Contains bootloader data. This section is optional and must be verified using a magic word. If present, it is discarded. Application 4 – 240K Contains the application data, which is transmitted to the device using the Write Command. Notes:\nOTA Header:\nIf the first 4 bytes match the expected magic word, the OTA header is considered present. Otherwise, default values (such as zeros) should be used for software version, hardware version, and signature.\nBootram:\nThis section, if present, includes additional bootloader code but should not be transmitted to the device. Always check the magic word to determine its validity.\nApplication:\nOnly the application data section is sent to the device during the OTA process via the Write Command.\nOTA Header (Optional, 128 bytes)\nField Size (bytes) Description Magicword 4 Should be 0xA9D8194E. If not, the OTA header is considered absent. SW Version 4 Software version (sent in the Software Version Command). HW Version 4 Hardware version (sent in the Hardware Version Command). Signature 64 Signature of the upgrade file (sent in the Signature Command). Reserve Data 52 Reserved for future use. Bootram (Optional, 16KB)\nThe Bootram section begins with a 4-byte magic word.\nField Size (bytes) Description Magicword 4 Should be 0xA72E0129 or 0x531b7635. If the magicword does not match, Bootram is absent. Data 16KB - 4 Bootram content. Do not send Bootram data to the device; discard this section if present. Application\nOnly the application data should be transmitted to the device using the Write Command.\nOTA Process Flowchart # Below is a flowchart illustrating the OTA upgrade process:\ngraph TD; A[Start] --\u0026gt; B[Cancel CMD]; B --\u0026gt; K[Prepare CMD]; K --\u0026gt; C[Update CMD with long interval]; C --\u0026gt; D[Configure CMD]; D --\u0026gt; E[Update CMD with short interval]; E --\u0026gt; L[SW Version CMD]; L --\u0026gt; M[HW Version CMD]; M --\u0026gt; N[Signature CMD]; N --\u0026gt; F[Write CMD]; F --\u0026gt; G{Write Complete?}; G --\u0026gt;|Yes| H[Done CMD]; H --\u0026gt; I[Reset CMD]; I --\u0026gt; J[End]; G --\u0026gt;|No| F; Best Pracitce # The first cancel command is used to cancel last OTA process. Use the following parameter of Update CMD with long interval. And add 5 seconds delay after update command. Interval min: 500 Interval max: 530 Latency: 0 Timeout：2000 Use OS API to set shorter connect interval.For example, use requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH) instead of update CMD with shot interval on Android system. If bin file is not 4 bytes aligned, pad zero at the end of the bin file. If get error, send cancel command. Suggeset to set flag to 0x1A(CRC|HASH|Force Erase). "},{"id":1,"href":"/docs/in6xxe/tools/ota-app.html","title":"InPlayOTA App Guide","section":"Tools","content":" InPlayOTA App Guide # Introduction # The InPlayOTA Android App is designed for Over-the-Air (OTA) firmware upgrades for the IN6XX and IN6XXE chips. This app allows users to easily update their devices\u0026rsquo; firmware, ensuring that they are running the latest features, improvements, and bug fixes. It provides a seamless process for upgrading the firmware without the need for physical connections, enhancing the convenience and efficiency of the update procedure.\nPreparation # Build the OTA demo project and download the bin file to the DK. Without Signature for Bin File: Copy the updated bin file to your phone, for example, to the \u0026ldquo;Download\u0026rdquo; folder. (Optional)With Signature for Bin File: Use the Python script ota_tool/ota_signature.py to generate the updated bin file with the signature. Then, copy the bin file to your phone. Initial App Run - Granting Permissions # When you run the InPlayOTA app for the first time, you will be prompted to grant permissions. Please follow these steps:\nTap \u0026ldquo;While using the app\u0026rdquo;.\nThen tap \u0026ldquo;Allow\u0026rdquo;.\nStep # Click the Scan button to search for available devices.\n(Optional)Click the Filter button to filter devices. Click it again to collapse the filter.\nFind the device (e.g., \u0026ldquo;InPlay-OTA\u0026rdquo;) and click the Connect button.\nIf the device status is not \u0026ldquo;CONNECTED,\u0026rdquo; click DISCONNECT and then click CONNECT again.\nSelect the bin file from your phone.\n(Optional) Click the Options button:\nHash: Enable hash checking (only available for IN6XX chip). CRC32: Enable CRC32 checking (only available for IN6XXE chip). AES Encrypt: Deprecated setting, do not check. Flash Verify: Verify flash data. This is not required if hash or CRC32 checking is enabled. Force Erase: Deprecated setting. Click the Start button to begin the OTA process.\nThe device will reset automatically once the OTA update is successful.\n"},{"id":2,"href":"/docs/in6xxe/user-guides/nanosync-technology/advanced-timer-guide.html","title":"NanoSync Timer Guide","section":"NanoSync Technology","content":" NanoSync Timer Guide # Introduction # The NanoSync timers(Advanced Timer) are capable of capturing the times of multiple real-time triggers or events simultaneously. The NanoSync timers can be also used as trigger sources for the NanoSync engine(Trigger Handler). If the current time of a NanoSync timer equals to the programmed target time (called emit time), a trigger (We also call the trigger from SyncTimer as an emit) happens. Each SyncTimer supports up to 10 emit time target. The emits also support direct control of a GPIO output without any latency.\nBasic Timer # The timer0 to timer9 are basic timers, which support timeout functionality and manual counting.\nNanoSync Timer(Advanced Timer) # Timer 0, timer 1 and timer 6 are advanced timer, supporting capture and emit functionalities.\nCapture # Advanced timers can capture signals, obtaining timestamps of the signals\u0026rsquo; rising or falling edges. These signals can be GPIO inputs or BLE TRX signals, refer to the Trigger (NanoSync Engine) document for signal details. Each timer can capture up to 4 signals simultaneously.\nEmit # Advanced timers can emit a signal when they reach the target timestamp. The trigger handler can use this emitted signal as input. Each advanced timer can emit up to 10 signals.\nOutput emit signal on GPIO # Using testmux, it\u0026rsquo;s possible to output emitted signals on GPIO. Each advanced timer can output up to 10 emit signals and 5 toggle emit signals. The emit signal is a pulse signal, and two emit signals combine to produce one toggle emit signal, controlling both its rising and falling edges.\nCapture and Emit with Shared memory # Advanced timers can use shared memory to capture and emit signals. With shared memory, it can capture one signal and emit one signal simultaneously. For instance, it can capture signal 0 and write its timestamp to shared memory, and emitting signal 0 with the timestamp stored in shared memory.\nAPI # See Timer API Document for details.\n"},{"id":3,"href":"/docs/in6xxe/api-documatation.html","title":"API Documentation","section":"IN6XXE","content":"Please click the following link:\nAPI document link\n"},{"id":4,"href":"/docs/in6xxe/examples-and-use-case/debug-reference.html","title":"Debug Reference","section":"Examples and Use Case","content":" Debug Reference # Configuration and Connection during Debug # To connect with the IN628E, we should use a terminal emulator with following setting,\nPort: according to your device.\nBaud Rate: 115200.\nData bits: 8.\nStop bits: 1.\nParity: None.\nFlow control: None.\nUART Tx Pin: default is GPIO_2_1.\nUART Rx Pin: default is GPIO_2_7.\n"},{"id":5,"href":"/docs/in6xx/getting-started/testing/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Testing and Debuging","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection.\nConfiguration # Install J-Link # Should install in-dev\\tools\\ InPlayToolsSetup.exe first, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, J-Link will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":6,"href":"/docs/in6xxe/getting-started/testing/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Testing and Debuging","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:\nTerminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\\tools\\ InPlayToolsSetup.exe, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, JLink will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":7,"href":"/docs/solutions/find-my/find-my-sdk-guide.html","title":"Find My Sdk Guide","section":"Find My","content":" InPlay Find My SDK Guide # Overview # The IN610 Find My SDK is compliant with the most recent versions of both Apple’s Find My Network Accessory Specification and Google’s Find My Device Network Accessory Specification. This guide provides detailed instructions for configuring, compiling, and installing the IN610 Find My SDK to implement an IN610-based Find My Network Accessory. A typical hardware block diagram for a Find My accessory is as below:\nThe accessory\u0026rsquo;s key components consist of the IN610 Bluetooth Low Energy (BLE) System-on-Chip (SoC), a key, a buzzer, and a motion sensor. The key acts as an input for one of the GPIOs on the IN610 BLE SoC, facilitating crucial user interactions such as restoring factory settings and turning the device on or off. The buzzer serves to emit sounds to aid in locating items, and when combined with the motion sensor, it can trigger an alarm to prevent unwanted tracking.\nThe SDK includes all essential hardware drivers and offers easy customization to meet your specific product needs.\nRequired tools # Before using the Find My SDK, users must install the necessary tools.\nCompiler and build tools # The SDK supports both Keil and GCC. Users can build their applications using either of tools.\nKeil # If Keil is used to build the project, below tools should be installed:\nTool URL or the path in the SDK Notes Keil MDK https://www.keil.com/download/product/ It is recommended to use version 5.29 or higher of the IDE for building the project. InPlayInc.DeviceFamilyPack.1.0.6.pack in-dev/tools Included in the SDK. Integrate IN610 support into Keil. GCC # Users can also build the project using GCC on either Windows or Linux. The required tools are ARM GCC and Make.\nARM GCC\nThe recommended ARM GCC toolchain is gcc-arm-none-eabi-9-2020-q2. It can be downloaded from the Downloads | 9-2020-q2-update – Arm Developer page. When installing the ARM GCC toolchain, ensure that the installation path does not contain special characters such as \u0026ldquo;(\u0026rdquo; or \u0026ldquo;)\u0026rdquo;.\nGNU make utility\nFor Windows, download the Make utility from Make for Windows and install it on your PC. If you\u0026rsquo;re using Ubuntu, install Make using the following commands:\nsudo apt-get update\rsudo apt-get install build-essential After installing Make on Windows or Ubuntu, ensure you add its path to the PATH environment variable.\nImage and token programming tools # Once users successfully build the project, they can download the application image to the IN610 using either the J-Link or UART interface. These are required tools:\nTool URL or path in the SDK Notes SEGGER J-Link https://www.segger.com/downloads/jlink/ Version 7.62 or higher is recommended. InPlayToolsSetup.exe in-dev/tools Included in the SDK. Add IN610 support for J-Flash The Windows application \u0026ldquo;inplay_programmer\u0026rdquo; included in the SDK (in-dev/tools/in_prog) can be used to download the application image by using UART.\nThe \u0026ldquo;in610_fmna_program\u0026rdquo; shown in below table is used to load the Apple token to IN610 either using J-Link or UART.\nTool URL or path in the SDK Notes Python 3.x https://www.python.org/downloads/ The In610_fmna_program utilizes a Python script to upload the Apple Find My token to the internal flash memory of the IN610. in610_fmna_program in-dev/proj/proj_ble_find_my/tools Included in the SDK. A toolset designed for loading the Apple Find My token to the internal flash memory of the IN610. Source code and software architecture # The source code for the Find My project is located in the in-dev/proj/proj_ble_find_my directory:\nbuild gcc: GCC build directory mdk: Keil MDK project file: proj_ble_lp.uvprojx inc: in_config.h is platform configuration file, fm_config.h is the Find My SDK configuration file. boards: Specific board configuration files lib: Apple and Google Find My libraries src app: Application layer, key operation definitions, storage, power on/off etc. bsp: Board Support Package, some necessary device drivers fmna: Apple Find My Network Accessory Specification related code nearby: Google Find My Device Network Accessory Specification related code utils tools in610_fmna_program: Tool to load Apple’s token to IN610 chip UARP: Apple’s UARP tools The architecture of the IN610 Find My software is illustrated as below:\nSoftware configuration # The configuration options for the IN610 Find My SDK are specified in the file \u0026ldquo;in-dev/proj/proj_ble_find_my/inc/fm_config.h\u0026rdquo;. This file includes a file named \u0026ldquo;fm_models.h\u0026rdquo;, which includes some hardware related macros. At the beginning of the file \u0026ldquo;fm_models.h\u0026rdquo;, a macro prefixed with \u0026ldquo;USE_\u0026rdquo; is defined to specify the target board. By default, the macro USE_DK is defined for InPlay\u0026rsquo;s IN610DK board:\n#define USE_DK //DK board, B0-07102021 If you want to adapt the SDK to a custom hardware platform, you need to define a new macro, such as USE_CUSTOMER_BOARD, and provide a corresponding platform configuration file, such as \u0026ldquo;in_config_customer.h\u0026rdquo;, in the boards directory.\nBSP configuration # The SDK\u0026rsquo;s Board Support Package (BSP) includes device drivers for key inputs, buzzer, and motion sensor functionalities. These drivers\u0026rsquo; source code can be found in the \u0026ldquo;bsp\u0026rdquo; directory.\nKey driver # The bsp_gpio_key.c file acts as the key driver, enabling features like single press, double press, and long press etc. To enable the GPIO key driver, set the macro USE_GPIO_KEY to 1 in the fm_config.h file. The key can be connected to any available GPIO pin, and the desired GPIO can be specified using the macro defined in fm_models.h:\n#define GPIO_KEY_PORT 0 // The GPIO port to which the key is connected.\r#define GPIO_KEY_PIN 0 // The pin of the GPIO port that connects to the key.\r#define GPIO_KEY_ACTIVE 1 // The active level of the GPIO key input. Note: The GPIO key input should always be active at a high level. In DK board, S3 is used as the GPIO Key, which is connected to GPIO_0_0.\nBuzzer driver # The bsp_buzzer.c file serves as the buzzer driver, utilizing PWM waveforms to drive a buzzer.\nBuzzers are classified into two types: magnetic buzzers and piezo buzzers. Magnetic buzzers produce sound by passing current through a coil, generating a magnetic field that moves a diaphragm to create sound waves. Piezo buzzers operate using the piezoelectric effect, where an alternating current causes a piezoelectric material to expand and contract, producing sound vibrations.\nTo generate a sound both magnetic buzzers and piezo buzzers require a PWM signal. The frequency of this PWM signal corresponds to the pitch of the note you want to play. Magnetic buzzers draw more current than piezo buzzers due to their fundamental design and operating principles. It is recommended to use piezo buzzers.\nThe IN610 features three GPIOs that support PWM:\nGPIO Port Number Pin Number PWM ID GPIO_0_2 0 2 PWM2_ID GPIO_1_7 1 7 PWM3_ID GPIO_1_8 1 8 PWM4_ID Users can select which GPIO to use for PWM by configuring the corresponding macro in fm_model.h:\n#define BUZZER_PWM_ID PWM2_ID //PWM id corresponding to the GPIO For magnetic buzzers, users can configure the active level of the PWM using the following macro. The active level defines the state in which the PWM signal enables a higher current to flow through the coil:\n#define BUZZER_ACTIVE_LEVEL 1 The buzzer driver allows users to customize sounds by defining buzzer sequences for various states of the Find My accessory device. Each entry in the sequence can specify how long the buzzer remains active, how long it stays inactive, and the PWM frequency during its active state. In the SDK, the following buzzer sequences are available and defined in \u0026ldquo;app_buzzer.c\u0026rdquo;:\nBuzzer sequence variable When to be used g_power_on_seq The Find My accessory is powered on g_power_off_seq The Find My accessory is powered off g_play_sound_seq Played when playing sound through App, or unwanted tracking with motion detected g_reset_seq Factory reset successfully g_unpair_seq Unpaired successfully g_paired_seq Paired successfully Examples of buzzer sequence definitions are available in the app_buzzer.c file. One such example is the power-on sequence, which users can configure to play sounds when the device is powered on:\nbuzzer_seq_t g_power_on_seq = {\r.evt = g_power_on_evts,\r.repeat_count = 1,\r.seq_len = 3,\r}; The g_power_on_seq buzzer sequence consists of three entries (defined by seq_len), each specifying its on duration (in 10 ms), off duration, and PWM frequency (in Hz). The repeat count is set to 1, meaning the entire sequence (comprising the three entries) will play once.\nUsers can call the bsp_buzzer_start_seq function to play a buzzer sequence, as shown in the following example:\nbsp_buzzer_start_seq(\u0026amp;g_power_on_seq). Motion sensor driver # The \u0026ldquo;bsp_acc.c\u0026rdquo; is the motion sensor driver. Currently, the SDK supports only the LIS2DH12 as the motion sensor. The driver allows users to specify the IN610 I2C interface in use, along with one GPIO pin that can receive interrupts from the motion sensor.\nThe bsp_acc.c file serves as the motion sensor driver. Currently, the SDK supports only the LIS2DH12 motion sensor. The driver allows users to configure the IN610 I2C interface and specify the GPIO pin for receiving interrupts from the motion sensor.\nThe IN610 offers two options for the I2C interface, as outlined in below table:\nI2C ID SCL\tSDA I2C0_ID GPIO_0_0 I2C1_ID GPIO_4_0 Users can select the desired interface by setting the I2C_BUS macro in fm_models.h as follows:\n#define I2C_BUS I2C0_ID // Select I2C0 for the interface The I2C address of the LIS2DH12 is determined by its SA0 pin state. If the SA0 pin is high (internally pulled-up by default), the address is 0x19. Configure this address using the I2C_ADDR macro:\n#define I2C_ADDR 0x19 // I2C address of the motion sensor chip The LIS2DH12 motion sensor generates interrupts via its INT1 and INT2 pins. The SDK uses the INT2 pin for the interrupt source for the IN610 device. When the sensor is stationary, the INT2 pin outputs a high signal. Upon detecting motion, the pin transitions to low. When returning to a stationary state, it remains low for a brief period before returning to high. Users can specify the GPIO pin on the IN610 device connected to the INT2 pin using the INT2_PORT and INT2_PIN macros in fm_models.h, as shown below:\n#define INT2_PORT 2 //The port of the 2nd GPIO which can receiver interrupt from the motion sensor.\r#define INT2_PIN 8 // The pin of the 2nd GPIO which can receiver interrupt from the motion sensor. Battery driver # The “bsp_battery.c” file functions as the battery driver for monitoring the battery voltage of the Find My accessory device. If the battery directly supplies power to the IN610, the internal ADC channel (ADC_CH14) can be used to measure the supply voltage directly. If the battery does not directly supply power to the IN610, external ADC channels of the IN610 (ADC_CH0 is recommended) must be utilized to measure the battery level. It is important to note that for external ADC channels, the input signal range must remain within [0, 2.0V]. Users are advised to implement a suitable voltage divider to ensure that the input signal range is between [50 mV, 1950 mV] for optimal linearity.\nThe driver enables users to define battery levels as \u0026ldquo;Full,\u0026rdquo; \u0026ldquo;Medium,\u0026rdquo; \u0026ldquo;Low,\u0026rdquo; and \u0026ldquo;Critical Low\u0026rdquo; based on the measured battery voltage (in millivolts, mV). These levels can be customized by modifying an array in the bsp_battery.c file, which maps specific voltage ranges to corresponding battery levels.\nFor rechargeable batteries, two threshold sets must be configured:\ng_vbat_thr in the bsp_battery.c file for batteries not in a charging state. g_vbat_chrg_thr for batteries in a charging state. For non-rechargeable batteries, thresholds can be defined using g_vbat_thr.\nThe SDK provides example thresholds for reference. For a non-rechargeable battery, the provided examples indicate the following:\nA voltage of 2810 mV or higher corresponds to \u0026ldquo;Full.\u0026rdquo; A voltage between 2650 mV and 2810 mV corresponds to \u0026ldquo;Medium.\u0026rdquo; A voltage between 2513 mV and 2650 mV corresponds to \u0026ldquo;Low.\u0026rdquo; A voltage below 2513 mV corresponds to \u0026ldquo;Critical Low.\u0026rdquo; Users can adjust the values to align with the specific characteristics of their battery.\nThe following macros can be defined in fm_models.h for configuring the battery driver:\n#define USE_CHARGER // Define this macro if a rechargeable battery is used\r#define BATT_TYPE 2 // Indicates a rechargeable battery; this value is used to initialize Find My libraries\r#define BAT_VOL_ADC_CH ADC_CH0 // Specifies the ADC channel used to sample battery voltage\r#define BAT_VOLTAGE_DIV ((1.2+1.5)/1.2) // Battery voltage divider configuration\r#define BAT_STABLE_DELAY (200000) // Delay (in microseconds) for battery voltage stabilization after reset; set to 0 for ADC_CH0. For mixed-signal pins, additional delay may be needed due to pull-up resistors. If a GPIO pin is connected to the charger for detecting the charging state, it can be defined as follows:\n#define GPIO_CHARG_DET 2,5 Note: If GPIO_CHARG_DET is not defined, the software cannot detect the charging state. Consequently, the g_vbat_chrg_thr parameter will not be used.\nTo ensure the tracker powers off automatically when the battery is low, define the following macro in bsp_battery.h to set the power-off voltage for the rechargeable battery:\n#define BAT_POWER_OFF_VOL 3300 // Power off battery voltage in millivolts (mV) If a load switch is used to control the battery voltage sampling, you can define the GPIO pin to manage the load switch as follows:\n#define GPIO_BAT_ADC_EN 1, 8 // Define GPIO to enable load switch\r#define ADC_EN_ACTIVE 1 // Define active level of the GPIO Boot Pin # The boot pin is utilized to signal the boot ROM of the IN610 that a firmware image or data (like Apple token) needs to be downloaded to the flash memory. In the SDK, the default boot pin is GPIO_1_6. If the boot pin is low during the transition of the chip from disabled to enabled (when the CHIP_EN pin goes from low to high), the chip will remain in the boot ROM, awaiting commands from any UART interface to initiate the firmware download. Users can also connect a J-Link to the IN610 in this state.\nSDK configuration # Several SDK configuration macros are defined in the fm_config.h file, as detailed in the following sub-sections.\nDebug option # The Keil project includes two targets: tracker (release version) and tracker_d (debug version). The differences between these targets are outlined in below table:\nTarget Linked libraries FMND_DEBUG defined? Description tracker fmna_lib.lib, nearby_lib.lib No Debug messages will not be output via UART. The \u0026ldquo;Debug Control Point\u0026rdquo; outlined in the \u0026ldquo;Find My Network Accessory Specification\u0026rdquo; is not activated. Less flash memory is needed. tracker_d fmna_lib_d.lib, nearby_lib_d.lib Yes Debug messages will be output via UART. The \u0026ldquo;Debug Control Point\u0026rdquo; outlined in the \u0026ldquo;Find My Network Accessory Specification\u0026rdquo; is activated. More flash memory is needed. Note:\nThe default debug UART interface is UART1 in the IN610 device, GPIO_2_1 as TXD and GPIO_2_7 as RXD. And the baud rate is 921600. If non-debug version libraries (libraries without \u0026ldquo;_d\u0026rdquo; suffix) are used, RAM log are not supported. Supported protocol # The SDK supports both the Apple Find My and Google Find My Device protocols. The tracker can be configured to support either one or both.\nIf the tracker is configured for one protocol, it can only join the corresponding predefined network. If configured for both, the end user can choose whether the tracker joins the Apple or Google network during a factory reset or the first-time power-on. To support the Apple Find My protocol, define the following macro in fm_config.h:\n#define USE_APPLE_TRACKER To support the Google Find My Device protocol, define the following macro:\n#define USE_GOOGLE_TRACKER Watchdog # Set the following macro to enable the IN610’s AON Watchdog. It is recommended to keep this enabled. To disable the WDT, set the macro to 0:\n#define USE_WDT 1 RAM log # Set the following macro to \u0026ldquo;1\u0026rdquo; to enable log printing to RAM. You can dump the logs using the InPlayOTA application. This option should be disabled for release versions:\n#define USE_RAM_LOG 1 DFT (Design for Test) BLE service # DFT service is a BLE service used to write SN, token or dump log. If users don’t need these features, users should set these options to “0”.\n#define USE_DFT_SVC 1 // If set to \u0026#34;1\u0026#34;, a BLE service will be included for testing purposes. For details, refer to app_dft.c.\r#define USE_DFT_ADV 0 // If set to \u0026#34;1\u0026#34;, an additional BLE advertisement for testing purposes will be enabled for 1 minute when entering pairing state. Google FMDN and Apple FMNA configuration # The configuration options for Google FMDN can be set using the nearby_cfg_t structure when calling nearby_init to initialize the Nearby library. Refer to nearby_user.h for the structure definition.\nSimilarly, the configuration options for Apple FMNA can be set using the fmna_cfg_t structure when calling fmna_init to initialize the FMNA library. Refer to fmna_user.h for the structure definition.\nIn app_power_state.c, the initialization is implemented as follows:\nGoogle FMDN is initialized with: nearby_init(\u0026amp;nearby_cfg, reset_reason, \u0026amp;g_app_cfg.fmdn_data); Apple Find My Network is initialized with: fmna_init(\u0026amp;fmna_cfg, \u0026amp;nv_data); The configuration options are defined as global variables (fmna_cfg and nearby_cfg). Certain members of these structures are initialized using macros.\nModel setup configuration # For the Google tracker, it is essential to correctly configure the model ID and anti-spoof private key; For the Apple tracker, the product data should be set correctly. They are defined as macros in \u0026ldquo;in-dev/proj/proj_ble_find_my/inc/fm_private.h\u0026rdquo;.\nNote: By default, these essential macros are set to invalid values. If they are not modified, the tracker will not work.\nMODEL_ID: Model ID distributed by Google ANTI_SPOOF_PRIV_KEY: Anti-Spoofing Private Key distributed by Google Refer to Fast Pair|Google for Developers to know how to register a model with Google.\nThe Anti-Spoofing Private Key distributed by Google is BASE64 encoded, it should be converted to hexadecimal format, some online tools can be used to do this:\nhttps://base64.guru/converter/decode/hex\nFor example, if the Base64-encoded private key string is: \u0026ldquo;AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyA=\u0026rdquo;\nConvert it to hexadecimal:\n\u0026ldquo;0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20\u0026rdquo;\nThen, define the private key in fm_private.h as follows:\n#define ANTI_SPOOF_PRIV_KEY \\\r0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \\\r0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, \\\r0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, \\\r0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, For the Apple tracker, the product data must be set accurately which is also defined in \u0026ldquo;fm_private.h\u0026rdquo; as FMNA_PRODUCT_DATA.\nCertain common options must be configured for both Apple and Google, including firmware version number, manufacturer name, model name, capability, category, and battery type. Definitions for some macros related to capability, category, and battery type can be found in \u0026ldquo;fm_constants.h\u0026rdquo;.\nRF related configuration # Certain RF-related configurations must be adjusted to align with the hardware setup. For the IN610 chip, the gain code parameter is used to configure the RF Tx power. Typically, the following values are used:\ngain_code = 0x18: Tx power set to 0 dBm gain_code = 0x78: Tx power set to 4 dBm However, these values may vary depending on hardware specifics, such as the RF matching network.\nIn the IN610 SDK, the Tx power for each advertisement can be configured independently. During a connection, the Tx power used matches that of the corresponding advertisement.\nFor Apple Find My, the Tx power must be set to higher than 4 dBm. The relevant settings are members of the fmna_cfg_t structure:\ntx_pwr: Represents the Tx Power Level characteristic of the Tx Power Service for FMNA and should reflect the Bluetooth LE TRP (Total Radiated Power). tx_gain_code: Configures the Tx power setting of the chip for FMNA advertisements. For Google Find My, two types of advertisements are used: Fast Pair and FMDN. Fast Pair advertisements are active during pairing and FMDN advertisements are used after pairing.\nThe configurations are members of the nearby_cfg_t structure:\nfp_calibrated_adv_tx_pwr: The calibrated Fast Pair Tx power at 0m distance, measured in dBm. Refer to Fast Pair Materials and Technical Notes | Google for Developers on the Google Developers site. fp_tx_gain_code: Configures the Tx power setting for Fast Pair advertisements and must be lower than fmdn_tx_gain_code. fmdn_tx_gain_code: Configures the Tx power setting for FMDN advertisements. Apple Find My Serial Number interface # The serial number for Apple Find My is retrieved by the Apple Find My library using the function fmna_plat_get_serial_number in the file fmna_platform.c. By default, the serial number is generated from the chip UUID. However, if USE_NV_SN is set to \u0026ldquo;1\u0026rdquo;, the serial number can be read from flash memory instead.\nFunction interface # Functions declared in “fmna_platform.h” and “fmna_platform_uarp.h” are called by fmna lib. Functions defined in “nearby_platform_os.c” are called by nearby lib. Functions declared in “fmna_user.h” and “nearby_user.h” are APIs called by user application, which are implemented in fmna lib and nearby lib.\nFlash layout # The flash address 0x0 is mapped to 0x00300000 in the CPU addressing space. Below table provides detailed information about the flash layout.\n512KB Flash: # Address range Description 0x0 ~ 0x4000 Boot options and Boot RAM 0x4000~0x40000 Application bank A 0x40000~0x7B000 Application bank B 0x7B000~0x7E000 Pair information and keys 0x7E000~0x7F000 Apple software authentication token 0x7F000~0x80000 Reserved, can be used to store SN, etc. 1MB Flash: # Address range Description 0x0 ~ 0x4000 Boot options and Boot RAM 0x4000~0x80000 Application bank A 0x80000~0xFB000 Application bank B 0xFB000~0xFE000 Pair information and keys 0xFE000~0xFF000 Apple software authentication token 0xFF000~0x100000 Reserved, can be used to store SN, etc. Note: The SDK supports firmware upgrades using A/B banks. At any given time, the application program is stored in either Application Bank A or Application Bank B. Keil can only program firmware to Bank A. If the firmware is upgraded to Bank B, the sector at address 0x3000 must be erased before running a program loaded with Keil.\nUI customization # A Find My Accessory typically supports several operations, including enabling or disabling the Find My Network, performing a factory reset, and reading the serial number. This section offers guidance on how to customize these operations within the SDK.\nFind My Network disable/enable # The enable/disable function for Find My Network has been implemented as a power on/off feature in the SDK. When in power off state, the chip will enter deep sleep mode, which is a state where the system consumes minimal power. The user interface for power on/off is defined in app_key.c. To trigger power on/off operations, call the function app_power_set_state.\nNote: By default, a long press of the button for 3 seconds will initiate the power-on operation. To trigger the power-off operation, quickly press the button three times, then long press it for 5 seconds immediately afterward.\nFactory Reset # In app_key.c, you can initiate a factory reset by calling the function do_factory_reset.\nNote: By default, quickly press the button 5 times will trigger factory reset.\nRead Serial Number # In app_key.c, you can enable reading the serial number by calling the function enable_serial_read.\nNote: By default, a double press of the button activates the serial number read mode.\nMultiple BLE applications coexist # When multiple BLE applications are running simultaneously, they typically exhibit the following characteristics:\nEach application has its own type of advertising packets. Each application performs different actions during connection and disconnection. Each application defines its own unique GATT services. Multiple BLE applications can run simultaneously with the SDK, this is achieved through the following steps:\nWhen establishing a connection, map the connection index to the corresponding BLE application based on the type of advertising packet associated with the connection. Subsequently, in the callback function for the same connection index, invoke the callback function of the corresponding BLE application for processing. This feature is implemented in \u0026ldquo;app_ble.c\u0026rdquo;, user can register a BLE application with \u0026ldquo;app_ble_register\u0026rdquo; function. Each BLE application is defined with a \u0026ldquo;app_ble_t\u0026rdquo; type structure which is composed by a few BLE callback functions. BLE callback functions not implemented for the application should be filled with “NULL”. The \u0026ldquo;check_adv_actv\u0026rdquo; callback function is used to check if an activity index is related to the application, it should return 1 if this is true.\nBuild the project and load the program to the flash # Build the project with Keil # The Keil project file is “in-dev/proj/proj_ble_find_my/build/mdk/proj_ble_lp.uvprojx”, open it with Keil and then select the appropriate target (refer to Debug option). If the build is successful, a file named \u0026ldquo;ble_find_my.bin\u0026rdquo; will be generated in the \u0026ldquo;in-dev/proj/proj_ble_find_my/build/mdk\u0026rdquo; directory. That file is the firmware image users need to load it to the IN610\u0026rsquo;s flash.\nBuild the project with GCC # Follow below steps to build the project.\nUnzip InPlay SDK to any directory. If you\u0026rsquo;re using Ubuntu, open the file in-dev/proj/common/gcc/linux.mk and set the GNU_INSTALL_ROOT to the path of your ARM GCC installation. For Windows users, modify the in-dev/proj/common/gcc/windows.mk file instead. Note that in windows.mk, you should use forward slashes \u0026ldquo;/\u0026rdquo; as the path separator, rather than backslashes \u0026ldquo;\\\u0026rdquo;. For Ubuntu users, navigate to the “in-dev/proj/proj_ble_find_my/build/gcc directory and execute the following command in your terminal: make -j4 This will build a release version by default (No logs will output). If you want to build a debug version, run below command:\nmake -j4 EN_DEBUG=1 Run below command to clean the project, then you can rebuild the project:\nmake clean If the build is successful, a file named \u0026ldquo;ble_find_my.bin\u0026rdquo; will be generated in the \u0026ldquo;in-dev/proj/proj_ble_find_my/build/gcc\u0026rdquo; directory. That file is the firmware image users need to load it to the IN610\u0026rsquo;s flash.\nNote: If you build the project on Windows, PowerShell or Command Prompt are not supported. It is recommended to install Git for Windows and execute the \u0026ldquo;make\u0026rdquo; command in \u0026ldquo;Git Bash\u0026rdquo; shell.\nLoad the image to IN610L flash # The boot pin signals the boot ROM of the IN610 to initiate firmware image download to the flash memory. If the device is already programmed, its state may be uncertain (e.g., it could be in deep sleep or active mode). In such cases, the boot pin assists in preparing the device for image loading. Follow these steps to load an image to the flash:\nConnect the boot pin to ground (not required if the device has never been programmed). Perform a power cycle on the device or toggle the CHIP_EN pin from low to high. Use the preferred tool to load the image to the device’s flash memory. Load the image with J-Link # Flash Programming with Keil\nKeil supports flash programming via J-Link. For configuration details on the programming utility in Keil for IN610L, refer to Quick Start | InPlay Doc. After building the project, users can use Keil to load the image into the device\u0026rsquo;s flash memory.\nFlash Programming without Keil\nIf Keil is unavailable, users can load the firmware binary (e.g., ble_find_my.bin) using J-Link. Refer to IN610 J-Flash Download Guide.\nLoad the image with UART # If J-Link is unavailable, users can load the firmware binary (e.g., ble_find_my.bin) using \u0026ldquo;InPlay Programmer\u0026rdquo; tool through UART. Refer to InPlay Programmer Guide.\nRun the program # The default debug UART port is UART1, using GPIO_2_1 for Tx and GPIO_2_7 for Rx, with a baud rate of 921600. If the program is a debug version and executes successfully, logs will be output through the UART port.\nLoad Software Authentication Token / UUID # Every Apple Find My accessory must have a unique token issued by Apple Inc. This token will be utilized once during the pairing of the accessory, and a new token will be provided during the pairing process, which should then be stored in non-volatile memory. This section explains the process of loading software authentication tokens on Windows.\nToken item format # A token item in excel file is as: A token item has an UUID and a base64-encoded token value.\nRun the script # In610_fmna_program.py is the python script to load the token. It can support both J-Link and UART.\nLoad token with J-Link # Before running the script, follow JFlash Programming | InPlay Doc to make sure you can program IN610 flash with J-Link. You should also add the directory path that contains \u0026ldquo;J-Link.exe\u0026rdquo; to the PATH environment variable. You can refer Add to the PATH on Windows 10 and Windows 11 | Architect Ryan to know how to do this.\nTo load the token, connect J-Link to IN610 chip and run the script as below:\n512KB flash python ./in610_fmna_program.py --mfi-token [token-UUID] [token-base64] 1MB flash python ./in610_fmna_program.py --mfi-token [token-UUID] [token-base64] --flash 1 where token-UUID represents the UUID of the token and token-base64 is the base64-encoded token value.\nThis is an example:\n512KB flash python ./in610_fmna_program.py --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ 1MB flash python ./in610_fmna_program.py --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ --flash 1 Load token with UART # Before running the script, check section Load the image to IN610L flash to ensure the chip is in Boot ROM mode and ready to download an image via UART. To load the token, connect your PC to any UART port on the IN610 chip. Then, include the \u0026ldquo;\u0026ndash;com\u0026rdquo; parameter to specify the COM port number used for the connection. This is an example:\npython ./in610_fmna_program.py --com 89 --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ Generate UARP file # UARP is Apple’s Unified Accessory Restore Protocol. IN610 Find My SDK support firmware update compliant with UARP. Related files for this section are in proj_ble_find_my/tools/UARP directory.\nGenerate the input bin to \u0026ldquo;mfigr2\u0026rdquo; tool # Note: Below steps can be done in Windows or MacOS\nThe .uarp file is an upgrade package for UARP. To generate .uarp file, preprocessing is required on the bin file that is generated from compilation:\nCopy the generated binary file (ble_find_my.bin) to the same directory as script \u0026ldquo;generate_bin.py\u0026rdquo;, and rename it to \u0026ldquo;input.bin\u0026rdquo;, then double click on the \u0026ldquo;generate_bin.py\u0026rdquo;, a file named \u0026ldquo;output_hashed.bin\u0026rdquo; will be generated, and it will be used as input file in following steps. Copy output_hashed.bin to the same directory as MyUARPSuperBinary.plist and rename it as you like. Then fill version number and the input binary file name (renamed output_hashed.bin) in \u0026ldquo;MyUARPSuperBinary.plist\u0026rdquo;.\nUse \u0026ldquo;mfigr2\u0026rdquo; to generate .uarp file # Note: below steps can only be done in MacOS\nRun mfigr2 in shell to generate the UARP file (mfigr2 can only be executed in MacOS):\n./mfigr2 superbinary compose metaDataFilepath=UARPMFIMetaDataTable2.plist plistFilepath=MyUARPSuperBinary.plist payloadsFilepath=. superBinaryFilepath=MyUARPSuperBinary.uarp If the command executes successfully, a file named \u0026ldquo;MyUARPSuperBinary.uarp\u0026rdquo; will be generated, this is the final .uarp file, you can rename it as you like.\nUpgrade the Find My Accessory # Install the FMCA Application # Find My Certification Assistant requires a device running iOS or iPadOS 14.5 or later. Use your iPhone to open link Find My Certification Asst. on the App Store on the App Store. Clicking on the link will open the App Store application, where you can proceed to install the app.\nInstall Find My Network Configuration Profile # Testing accessory firmware updates requires the installation of the Find My Network Configuration Profile. Extract the contents of the file \u0026ldquo;FMCA Configuration Profile Jan 2024.zip\u0026rdquo; to obtain a file named \u0026ldquo;Find_My_Certification_Configuration.mobileconfig\u0026rdquo;. Transfer this file to your iPhone using AirDrop (it is recommended to use AirDrop). Next, navigate to the \u0026ldquo;Settings\u0026rdquo; app on your iPhone, where you will find the \u0026ldquo;Profile Downloaded\u0026rdquo; button.\nClick on the button and continue with the profile installation:\nAfter restarting your iPhone, you can verify its installation by checking in \u0026ldquo;Settings\u0026rdquo; -\u0026gt; \u0026ldquo;General\u0026rdquo; -\u0026gt; \u0026ldquo;VPN \u0026amp; Device Management\u0026rdquo;.\nUpdate the firmware # A UARP firmware file is denoted as \u0026ldquo;xxxx.uarp.\u0026rdquo; Begin by transferring the file to your iPhone. Prior to conducting the update, pair the Find My Accessory with your iPhone. Next, open the \u0026ldquo;FMCA\u0026rdquo; app, sign in using your Apple ID (which should be your company account), and locate your device under \u0026ldquo;My Items\u0026rdquo;. Select your device, then tap the \u0026ldquo;Firmware Settings\u0026rdquo; button. Choose the option to \u0026ldquo;Select a File\u0026hellip;\u0026rdquo; and pick the .uarp file. Ensure you do not leave the page, and proceed to open the \u0026ldquo;Find My\u0026rdquo; app. Select the device you wish to upgrade; if the .uarp file is recognized correctly, the \u0026ldquo;Update Available\u0026rdquo; button will be displayed as shown below. Then tap the button to start upgrading. If you can’t see “Update Available” button, try to restart your iPhone and repeat the above steps.\n"},{"id":8,"href":"/docs/solutions/modbus/wireless-modbus-demo-guide.html","title":"Wireless Modbus Demo Guide","section":"Wireless Modbus Network","content":" Wireless Modbus Demo Guide # Demo Connections # This guide demonstrates connecting the Wireless Modbus Module, featuring a port with four pins: Vin, GND, A, and B.\nLikewise, the Sensor and Relay devices offer one or more similar ports, each with pins designated as A, B, GND, and VCC. The \u0026lsquo;A\u0026rsquo; and \u0026lsquo;B\u0026rsquo; pins facilitate RS485 connections, while VCC and GND pins cater to power connections, requiring a power supply voltage of 5V or greater.\nConnection Guidelines # Ensure the correct pins are connected as advised below:\nA to A B to B V to V (either Vcc or Vin) G to G (represents GND) Configuration # It is crucial that the RS485 baud rate be set correctly. For example, the sensors support only 4800 bps. The relay RS485, however, is compatible with 4800, 9600, and 91200 bps. Hence, we suggest configuring both the Wireless Module and the relay to 4800 bps for peak performance.\nDemo GUI Guide # Modbus RTU Serial Client GUI version: 0.8\nThe Demo GUI\u0026rsquo;s main window features three dock windows—Indicator, Sensor, Command—a toolbar with various control buttons, and a status bar at the bottom displaying serial connection states and settings.\nThe Toolbar has changed in version: 0.9\nOperations # Steps:\nConfirm Serial settings Ascertain Modbus request and response patterns of relay and sensor Connect COM port Scan devices Control devices Serial Configuration # Navigate to Setting/com to open a dialog window and modify serial settings parameters such as baud rate, data bits, stop bits, parity, and timeout. Click \u0026ldquo;confirm\u0026rdquo; to apply these settings.\nRelay Configuration # Access Setting/relay to open a dialog window and adjust the relay settings:\nSearch\nCount: Number of \u0026ldquo;relay\u0026rdquo; devices found. This parameter may be omitted. Maximum: The number of devices required. The search halts when the count meets this figure. Read Pattern: Triggers a search for relay devices upon clicking the toolbar\u0026rsquo;s Relay Search button. For instance, xx, 01, 0000, 0008 represents a Read Coils request in Modbus RTU format without crc16. Control\nWrite Pattern: Functions akin to Read Pattern; employs Function 05 (05hex) Write Single Coil. Response Pattern: Reactions following the requests. Sensor Configuration # Select Setting/sensor to amend sensor configurations:\nMonitor\nStart ID: Commencing address ID of the sensor device when monitoring is active. End ID: Terminal address ID of the sensor device when monitoring is active. Read Pattern: Command request for procuring sensor data, using function code 03. Value Upon receiving the slave\u0026rsquo;s response, the GUI parses the data list and employs formulas to calculate values.\nConnect and Run # Choose the appropriate COM Port and hit the Connect button in the toolbar. The status bar will exhibit the connection state.\nVersion 0.9 as below:\nVersion 0.8 as below:\nPressing the Network Scan Discovery (which is Start All in v0.8) button ignites the Relay Search and Sensor Monitor, proceeding as per the Settings to dispatch requests. The Command dock window relays messages of both requests and responses.\nShould relay or sensor devices be located, the Indicator and Sensor dock windows will relay pertinent information such as \u0026ldquo;lamp buttons,\u0026rdquo; alongside temperature and humidity graphs.\nVersion 0.8 as below: Indicator and Sensor sections incorporate selectors and buttons for demonstrating various actions.\nAnd in version 0.9 update the sensor\u0026rsquo;s dock window:\nSet \u0026ldquo;Temp upper\u0026rdquo; and \u0026ldquo;Temp lower\u0026rdquo; to adjust the temperature display limits on the graph.\nManual Command Input # Located at the Command dock window\u0026rsquo;s base, a manual command input area exists for entry of Modbus RTU requests (sans crc). Click Send Request post-entry to dispatch the command.\nStatus in Command # The Command dock window\u0026rsquo;s Status presents a tally of the requests and responses.\nAn input field is provided to insert metrics for computing the packet loss rate. When left blank or set to zero, all data is considered in the statistic.\nMenu # Additional operations within the menu are outlined here. Clicking File/Restore Setting regenerates a default setting.json file, which is then loaded by the Setting menu option.\nEditing the setting.json file can be accomplished with an external editor, replacing the same-name file in the GUI program\u0026rsquo;s directory.\nThe View menu permits modification of the GUI\u0026rsquo;s visual appeal, such as font selection, and toggles the display status of Dock Windows.\nIn version 0.9, View menu permit toggles the display of \u0026ldquo;other tools\u0026rdquo; in toolbar.\nThe Help menu grants access to assorted explanatory documents, including a GUI usage guide.\n"},{"id":9,"href":"/docs/solutions/modbus/wireless-modbus-module.html","title":"Wireless Modbus Module","section":"Wireless Modbus Network","content":" Introduction to the Wireless Modbus Module # Overview of the Modbus Protocol # Modbus is an application-layer messaging protocol, designed in 1979 by Modicon, which facilitates master/slave interaction between devices. A de facto communication standard in industrial electronics, it has the following features:\nMaster-Slave Architecture: One master device issues commands to one or more slave devices that respond in kind. Data Representation: Modbus categorizes data as either coils (binary) or registers (numeric), offering diverse data manipulation capabilities. Variants: Modbus has adapted to different environments with variants like Modbus RTU, Modbus ASCII, and Modbus TCP/IP. The RS485 Communication Standard # RS485, or EIA-485, prescribes electrical specifications for drivers and receivers in digital multipoint systems. It is characterized by:\nExtended Communication Range: Capable of transmitting data up to 4000 feet (~1200 meters). Noise Resistance: Differential signaling provides robustness against voltage fluctuations and electromagnetic interference. Multi-Drop Configurations: Supports up to 32 devices on a single bus network. RS485\u0026rsquo;s reliability is a cornerstone of industrial controls in leveraging Modbus protocol.\nConnection # RS485 Connection # A standard RS485 wiring diagram depicting a \u0026ldquo;daisy-chain\u0026rdquo; topology is shown:\nConnection of the Wireless Modbus # Replacement of wired RS485 connections with a wireless module:\nFeatures of the Wireless Modbus Module # Firmware version 0.2\nThe module supports baud rates [in bps]: 1200 to 1000000, including automatic master node baud rate detection and synchronization.\nCommunication Between Master and Slave # The interaction comprises the master\u0026rsquo;s request, the slave\u0026rsquo;s response, and the corresponding response times as shown:\nExample timing for a 69-byte request and 8-byte response Modbus RTU query. Response timing across UART and wireless PHY settings:\nUART Settings Net PHY Speed Response Time [ms] 4800-8-1-E 1M 222 9600-8-1-E 1M 127 14400-8-1-E 1M 94 19200-8-1-E 1M 76 115200-8-1-E 2M 28 500000-8-1-E 2M 17 Configurations and User Interface # Configuration channels include ATCMD, UART-based commands, physical interfacing (buttons/switches), and upcoming BLE.\nLED Indicators # Two LEDs (Blue and Red) denote operational states. Patterns of their light signify network status and the network node mode. It varies as follows - fast flash, slow flash, and constant on. For example:\nState LED Activity LED Interval Network Loss Fast flash: 100ms on/off 500ms off Network Sync Continuous: 3sec on 500ms off Network Wait Slow flash(500ms on/off) 500ms off Dip Switch Configuration # Settings like SW1 and SW2 determine network status and node mode, respectively.\nSetting RS485 parity with SW3 and SW4.\nSwitch Function Description SW1 Network start/config On: Activate; Off: Default. See below. SW2 Node mode On: Master; Off: Slave. SW3 RS485 parity enable On: Enable parity; Off: Disable parity SW4 RS485 parity mode On: ODD Parity; Off: EVEN parity SW1 Configuration Details\nON to OFF: Trigger reconfiguration; a fast flash indicates readiness to reconfigure. AT Commands # Each command starts with AT and ends with a terminator. The command and response bodies vary by read parameter or result code.\nNormal AT Commands # Command Response Description AT+MODE=?, +MODE=[m,1,0] Read the device Mode. m: 1, master; 0, slave. AT+STATE=?, +STATE=[x,p,ch] Read net state. x:1, sync; 0, loss. p: phy. ch：channels AT+UART=? +UART=[baud,data,stop,parity,th] Read RS485 UART setting. baud:baudrate; data:data bits(8); stop: stop bits(0: 1bit, 1: 2bits), parity:(0:disable, 1: odd, 2: even); th: internal threshold. AT+PKTL=?, +PKTL=[up,dn] Read data packege size. up: uplink size; dn: downlink size AT+PKTL=[up,dn], Result code Write data packege size. up: uplink size; dn: downlink size AT+LOG=x Result code Write Log enable level x: bit[0:2]. 3 levels AT+ADDR=? +ADDR=[xxyyxxyy] Read net address. xxyyxxyy: address AT+ADDR=[xxyyxxyy] Result code Write net address. xxyyxxyy: address. sendAT+SYSCMD=3save config and sendAT+SYSCMD=1 to apply AT+VER=? +VER=[xxH] Read firmware version AT+NET=? +NET=[p,t,d,u] Read net information. p:phy, t: type, d:downlink length; u:uplink length AT+SYSCMD=x Result code Send system command. x: 1, reset; 2, restore; 3, save config. Responses follow the \u0026lt;CR\u0026gt;\u0026lt;LF\u0026gt; structure.\nResult Codes # Result codes for command outcomes:\n0 for success, 0x1001 for\tCommand execution error 0x100A for\tBad command 0x100B for\tBad format 0x100D for\tBad parameter 0x100E for\tOvertime Others for\tProtocol stack error Advanced Commands # There are also advanced commands for specialized tasks.\nFor detailed information, consult the Engineer\u0026rsquo;s Manual.\n"},{"id":10,"href":"/docs/in6xxe/user-guides/driver-integration/adc-guide.html","title":"ADC Guide","section":"Driver Integration","content":" ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.\nKey Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.\nMode # There are two modes for the ADC:\nForce Mode In Force Mode, the ADC samples a single channel once and returns the result.\nAuto Mode Auto Mode allows the ADC to continuously sample multiple channels. It is capable of sequential sampling across several channels. The results will be put into shared memory through DMA.\nChannels # The ADC supports measurement from 15 channels, including:\n12 input channels (analog/digtal mixed pins) 1 analog input channel (ADC_CH_IN) 1 VBAT (Voltage Battery) channel 1 temperature sensor channel enum adc_ch{ ADC_CH0 = 0, ///\u0026lt;ADC_CH_IN ADC_CH1, ///\u0026lt;GPIO_2_9 ADC_CH2, ///\u0026lt;GPIO_2_8 ADC_CH3, ///\u0026lt;GPIO_2_7 ADC_CH4, ///\u0026lt;GPIO_2_6 ADC_CH5, ///\u0026lt;GPIO_2_5 ADC_CH6, ///\u0026lt;GPIO_2_4 ADC_CH7, ///\u0026lt;GPIO_2_3 ADC_CH8, ///\u0026lt;GPIO_2_2 ADC_CH9, ///\u0026lt;GPIO_2_1 ADC_CH10 = 10, ///\u0026lt;GPIO_2_0 ADC_CH11, ///\u0026lt;GPIO_3_1 ADC_CH12, ///\u0026lt;GPIO_3_0 ADC_CH14 = 14, ///\u0026lt;VBAT ADC_CH15 = 15, ///\u0026lt;temperature sensor }; Note:\nChannel 13 is only for internal usage.\nVref # The Vref (Reference Voltage) can be configured as either 1.0V or 1.5V. The ADC\u0026rsquo;s range is 2*Vref. And the maximum ADC sample value is 0xFFF. Note:\nDon’t input voltage higher than 2*Vref to ADC pin.\nChannel 14(VBAT) and channel 15(temperature) can only use 1.0V Vref.\nCapture clock # Should set capture clock base on input impedance.\nCaputure clock frequency = 1 / (14*Rs*C) Rs is input\u0026#39;s output resistance (Rs). C is internal capacitor, it is 11 pF. Note:\nIf use a lower capture clock, will get a lower ADC sample rate.\nIf use a higher capture clock, it may be necessary to discard the first few samples.\nGroup interval # The group interval refers to the sampling interval between groups of samples in auto mode. The unit is us (the ADC clock is set to 1MHz) with the range of 0~255, and the default value is 16us.\nConfigration # Configration tool\nSelect \u0026ldquo;SADC\u0026rdquo; in SwiftConfig tool peripheral tab. If use auto mode, select \u0026ldquo;Sensor ADC\u0026rdquo; in Misc tab. And set SMEM size. A single sample has 2 bytes, and the minimum required size can be calculated according to the number of needed samples. SMEM size = all channel samples * 2 Example code # Force Mode Sample channel 5 in force mode:\nadc_dev_t * dev = hal_adc_open(); hal_adc_force_mode_enable_ch(dev, ADC_CH5); uint16_t buff[16]; int res = hal_adc_force_mode_start(dev, ADC_CH5, buff, 16); Auto Mode Enable \u0026ldquo;ADC_CH1\u0026rdquo; and \u0026ldquo;ADC_CH2\u0026rdquo;, get 32 samples for each channel.\nThe sampling order is shown as follows,end after 32 cycles:\nCH1 CH2 CH1 CH2 CH1 CH2 …\nuint8_t buf1[32]={0}; uint8_t buf2[32]={0}; adc_dev_t * dev = hal_adc_open(); hal_adc_auto_mode_enable_ch(dev, ADC_CH1, buf1, 32); hal_adc_auto_mode_enable_ch(dev, ADC_CH2, buf2, 32); hal_adc_auto_mode_start(dev,32, osWaitForever); Convert data # Convert raw data to voltage and temperature.\nUse \u0026ldquo;hal_adc_sample_convert\u0026rdquo; to covert raw data to voltage for channel0 ~ channel 12. Use \u0026ldquo;hal_adc_vbat_sample_convert\u0026rdquo; for channel 14. Use hal_adc_temp_sample_convert\u0026quot; for channel 15. These API use calibration data for coverting.\n"},{"id":11,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/adc-sample.html","title":"ADC Sample","section":"Driver Examples","content":" ADC Sample # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_adc in-dev/proj/driver/proj_drv_adc Configuration # #define FORCE_MODE 1 //0: auto mode, 1: force mode Define whether choose force mode or not.\n#define FORCE_MODE_SAMPLE_NUM 16 #define AUTO_MODE_SAMPLE_NUM 16 Define the sample num in adc test.\n#define DISCARD_NUM 0 ///\u0026lt; skip adc sample number Define the sample num need to be discarded.\n#define CH_NUM 4 Define the adc test total channel num.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of sample value, test content and value according to UART Log. The following are samples: VBAT ch:14 =0xab3 3294.8mV,\ntest content: VBAT/Temperature/...\nchosen channel: ch:...\nmeasurement value: =0x...\nconverted value: here is 3294,8mV\nMore information may be found in debug guide page.\nTest Steps # force mode\nOpen Keil and set FORCE_MODE to be 1, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. auto mode\nOpen Keil and set FORCE_MODE to be 0, download proj_drv_adc. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. On UART log, there will be text like \u0026ldquo;VBAT ch:14 =0xab3 3294.8mV\u0026rdquo;. "},{"id":12,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/aes-sample.html","title":"AES Sample","section":"Driver Examples","content":" AES Sample # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.\nAES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted. AES encryption has three modes: ECB (Electronic Codebook), CBC (Cipher Block Chaining), and CFB (Cipher Feedback).\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_aes in-dev/proj/driver/proj_drv_aes Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of encryption to UART Log. If test pass, ...passed or ... successed will be shown on UART log.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil, download proj_drv_aes. Press the reset button and observe the log for the message main start.... The status of encryption will be shown on UART log. "},{"id":13,"href":"/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html","title":"Antenna Diversity","section":"Driver Integration","content":" Antenna Diversity # Overview # The antenna diversity engine supports signal RSSI evaluation and antenna switching, and it supports both dual and 4 antennas. Signal evaluation and antenna switching are performed in the background by the chip\u0026rsquo;s hardware modules.\nAPI # initialization. # int hal_ana_diversity_init(uint8_t num_ants, uint8_t frz_time, uint32_t agc_stable_time);\rvoid hal_ann_2diversity_gpio25_invgpio00_sw_init(void);\rvoid hal_ann_4diversity_gpio25_gpio26_sw_init(void); Example of Dual Antenna # int main(void)\r{\rint res;\ruint8_t tx_buf[16];\rsdr_mstr_scan_t scan_cfg;\rhal_global_post_init();\rPRINTD(DBG_TRACE, \u0026#34;%s %s\\r\\n\u0026#34;, __DATE__, __TIME__);\rPRINTD(DBG_TRACE, \u0026#34;CHIP ID = %08X\\r\\n\u0026#34;, chip_get_id());\rhal_ana_diversity_init(2, 40, 40); hal_ann_2diversity_gpio25_invgpio00_sw_init();\rres = in_sdr_init();\rif (SDR_ERR_OK != res)\r{ PRINTD(DBG_ERR, \u0026#34;in_sdr_init failed %d\\r\\n\u0026#34;, res);\rreturn 1;\r}\rscan_cfg.chn = 37;\rscan_cfg.txr = PHY_RATE_1M;\rscan_cfg.rxr = PHY_RATE_1M;\rscan_cfg.aa = 0x8E89BED6;\rscan_cfg.rxw_sz = 0x80ff;\rscan_cfg.rx_arg = NULL;\rscan_cfg.rx_callback = sdr_rx_callback;\rhw_ana_set_tx_power(TX_POWER_7);\rwhile (1) { res = in_sdr_mstr_scan(\u0026amp;scan_cfg, tx_buf, 0);\rif (SDR_ERR_OK != res)\r{\rPRINTD(DBG_ERR, \u0026#34;SDR scan failed %d\\r\\n\u0026#34;, res);\r}\r}\rreturn 1;\r} "},{"id":14,"href":"/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html","title":"AOA Antenna Guide","section":"Driver Integration","content":" AOA Antenna # Overview # AOA Antenna engine supports antenna switching and IQ capture,as shown in the following Figure.AOA Antenna engine supports IQ capture for constant tone inside the payload and attached to the packet after CRC.\nBelow are some key features of the AoA antenna switching IQ capture engine:\nProgrammable SYNC address (preamble is not programmable) Programmable channel index and frequency relationship The enable/disable of whitening is programmable (the whitening sequence is not programmable, it is decided by the channel index) Support up to 256 antenna patterns. The antenna pattern can be directly to control the outputs of 8 GPIOs. Programmable starting time for IQ capture and antenna switching (as shown in above figure) Programmable antenna switching pattern Programmable duration for each antenna (in terms of how many clock cycles of a 2MHz clock) 4 programmable capture speeds: 8, 4, 2 and 1 MSPS Capture length is up to 8192 IQ samples (For 8 MSPS IQ capture speed, it means we can capture IQ samples up to 1024 us). Two programmable raw IQ capture word length: 14-bit and 12-bit in 2’s complement. Readable IQ capture status: the starting address in capture memory and length Two AGC operation modes (SW programmable) Freeze after SYNC is found Always adjust the gain according to the input signal level IQ and Antenna switching for constant tone inside the payload (before CRC) or after CRC Design Details # The following Figure shows the AoA antenna switching and IQ capture scheme. The AoA captured is controlled by the AoA controller. Once the controller detects a valid special signal (by matching the sync address that user has programmed), the controller uses the SYNC valid signal to generate various RX antenna switching signals and automatically captures the IQ samples.\nAntenna Switch # AOA Antenna engine support a sequence of RX antenna switch signals as shown in the above figure, which have the following feature:\nThe sequence consists of multiple 8-bit patterns (up to 256 patterns). Each of bit of a pattern can be mapped to an GPIO output. The sequence can have up to 256 patterns. Each pattern has its own programmable duration (10-bit, unit 0.5us). The sequence consists of:\nPattern 0 and its duration Pattern 0 is the default antenna pattern, and it is used upon RX enabled. Pattern 0 duration: This duration is measured starting from SYNC found. Pattern 1 and Pattern 1 duration Pattern 2 and Pattern 2 duration …… The last pattern and the last pattern duration The last pattern duration is a don’t care, it means the pattern will be used until the end of the RX regardless of the time being programmed. All the above durations have a unit of 0.5us and can be up to 511.5 us. If the specified duration is 0, it means that the corresponding antenna will be used until the end of RX.In normal case, if SYNC is found, then the antenna switch will be always like (Pi denotes pattern i).P0, P1, P2, …, PN. If the received signal is not good (like SYNC is not found), the switching may end early and stop before PN where PN is the last pattern.\nIQ Data Capture # Once RX is enabled, IQ data along with the used antenna pattern are captured into memory if AoA is enabled. The captured data are written into memory in a circular way. If the address reaches its maximum, the address wraps around.\nOnce a SYNC is found, the address holds the captured data when SYNC found happens is written into a status register which user can access. The IQ capture keeps going until the IQ capture duration expires.The IQ capture can be captured starting from SYNC found or be captured since RX is enabled. In the first case, the memory with address offset of 0 holds the IQ capture when SYNC is found. In the second case, there is a status register which tells us the address offset of the IQ capture when SYNC is found.\nEach IQ capture occupies 4 bytes, the device supports up to 8192 IQ captures. The IQ capture can be captured at a speed of 8 MSPS, 4 MSPS, 2MSPS and 1 MSPS (user programmable).\nBit-patten match and mask # AOA Antenna engine also supports a feature that only if both SYNC match and some of bits in a 32-bit sequence match, the device starts to do AoA antenna switch and IQ capture.\nIf this feature is enabled, besides the SYNC, the AoA antenna switch and IQ capture also rely on the received bits. The user can program where the 32-bits starts (i.e., the bit position offset in following figure), the 32-bit pattern which user want to let the hardware to compare with the received bits. In addition, the user can program a mask in case only some selected bits in the 32-bit pattern need to be matched. API # initialization. # typedef struct aoa_cap_ant_pattern_s\r{\ruint16_t duration;\ruint8_t addr;\r} aoa_cap_ant_pattern_t;\rtypedef struct aoa_cap_filter_s\r{\rint8_t enable;\rint8_t channel;\ruint32_t bit_pattern; //B0 is header[0];B1 is header[1];B2 is address[0];B3 is address[1]\ruint32_t bit_mask;\r} aoa_cap_filter_t; const aoa_cap_ant_pattern_t *patterns is antenna switch pattern, int size is size of patterns, maximum is 256, aoa_cap_filter_t *filter is bit-patten match and mask void (*on_data)(uint32_t *data, uint16_t samples the callback function will be called when finish.\rvoid hal_ana_aoa_capture_init(const aoa_cap_ant_pattern_t *patterns, uint8_t pattern_size, aoa_cap_filter_t *filter, void (*on_data)(uint32_t *data, uint16_t samples)); "},{"id":15,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-advertising-sample.html","title":"BLE advertising Sample","section":"BLE Examples","content":" BLE Advertising Sample # Overview # Bluetooth advertising is based on the transmission of advertising packets. An advertising packet is a small amount of data that contains device identifiers and other relevant information. The transmission of advertising packets is connectionless, meaning that it does not require pairing or connection operations before establishing a Bluetooth connection.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_adv_conn in-dev/proj/BLE/proj_ble_adv_conn Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_adv_conn. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. We can search for the device with the corresponding address on a Bluetooth device. If we have two development boards, we can download the proj_ble_init project on another board. The board with proj_ble_init can automatically connect to the board with proj_ble_adv_conn. "},{"id":16,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-gatt-sample.html","title":"BLE GATT Sample","section":"BLE Examples","content":" BLE GATT Sample # Overview # GATT (Generic Attribute Profile) is a protocol introduced in Bluetooth that defines the communication rules between Bluetooth devices. It enables different types of Bluetooth devices to communicate and exchange data efficiently, particularly in Bluetooth Low Energy (BLE) devices such as smart bracelets, watches, and health monitoring devices.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_gatt_service\u0026amp;proj_ble_gatt_write in-dev/proj/BLE/proj_ble_gatt_service\u0026amp;proj_ble_gatt_write Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both central and peripheral according to Uart Log. The following are samples,\nCentral # start initiation process start init connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... Peripheral # start advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... More information may be found in debug guide page.\nTest Steps # Central Download and run the proj_ble_gatt_write project.\nThe Bluetooth device initiates a connection request.\nAfter a successful connection, central would enable peripheral notification and we can view the address information of the Bluetooth device on the Terminal Emulator.\nThe Bluetooth device sends a write request to the development board periodically.\nPeripheral Download and run the proj_ble_gatt_service project. The Bluetooth device starts advertising. After a successful connection, we can view the address information of the Bluetooth device on the Terminal Emulator. The Bluetooth device sends a notify request to the development board periodically. "},{"id":17,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-initiation-sample.html","title":"BLE Initiation Sample","section":"BLE Examples","content":" Ble Initiation Sample # Overview # The Bluetooth connection initiation mode refers to the method utilized by a Bluetooth device to proactively initiate a connection with other devices. Within Bluetooth communication, there are typically two connection modes: Central and Peripheral. The Central mode represents the party that takes the initiative in establishing the connection, whereas the Peripheral mode signifies the party that passively accepts the connection.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_init in-dev/proj/BLE/proj_ble_init Debug # We can get the status of development board according to Uart Log. The following are samples,\nCentral # start initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nPeripheral # start advertising process start advertising\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_init (Central), and on another development board, download proj_ble_adv_conn (Peripheral).\nPress the reset button on the central board and the peripheral board, observe the text CHIP ID = appear in the log, and begin scanning based on the settings in in_config.h.\nWhen scanning for devices with the Peripheral address, the Central will initiate a connection request to the Peripheral, and the Peripheral will accept the connection request, establishing a Bluetooth connection.\n"},{"id":18,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-keyboard-sample.html","title":"BLE Keyboard Sample","section":"BLE Examples","content":" BLE Keyboard Sample # Overview # Bluetooth is widely used in wireless mouse and keyboard, this is an example for chip to plays a role of keyboard using bluetooth.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_Keyboard in-dev/proj/BLE_no_os/proj_ble_Keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... send keyboard command report idx=0 More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_Keyboard. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. We can search for the device with the corresponding address on a Bluetooth device. Connect to the device and send bond request to the device. After that, we will get keyboard information a for 3 seconds. "},{"id":19,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-scan-sample.html","title":"BLE Scan Sample","section":"BLE Examples","content":" Bluetooth Scan Sample # Overview # In Bluetooth Low Energy (BLE), scanning is the process where a BLE central device (such as a smartphone or a BLE-enabled gateway) actively searches and listens for advertising packets from nearby BLE peripheral devices. The scanning process allows the central device to discover and connect to nearby peripherals.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_scan in-dev/proj/BLE/proj_ble_scan Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nstart scan process: start scan get advertising data from other BLE device: *** ADV DATA FROM...*** , ...means the address of other device. More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_ble_scan. Press the reset button and observe the text CHIP ID = on the log while the device starts advertising according to the settings in in_config.h. After device scanning start, we can get advertising data from other BLE device. "},{"id":20,"href":"/docs/in6xxe/examples-and-use-case/ble/ble-transparent-transmission-sample.html","title":"BLE Transparent Transmission Sample","section":"BLE Examples","content":" BLE Transparent Transmission Sample # Overview # In Bluetooth data transparent transmission, the sending device packages the raw data into Bluetooth data packets and sends them to the receiving device through the Bluetooth connection. After receiving these data packets, the receiving device can directly read and parse the raw data without any decoding or processing.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_trx_clt\u0026amp;proj_ble_trx_svc in-dev/proj/BLE/proj_ble_trx_clt\u0026amp;proj_ble_trx_svc Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both central and peripheral according to Uart Log. The following are samples,\nCentral # start scan process Scan start\nstart initiation process start init\nconnection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot;\ndisconnect *** Disconnect ***, reason=...\nReceive data TRX RX: len=...\nPeripheral # start advertising process start advertising connection established \u0026quot;ble_connect Connect ... intv:... lantency:... timeout:... clock:...\u0026quot; disconnect *** Disconnect ***, reason=... Receive data TRX RX: len=... More information may be found in debug guide page.\nTest Steps # Using a Single Development Board Download and run the proj_ble_trx_svc project. The development board starts Bluetooth broadcasting, allowing the Bluetooth device to search and find the broadcast data. The Bluetooth device initiates a connection request. After a successful connection, we can view the address information of the Bluetooth device on the Terminal Emulator. The Bluetooth device sends a write request to the development board. The developer inputs data on the Terminal Emulator and sends it. The development board transmits data to the Bluetooth device, which will display the same data content upon receiving it. Using Two Development Boards Central downloads the proj_ble_trx_clt, while Peripheral downloads the proj_ble_trx_svc. Reset Central device and Peripheral device. Peripheral development board starts Bluetooth broadcasting, allowing Central to search and find the broadcast data. Central initiates a connection request. After a successful connection, we can view the address information of the other party on Uart log. On the client side of the Uart, input data and send it. The client sends a write request to the server, and the server receives the same data. The developer on the Peripheral side inputs data and sends it. Peripheral transmits data to the Central, which will display the same data content upon receiving it. "},{"id":21,"href":"/docs/in6xxe/protocols-reference/ble/inplay-ble5.0-at-command-set.html","title":"BLE5.0 AT Command Set","section":"BLE","content":" Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.\nIN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.\nCONTROL INTERFACE # The AT commands are transmitted over standard UART interface. A terminal emulator, such as TeraTerm (Windows) or CoolTerm (Mac OS-X®), can be used to control the module from a computer, with the following default port settings:\n115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The serial port parameter configure command can modify the UART settings permanently.\nSYNTAX # The AT commands can be divided into 3 main categories: Command, Response and Event. The module receives Command and, after execution, sends back Response to the command initiator. When something happens in the module, such as an unexpected disconnection, receiving data from a remote device, etc., a corresponding Event is sent.\nCOMMAND SYNTAX # An AT command is composed of the Prefix, CommandID, CommandBody and Terminator as shown below.\nAT+\u0026lt;CommandID\u0026gt;=\u0026lt;CommandBody\u0026gt;\u0026lt;Terminator\u0026gt; The Prefix of each command is fixed ASCII string \u0026ldquo;AT\u0026rdquo; or \u0026ldquo;at\u0026rdquo;.\nCommandID is an ASCII string representing different command. It\u0026rsquo;s case sensitive.\nCommandBody can be either ASCII \u0026lsquo;?\u0026rsquo; if the command gets a parameter or parameters set if the command sets parameter. A parameter set is a collection of parameters surrounded by \u0026lsquo;[]\u0026rsquo;, each separated by \u0026lsquo;,\u0026rsquo;.\nTerminator of each command is carriage return (CR, \u0026lsquo;\\r\u0026rsquo;, \\x0d) and line feed (LF, \u0026lsquo;\\n\u0026rsquo;, \\x0a). Command is accepted and executed only when the Terminator is received.\nRESPONSE SYNTAX # After an AT command is executed, a response will be sent back. Response consists of corresponding CommandID, ResponseBody and Terminator as shown below.\n+\u0026lt;CommandID\u0026gt;=\u0026lt;ResponseBody\u0026gt;\u0026lt;Terminator\u0026gt; If command is to set parameter, the ResponseBody is either parameter set read or just a numerical error result code. The format of the read parameter set is same as the format of the set parameters of the corresponding command. Only result code is returned for set parameter commands.\nEVENT SYNTAX # An event is a message reported by the module initiatively, rather than a response obtained through the AT command. An event consists of EventID, EventBody and Terminator as shown in below.\n+\u0026lt;EventID\u0026gt;=\u0026lt;EventBody\u0026gt;\u0026lt;Terminator\u0026gt; EventID is an ASCII string representing different event. It\u0026rsquo;s case sensitive. EventBody is a parameter set and its format is same as CommandBody in AT command. Terminator is same as that in AT command response.\nPARAMETER VALUE # Parameter in parameter set supports numeric values, strings. There are three format of string: ASCII format string, Byte Array format string and Base64 encoding format string.\nEXAMPLES # The below table lists some examples of AT commands and their responses and events.\nCommand/Event Function Response AT+DEVCFG=[10,\"112222222211\",0,\"Slave\",1] Set device general configuration +DEVCFG=0000H AT+DEVCFG=? Get device general configuration +DEVCFG=[10,\"112222222211\",0,\"Slave\",1] AT+CFGADVACTV=[1,0,1,500,0,\"BwlJbnBsYXk=\"] Create legacy connectable advertising in 500ms interval. The payload is local name \"Inplay\" +CFGADVACTV=0000H: successful\n+CFGADVACTV=0043H: error advertising can't be create -EVTCONN=[1,\"EFBBCCCCDDEF\",1,1] Connected with device \"EF:DD:CC:CC:BB:EF\" on 1M PHY COMMAND REFERENCE # This section describes AT commands in detail and provides examples. Those parameter surrounded by \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; brackets are optional in some cases. If an optional parameter needs to be set, all optional parameters prior to that optional parameter must also be provided.\nSince the responseBody of the response returned by the get command is the same as the CommandBody of the corresponding set command, for simplicity, only the format of the get command is listed.\nGet Module State # This command gets the current status of the module.\nCommand: AT+STATE=?\nResponse: +STATE=[sys_state,pair_state,conn_state,scan_state,adv_state]\nParameter Type Value sys_state Number 0: Not ready;\n1: Ready pair_state Number 0: Not paired;\n1: Paired conn_state Number 0: Unconnected\n1: Connecting 2: Connected scan_state Number 0: Scanning Stopped;\n1: Scanning Started adv_state Number 0: Advertising Stopped;\n1: Advertising Started Example:\n→AT+STATE=?\n←+STATE=[1,0,0,0,0]\nGet Version # This command gets the version of the module including chip version, sdk version and firmware version\nCommand: AT+VER=?\nResponse: +VER=[chip_ver,sdk_ver,fw_ver]\nParameter Type Value chip_ver String Chip version sdk_ver String SDK version fw_ver String Firmware version Example:\n→AT+VER=?\n←+VER=[\u0026ldquo;602F0100\u0026rdquo;,\u0026ldquo;3.0.0\u0026rdquo;,\u0026ldquo;xxxx\u0026rdquo;]\nUART Configuration # This command sets UART parameters. Once UART parameter is changed, module will automatically reset and all parameters configured before will be lost.\nCommand: AT+CFGUART=[baud_rate,\u0026lt;data_bit\u0026gt;,,\u0026lt;stop_bit\u0026gt;]\nResponse: +CFGUART=err_code\nParameter Type Value baud_rate Number Standard UART baud rate value data_bit Number 5 - 8 bits polarity Number 0：No polarity\n1：Odd polarity\n2：Even polarity\nOther: invalid value stop_bit Number 0: 1 stop bits\n1: 2 stop bits Example:\n→AT+CFGUART=[921600,8,0,1]\n←+CFGUART=0000H\nDevice General Configuration # This command gets or sets the general parameters of the module.\nCommand: AT+CFGDEV=[role,dev_addr,addr_type,dev_name,phy]\nResponse: +CFGDEV=err_code\nParameter Type Value role Number 1 Observer 2 Broadcaster 5 Central 10 Peripheral 15 All Role dev_addr String Byte Array format string representing MAC address of device in little-endian mode addr_type Number 0: Public address;\n1: Static random address dev_name String ASCII phy Number 0 Random 1 1M Phy 2 2M Phy 4 Coded Phy Example:\n//Set device as BLE Peripheral, device public MAC address is 11-22-22-22-22-11, device name is \u0026ldquo;Slave\u0026rdquo; and prefered PHY is 1M PHY\n→AT+CFGDEV=[10,\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,1]\n←+CFGDEV=0000H\n//Set device as All role and prefered PHY is Coded Phy\n→AT+CFGDEV=[15,\u0026ldquo;AABB0101BBAA\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,4]\n←+CFGDEV=0000H\nData Transparent Transmission Service Configuration # This command gets or sets parameters of Inplay private data transparent tranmission service as GATT server, including service UUID, maximum data transmission size etc. After the execution of the command, the service with specified parameters will be created. It MUST be sent after +CFGDEV\nIt is only allowed by device with \u0026lsquo;Peripheral role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXSVC=[start_hdl,svc_uuid,max_data_sz]\nResponse: +CFGTRXSVC=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically created\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied max_data_sz Number Maximum data transmission size\n0: Default 20 bytes\n1 - 1024: Maximum data size Example:\n//Set service UUID as 1122b4f8-cdf3-11e9-a32f-2a2ae2dbcce4 and the maximum transmission data as 512 bytes.\n→AT+CFGTRXSVC=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;,512]\n←+CFGTRXSVC=0000H\n//Set service UUID by default. Fixed service start handle to 20\n→AT+CFGTRXSVC=[20,\u0026quot;\u0026quot;,0]\n←+CFGTRXSVC=0000H\nData Transparent Transmission Client Configuration # This command gets or sets parameter of Inplay private data transparent tranmission service as GATT client. If parameters are not set or parameter \u0026lsquo;start_hdl\u0026rsquo; is set to 0, device will initiate a Service Discovery Process (SDP) to find remote service after connection.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXCLT=[start_hdl,svc_uuid]\nResponse: +CFGTRXCLT=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically get by SDP\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied Example:\n//Set to discover service by SDP.\n→AT+CFGTRXCLT=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;]\n←+CFGTRXCLT=0000H\n//Set specific start handle and leave other in default, so that SDP is not necessary.\n→AT+CFGTRXCLT=[20,\u0026quot;\u0026quot;]\n←+CFGTRXCLT=0000H\nRF Configuration # This command gets or sets RF related parameter.\nCommand: AT+CFGRF=[tx_power]\nResponse: +CFGRF=err_code\nParameter Type Value tx_power Number TX power: 0Max TX power (~8dBm) 1-157dBm to 0dBm with step 0.5dBm 16-22-1dBm to -7dBm with step -1dBm Example:\n//Set TX power +3dBm\n→AT+CFGRF=[9]\n←+CFGRF=0000H\nSMP Configuration # This command gets or sets security parameters of the module.\nCommand: AT+CFGSMP=[smp,dev_io_cap,pairing_code]\nResponse: +CFGSMP=err_code\nParameter Type Value smp Number (1 byte) - - - - LE Secure Connection MITM - Encryption - - - - Bit3 Bit2 - Bit0 0: false; 1: true dev_io_cap Number 0 Display Only 1 Display Yes No 2 Keyboard Only 3 Keyboard Display 4 No Input No Output pairing_code String ASCII Paring code Example:\n//Set SMP to MITM security and encryption, with ability of keyboard input. The corresponding MITM pairing code is 012345\n→AT+CFGSMP=[5,2,\u0026ldquo;012345\u0026rdquo;]\n←+CFGSMP=0000H\nTarget Device Configuration # This command gets or sets the target devices that are allowed to connect or scan. If initiating activity is configured as direct connection type, only first device in the device list is the target. Maximum 25 target devices can be set.\nIt is only allowed by device with ‘Central role’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGTARGET=[dev1_addr,dev1_addr_type,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_addr_type\u0026gt;,\u0026hellip;]\nResponse: +CFGTARGET=err_code\nParameter Type Value dev_addr String Byte Array format string representing MAC address of target device in little-endian mode dev_addr_type Number 0: Public address;\n1: Static random address Example:\n→AT+CFGTARGET=[\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;AABBCCCCDDEE\u0026rdquo;,0]\n←+CFGTARGET=0000H\nAdvertising Activity Configuration # This command sets parameter to create BLE advertising activity. Maximum 2 advertising activities can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Peripheral’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGADVACTV=[actv_id,adv_type,connectable,intv,chn,payload]\nResponse: +CFGADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity adv_type Number 0: Legacy Advertise 1: Extended Advertise connectable Number 0: Unconnectable 1: Connectable intv Number 20-10240ms chn Number 0: all BLE advertising channel\n37-39: Fixed channel payload String BLE standard advertising data format in base64 encoding\nLength (1 byte) + Type (1 byte) + Content (length -1 byte) Example:\n//Set legacy connectable advertising in 500ms interval. The payload is local name \u0026ldquo;Inplay\u0026rdquo;\n→AT+CFGADVACTV=[1,0,1,500,0,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n//Successfully set\n←+CFGADVACTV=0000H\nScan Activity Configuration # This command sets parameter to create BLE scan activity. Only one scan activity can be created.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGSCANACTV=[actv_id,type]\nResponse: +CFGSCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity type Number 2: Observer\n3: Selective observer. Only devices configured by +CFGTARGET will be reported Example:\n//Set scan activity\n→AT+CFGSCANACTV=[20,3]\n//Successfully set\n←+CFGSCANACTV=0000H\nInitiating Activity Configuration # This command sets parameter to create BLE initiating activity to establish connections with the target device. Only one initiating activity can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Central\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGINITACTV=[actv_id,type]\nResponse: +CFGINITACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity type Number 0: Direct connect\n1: Auto connect. Only devices configured by +CFGTARGET can be connected Example:\n//Create initiating activity to auto connect with target devices.\n→AT+CFGINITACTV=[10,1]\n//Successfully set\n←+CFGINITACTV=0000H\n//Create initiating activity to direct connect with remote device.\n→AT+CFGINITACTV=[10,0]\n//Successfully set\n←+CFGINITACTV=0000H\nStart Advertising Activity # This command start advertising activity that is created by previous +CFGADVACTV command.\nCommand: AT+ADVACTV=[actv_id,op,\u0026lt;duration\u0026gt;]\nResponse: +ADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activities op Number 0: Stop Activity\n1: Start Activity duration Number 0: Forever\n10-65535: Actual duration (in unit of 10ms)\nDefault 0 Example:\n//Start advertising activty permanently\n→AT+ADVACTV=[1,1,0]\n//Successfully set\n←+ADVACTV=0000H\n//Stop advertising activity\n→AT+ADVACTV=[1,0]\n←+ADVACTV=0000H\nStart Scan Activity # This command start scan activity that is created by previous +CFGSCANACTV command. If target devices are not configured by +CFGTARGET command, advertisement from any devices scaned will be reported.\nCommand: AT+SCANACTV=[actv_id,op,\u0026lt;intv\u0026gt;,\u0026lt;wnd\u0026gt;,\u0026lt;chn\u0026gt;,\u0026lt;duration\u0026gt;,\u0026lt;dup_filter\u0026gt;]\nResponse: +SCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity op Number 0: Stop Activity\n1: Start Activity intv Number Scan activity interval 3-40959 ms\nDefault 200ms wnd Number Scan running time, must be less than intv\nDefault 100ms chn Number 0: Scan on three channel alternately\n37-39: Scan on fixed channel\nDefault 0 duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 dup_filter Number 0: No filtering\n1: Filter duplicates within the duration\nDefault 0 Example:\n//Start scan activty permanently\n→AT+SCANACTV=[20,1,200,100,0,0,1]\n//Successfully set\n←+SCANACTV=0000H\n//Stop scan activity\n→AT+SCANACTV=[20,0]\n←+SCANACTV=0000H\nStart Initiating Activity # This command start initiating activity that is created by previous +CFGINITACTV command. If target devices are not configured by +CFGTARGET command, activity cann\u0026rsquo;t be started and retures error response. When it is started permanently, it will end until all target devices configured are connected.\nCommand: AT+INITACTV=[actv_id,op,\u0026lt;conn_intv\u0026gt;,\u0026lt;latency\u0026gt;,\u0026lt;sup_tmo\u0026gt;,\u0026lt;duration\u0026gt;]\nResponse: +INITACTV=err_code\nParameter Type Value actv_id Number Unique ID for initiating activity op Number 0: Stop Activity\n1: Start Activity conn_intv Number Connection interval: 8 - 4800 ms\nDefault 100 ms latency Number 0 - 499\nDefault 0 sup_tmo Number 100 - 32000 ms\nDefault 20000 ms duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 Example:\n//Start initiating activty\n→AT+INITACTV=[10,1,200,0,20000,0]\n//Successfully set\n←+INITACTV=0000H\n//Stop initiating activity\n→AT+INITACTV=[10,0]\n←+INITACTV=0000H\nGet current connection list # This command gets a list of currently connected devices.\nCommand: AT+CONNLST=?\nResponse: +CONNLST=[\u0026lt;dev1_addr\u0026gt;,\u0026lt;dev1_role\u0026gt;,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_role\u0026gt;,\u0026hellip;]\nParameter Type Value dev_addr String The Byte Array format string representing MAC address of peer device in little-endian mode dev_role Number 0: Peer device as Master role;\n1: Peer device as Slave role Example:\n→AT+CONNLST=?\n//Connect to master device \u0026ldquo;66-55-44-33-22-11\u0026rdquo; and a peripheral device \u0026ldquo;FF-EE-DD-CC-BB-AA\u0026rdquo;\n←+CONNLST=[\u0026ldquo;112233445566\u0026rdquo;,0,\u0026ldquo;AABBCCDDEEFF\u0026rdquo;,1]\nStart Pairing # This command start operation of BLE pairing with connected device.\nCommand: AT+BOND=[op,dest_addr,\u0026lt;pairing_code\u0026gt;]\nResponse: +BOND=err_code\nParameter Type Value op Number 0: Cancel pairing\n1: Start pairing dest_addr String The Byte Array format string representing MAC address of connected device in little-endian mode pairing_code String 6 bytes ASCII pairing code Example:\n→AT+BOND=[1,\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;012345\u0026rdquo;]\n←+BOND=0000H\n//Stop pairing\n→AT+BOND=[0,\u0026ldquo;112233445566\u0026rdquo;]\n←+BOND=0000H\nData Transmit # This command transmit data via Inplay private transparent transmission service.\nCommand: AT+DATATX=[dest_addr,data]\nResponse: +DATATX=err_code\nParameter Type Value dest_addr String The Byte Array format string representing MAC address of destination connected device in little-endian mode data String Base64 encoding string representing binary data to transmit Example:\n//Send data \u0026ldquo;0x0001020304050607080910\u0026rdquo; to remove device \u0026ldquo;66-55-44-33-22-11\u0026rdquo;\n→AT+DATATX=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n←+DATATX=0000H\nReset # This command causes the system to reset. While execution, application can choose whether to save or clear current configured parameters permanently. This command don\u0026rsquo;t have any response. The application determines whether reset is complete or not by receiving the +EVTREADY event.\nCommand: AT+SYSRST=[op]\nResponse: N/A\nParameter Type Value op Number 0: Reset module\n1: Reset after saving current parameters to Flash\n2: Reset after clearing current parameter from Flash Example:\n→AT+SYSRST=[1]\nWatchdog # This command set up watch dog.\nCommand: AT+SYSWDT=[wdt_enable,wdt_int_pol,wdt_tmo]\nResponse: +SYSWDT=err_code\nParameter Type Value wdt_enable Number 0: Disable\n1: Enable wdt_int_pol Number 0: Low level trigger interrupt\n1: High level trigger interrupt wdt_tmo Number 1 - 65536 seconds Example:\n→AT+SYSWDT=[1,0,60]\n←+SYSWDT=0000H\nEVENT REFERENCE # -EVTREADY # This event indicates module is ready to accept AT commands. It is usually received after power on reset or +SYSRST command is executed.\nEvent: -EVTREADY=[prev_state]\nParameter Type Value prev_state Number 0 Power on reset or reset command with op 0 1 Reset command with op 1 2 Reset command with op 2 3 Watch dog reset Example:\n-EVTREADY=[1]\n-EVTCONN # This event indicates device has been connected or disconnected.\nEvent: -EVTCONN=[state,peer_addr,role,phy]\nParameter Type Value state Number 0: Disconnect\n1: Connect peer_addr String Byte Array format string representing MAC address of peer device in little role Number 5: Device is connected as Master role;\n10: Device is connected as Slave role phy Number Phy that connection on. Please refer to PHY parameter in command +DEVCFG Example:\n//Successfully connected with remote Master device \u0026ldquo;EF:DD:CC:CC:BB:EF\u0026rdquo; on 1M PHY.\n-EVTCONN=[1,\u0026lsquo;EFBBCCCCDDEF\u0026rsquo;,1,1]\n-EVTDATA # This event indicates the data reception from peer device.\nEvent: -EVTDATA=[peer_addr,data]\nParameter Type Value peer_addr String Byte Array format string representing MAC address of peer device in little-endian mode data String Base64 encoding format string representing binary data received Example:\n//Data \u0026ldquo;0x0001020304050607080910\u0026rdquo; received from remove device \u0026ldquo;66-55-44-33-22-11”\n-EVTDATA=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n-EVTADV # This event indicates that an advertising signal has been scanned.\nEvent: -EVTADV=[dev_addr,addr_type,connectable,rssi,payload]\nParameter Type Value dev_addr String Byte Array format string representing MAC address of advertising device in little-endian mode addr_type Number 0: Public\n1: Static random connectable Number 0: Unconnectable\n1: Connectable rssi Number Signed integer in dBm payload String Base64 encoding format string representing advertising payload binary data Example:\n//A connectable ad with local name \u0026lsquo;Inplay\u0026rsquo; as payload from device \u0026lsquo;66-55-44-33-22-11\u0026rsquo; is scanned. RSSI is -80dBm.\n-EVTADV=[\u0026ldquo;112233445566\u0026rdquo;,0,1,-80,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n-EVTACTVEND # This event indicates the termination of the command +SCANACTV, +ADVACTV, +INITACTV and +BOND, whether the commands are terminated automatically or manually.\nEvent: -EVTACTVEND=[actv_type,actv_id]\nParameter Type Value actv_type Number 0 Advertising activity 1 Scan activity 2 Initiating activity 3 Bond actv_id Number Unique ID for activity Example:\n//Advertising activity 1 has ended\n-EVTACTVEND=[0,1]\n//Scan activity has ended\n-EVTACTVEND=[1,20]\nERROR CODE # The ERROR CODE is returned as a hexadecimal value. Please refer to following table for details.\n0000H Command executed successfully 1001H Wrong command execution 100AH Wrong CommandID 100BH Wrong format 100DH Wrong parameter 100EH Execution overtime Others BLE error. Refer to in_ble_error.h in SDK "},{"id":22,"href":"/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html","title":"Counter Guide","section":"Driver Integration","content":" Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.\nThe 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.\nFor details, please refer to:\nHal_cnt_pwm.c Hal_cnt_timer.c Hal_ir.c Hal_sync7816.c Counter Mode # The counter supports four modes:\nCapture Mode: In Capture Mode, the counter captures waveforms on din A and din B. It detects falling edge and rising edge, records the timestamp into corresponding registers.\nCapture Register 0: Stores the counter value at the first event trigger(falling edge or rising edge).\nCapture Register 1: Stores the counter value at the second event trigger(falling edge or rising edge).\nCapture Register 2: Stores the counter value at the third event trigger(falling edge or rising edge). Subsequent event triggers will overwrite Capture Registers 0, 1, and 2.\nWaveform Mode: In Waveform Mode, the counter outputs signals on \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; based on the values stored in the target registers.\nTarget Register 0: Outputs 0 when the counter reaches the specified value. Target Register 1: Outputs 1 when the counter reaches the specified value. Target Register 2: Stops output when the counter reaches the specified value. Shift In Mode: In Shift In Mode, the counter reads signals from \u0026ldquo;Din A\u0026rdquo; and \u0026ldquo;Din B\u0026rdquo; on every clock cycle, capturing one bit at a time.\nShift Out Mode: In Shift Out Mode, the counter outputs signals to \u0026ldquo;Dout A\u0026rdquo; and \u0026ldquo;Dout B\u0026rdquo; on every clock cycle, transmitting one bit at a time.\nMode Switching: When automatic mode switching is enabled, Capture Mode and Waveform Mode can automatically switch. Similarly, Shift In Mode and Shift Out Mode can also automatically switch.\nConfiguration # Each counter has two input signals: \u0026ldquo;din A\u0026rdquo; and \u0026ldquo;din B\u0026rdquo;, as well as two output signals: \u0026ldquo;dout A\u0026rdquo; and \u0026ldquo;dout B\u0026rdquo;. These internal signal can be configured to connect to external pins. Specifically, these pins are represented as PIN0 to PINI7 (GPIO21 to GPIO28) on the diagram. Select \u0026ldquo;Counter\u0026rdquo; in config tool and select the corresponding pin according to the actual circuit.\nRefer to:\nint hal_cnt_internal_din_pinmux(int inner_pin, int ext_pin) int hal_cnt_internal_dout_pinmux(int inner_pin, int ext_pin) EXT_DIN is from PIN0~PIN7.\nINNTER_DIN is internal din signal from four counters.\nInterrupt # Interrupt status. Each bit is represented as follows:\nCNT_A_UPDATE 1\tcapture register a0 a1 a2 all updated CNT_B_UPDATE 0x2\tcapture register b0 b1 b2 all updated CNT_OVERFLOW 0x4\tcounter overflow the counting will restart CNT_SHIFTIN_COMPLETE 0x8 shift in completed CNT_SHIFTOUT_COMPLETE 0x10\tshift out completed CNT_WAVEFORM_STOP 0x20\twaveform stop, the counter has reached the value of register a2/b2 CNT_SHIFTIN_CAPTURE_END 0x40\tin the automatic switching mode, capture or shift in is completed CNT_SHIFTOUT_WAVEFORM_END 0x80 in the automatic switching mode, waveform or shift out is completed API # Set the callback of the interrupt. # The callback fun will be called during the interrupt.\nvoid hal_cnt_set_handler(cnt_dev_t *dev, CNT_ISR_FUN fun, void *arg) Mask/unmask interrupt # int hal_cnt_intr_unmask(cnt_dev_t* dev) int hal_cnt_intr_mask(cnt_dev_t* dev) Enable/Disable # void cnt_enable(uint32_t base) void cnt_disable(uint32_t base) Trigger and signal source # The counter can be set to be triggered by signal or manually.\nSet the signal source and edge\nvoid cnt_set_src_edge(uint32_t base, uint32_t src_edge)\nSignal source:\n#define CNT_EXT_DIN_A 1 #define CNT_EXT_DIN_B 2 #define CNT_GLOBAL_START_TRIGGER 3 #define CNT_SINGLE_START_TRIGGER 4 #define CNT_GLOBAL_STOP_TRIGGER 5 #define CNT_SINGLE_STOP_TRIGGER 6 #define CNT_INNER_DIN0 11 #define CNT_INNER_DIN1 12 #define CNT_INNER_DIN2 13 #define CNT_INNER_DIN3 14 Global trigger will trigger all four counters, single trigger will only trigger one counter.\nEdge\n#define CNT_RISING_EDGE 0 #define CNT_FALLING_EDGE 0x10UL #define CNT_BOTH_EDGE 0x20UL Signal\nStart signal\n#define CNT_START_SIGNLE_SHIFT 0 Stop signal\n#define CNT_STOP_SIGNLE_SHIFT 8 Din 0 signal\n#define CNT_DIN0_SHIFT 16 Din 1 signal\n#define CNT_DIN1_SHIFT 24 Example # Set the external DIN A as the start signal. Double edge trigger. The DIN0 signal is the external DIN A. Double edge trigger.\ncnt_set_src_edge(cnt_dev-\u0026gt;base, (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_START_SIGNLE_SHIFT | (CNT_EXT_DIN_A | CNT_BOTH_EDGE) \u0026lt;\u0026lt; CNT_DIN0_SHIFT); Manual trigger # void cnt_trigger_start (uint32_t base) void cnt_trigger_stop (uint32_t base) Set the internal signal # void cnt_set_input_mux(uint32_t base, uint32_t val) Parameter Val, bus A by default\n#define CNT0_BUS_B 0x1 #define CNT1_BUS_B 0x2 #define CNT2_BUS_B 0x4 #define CNT3_BUS_B 0x8 Target control # void cnt_set_target_ctrl (uint32_t base, uint32_t ctrl) The behavior when the counter reaches register A2.\nKeep or reset value. Reset value by default.\n#define CNT_A2_KEEP_VALUE 0x1UL #define CNT_A2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_A2_STOP_COUNTER 0x2UL #define CNT_A2_RESTART_COUNTER 0x0UL The behavior when the counter reaches register B2\nKeep or reset value. Reset value by default.\n#define CNT_B2_KEEP_VALUE 0x4UL #define CNT_B2_RESET_VALUE 0x0UL Stop or restart counter. Restart by default.\n#define CNT_B2_STOP_COUNTER 0x8UL #define CNT_B2_RESTART_COUNTER 0x0UL Set the value when resetting\n#define CNT_DOUT_A_RESET_VALUE_SHIFT 4 #define CNT_DOUT_B_RESET_VALUE_SHIFT 5 Example: # B2 is to hold and stop counter, while A2 resets value and stops counter. The reset values are both set to 0.\ncnt_set_target_ctrl(dev-\u0026gt;base, CNT_B2_KEEP_VALUE|CNT_B2_STOP_COUNTER |CNT_A2_RESET_VALUE|CNT_A2_STOP_COUNTER|(0\u0026lt;\u0026lt;CNT_DOUT_A_RESET_VALUE_SHIFT)|(0\u0026lt;\u0026lt;CNT_DOUT_B_RESET_VALUE_SHIFT)); Set output bypass # void cnt_set_out_bypass(uint32_t base, uint32_t val) Bypass A or B. A and B will perform the bit operation by default\n#define CNT_OUT_BYPASS_A 0x10000UL #define CNT_OUT_BYPASS_B 0x20000UL Set the logical operation of A, and the result of dout A is the result of the related bit operation of A and B.\n#define CNT_OPT_A_AND\t0x0 #define CNT_OPT_A_OR\t0x1 #define CNT_OPT_A_XOR\t0x2 Set the logical operation of B, and the result of dout B is the result of the related bit operation of A and B\n#define CNT_OPT_B_AND\t0x0 #define CNT_OPT_B_OR\t0x10 #define CNT_OPT_B_XOR\t0x20 "},{"id":23,"href":"/docs/in6xxe/user-guides/driver-integration/crc-guide.html","title":"CRC Guide","section":"Driver Integration","content":" CRC Guide # Overview # CRC (Cyclic Redundancy Check) is a widely used error-detecting code in digital communication networks and storage devices. It is a mathematical algorithm that calculates a checksum based on the data being transmitted or stored, which can then be used to detect errors during transmission or storage.\nFeatures # Support calculate fix length data or variable length data Support DMA(need occupy one I2C DMA channel) Support configuare parameters such as polynomial selection, initial value, XOR output and so on. API # CRC API\n"},{"id":24,"href":"/docs/in6xx/getting-started/testing/debug-guide.html","title":"Debug Guide","section":"Testing and Debuging","content":" Debug Guide # Introduction # Arm Keil MDK (Microcontroller Development Kit) provides robust debugging capabilities that are essential for efficient software development targeting Arm Cortex-M based microcontrollers. This document provides instructions on using the debugging features in Keil.\nDebug Step: # Enter debugging and run to main funtion # Enter debug mode, run program from flash to main function.\nOpen project, double click \u0026ldquo;proj_ble_lp.uvmpw\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click project option button, select \u0026ldquo;J-Link\u0026rdquo; in \u0026ldquo;Debug\u0026rdquo; page. Check the \u0026ldquo;Load Application at Startup\u0026rdquo; and \u0026ldquo;Run to main()\u0026rdquo; option. Click \u0026ldquo;\u0026hellip;\u0026rdquo; button, select script \u0026ldquo;jlink_flash_setup.ini\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click \u0026ldquo;Setting\u0026rdquo; button, select “SW” (single-wire interface) from the drop-down menu of “Port.” Then click “OK” to apply changes. Note:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the “SW Device” column, as illustrated below. If Keil can’t find device, reset DK and click “Scan” to rescan device.\nIf a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nClick \u0026ldquo;start debug\u0026rdquo; button to start debug session. Entering debugging while the program is running # When the program is running, enter debug mode, then halt the CPU at the current instruction.\nClick \u0026ldquo;Setting\u0026rdquo; button, uncheck \u0026ldquo;Reset afger Connect\u0026rdquo;, \u0026ldquo;Verify code Download\u0026rdquo; and \u0026ldquo;Download to Flash\u0026rdquo; option. Click \u0026ldquo;OK\u0026rdquo; button. Uncheck the \u0026ldquo;Load Application at Startup\u0026rdquo; option. Click \u0026ldquo;Edit\u0026rdquo; button, commit out this line \u0026ldquo;Setup_giga();\u0026rdquo; Click \u0026ldquo;OK\u0026rdquo; button. Click \u0026ldquo;start debug\u0026rdquo; button to start debug session. "},{"id":25,"href":"/docs/in6xxe/getting-started/testing/debug-guide.html","title":"Debug Guide","section":"Testing and Debuging","content":" Debug Guide # Introduction # This document provides a guide on how to use keil to debug project to the IN6XXE chip.\nDebug Step: # Enter Debugging # Copy jlink_flash_setup.ini file in in-dev\\proj\\common\\JLINK to project directory\nEdit .ini file with following steps (1) change the setting in jlink_flash_setup.ini according to the in_config.h. (2)change the setup mode according to in_config.h Follow these steps to select the .ini file. Click the debug button. Enter debugging mode, where you can perform simulation debugging. Entering Debugging While the Program Is Running # To enter debugging mode during program execution, please follow these steps:\nRemove the options at 1 and 2, and click Confirm. Remove the options at 1 and 2, and click OK. Edit .ini file. Comment out the Setup section. Click the debug button. Enter debugging mode, where you can see the program\u0026rsquo;s execution position and perform simulation debugging. Note: # Setting breakpoints: Breakpoints are crucial tools in the debugging process, as they allow you to pause execution at specific locations in the program. In Keil, you can set breakpoints by clicking on the line number of the code. When the program reaches the breakpoint, it will automatically pause, enabling you to observe the current variable values and program state.\nStep-by-step execution: Step-by-step execution is a common operation in debugging, allowing the program to execute one line of code at a time. In Keil, you can perform step-by-step execution by clicking the \u0026ldquo;Step\u0026rdquo; button on the toolbar. This helps you observe the execution of the program line by line, identifying potential issues.\nObserving variable values: Observing variable values is crucial during debugging. Keil provides an \u0026ldquo;Watch Window\u0026rdquo; to display variable values in real-time. You can add the variables you want to observe to the Watch Window to view their value changes anytime during debugging.\nRight-click on the variable you need to observe, and click \u0026ldquo;Add to Watch1\u0026rdquo; as shown in the figure. This will allow you to view or modify the value of the variable you are observing in the designated box. Setting a while(debug) {} loop at the beginning of the main function:When the debug variable is set to a non-zero value (in this case, 1), the while(debug) {} loop creates an infinite loop, suspending further program execution. This allows developers to inspect the initial state of the program, including memory contents, register values, peripheral states, and more.\n"},{"id":26,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/ecc-sample.html","title":"ECC Sample","section":"Driver Examples","content":" ECC Sample # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_ECC in-dev/proj/drv/proj_drv_ECC Debug # We can get the status of development board according to Uart Log. The following are samples,\nverify success: Verify OK More information may be found in debug guide page.\nTest Steps # Open Keil and download proj_drv_ECC\nPress the reset button on the board and the peripheral board, observe the text CHIP ID = appear in the log.\nVerify the data using ECC. If verify success, text Verify OK will appear in the log.\n"},{"id":27,"href":"/docs/in6xx/protocol-reference/ble/gatt-programming-guide.html","title":"GATT Programming Guide","section":"BLE","content":" GATT Programming Guide # Overview # GATT is a standard BLE protocol, which is based on the ATT protocol. The ATT protocol describes the structure and the access method of Attribute, the basic data unit of BLE. ATT is equivalent to a base class, while Generic Attribute Profile (GATT) is a derived class. It reorganizes attributes and constructs the structure of data access in the application layer - Service/Characteristic. It defines the methods and mechanisms of the data structures including Discover, Read, Write, and Notify/Indicate.\nGATT is one of the protocols that BLE must support. Inplay provides the following GATT interface APIs.\nint inb_gatt_exc_mtu(int conidx, uint16_t *p_mtu, comp_cb callback); int inb_gatt_sdp(int conidx, int sdp_type, inb_gatt_sdp_t *p_sdp, comp_cb callback); int inb_gatt_discovery(int conidx, int disc_type, inb_gatt_disc_t *p_disc, comp_cb callback); int inb_gatt_read(int conidx, int read_type, inb_gatt_read_req_t *p_req, comp_cb callback); int inb_gatt_write(int conidx, int wrt_type, inb_gatt_write_t *p_write, comp_cb callback); int inb_gatt_excute_write(int conidx, bool execute, comp_cb callback); int inb_gatt_register_ind_ntf_event(int conidx, bool reg, uint32_t start_hdl, uint32_t end_hdl, comp_cb callback); int inb_gatt_indication_cfm(int conidx, uint16_t handle); int inb_gatt_send_ind(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); int inb_gatt_send_ntf(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); int inb_gatt_send_svc_changed(int conidx, uint32_t svc_shdl, uint32_t svc_ehdl, comp_cb callback); int inb_gatt_add_svc(inb_gatt_svc_desc_t *p_svc, uint16_t *p_hdl, comp_cb callback); int inb_gatt_get_svc_perm(uint16_t start_hdl, uint8_t *p_perm, comp_cb callback); int inb_gatt_set_svc_perm(uint16_t start_hdl, uint8_t perm, comp_cb callback); int inb_gatt_get_att_perm(uint16_t handle, inb_att_perm_t *p_perm, comp_cb callback); int inb_gatt_set_att_perm(uint16_t handle, uint16_t perm, uint16_t ext_perm, comp_cb callback); int inb_gatt_get_att_value(uint16_t handle, inb_att_val_t *p_att_val, comp_cb callback); int inb_gatt_set_att_value(uint16_t handle, uint16_t length, uint8_t *value, comp_cb callback); int inb_gatt_att_info_req_cfm(int conidx, uint16_t handle, uint16_t length, uint8_t status); int inb_gatt_write_req_cfm(uint8_t conidx, uint16_t handle, uint8_t status); int inb_gatt_read_req_cfm(uint8_t conidx, uint16_t handle, uint8_t status, uint16_t length, uint8_t *value); Firstly, APIs in SDK can be synchronous or asynchronous calls. That\u0026rsquo;s why almost all APIs above have one common parameter named \u0026ldquo;callback\u0026rdquo;. If \u0026ldquo;callback\u0026rdquo; is NULL, the API will not return until BLE protocol stack has finished processing the request, send the data to or get the response from peer device. Otherwise, it will return immediately only indicating whether the request is acceptable or not. After the request has been processed or executed, the callback will be called then. Since processing the request takes time, the application can utilize this time to perform their own tasks in parallel.\nSimilar to ATT, GATT defines two roles, Server and Client. Server is the one who provides data service and the Client consumes data by read, write, indication or notification methods provided by server. Generally, peripherals who produce data (such as sensor nodes) act as server which creates services, while central devices obtain services and use them (such as sensor values notification). The transparent data transmission service of Inplay is also designed based on this principle.\nInplay Transparent Data Transmission service (proj/common/util/in_trx_svc.c and proj/common/util/in_trx_client.c in SDK) is a common component developed based on GATT. Take it as an example to see the basic usage of these APIs.\nGATT Server # Create Service # The function that creates GATT service is inb_gatt_add_svc, whose prototype is as follows:\n/** **************************************************************************************** * @brief Add a new Service * @note This can only issue by the Server. * * @param[in] p_svc\tPointer to service data structure * @param[out] p_hdl\tService handle * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_add_svc(inb_gatt_svc_desc_t *p_svc, uint16_t *p_hdl, comp_cb callback); p_svc is a pointer to inb_gatt_svc_desc_t that contains all the attributes the service contains typedef struct { /// Attribute Start Handle (0 = dynamically allocated) uint16_t start_hdl; /// Service properties, @see inb_att_svc_prop uint8_t prop; /// Service UUID uint8_t uuid[INB_UUID_128_LEN]; /// Number of attributes uint8_t nb_att; /// List of attribute description present in service. inb_gatt_att_desc_t atts[]; } inb_gatt_svc_desc_t; The members of the structure are assigned as described in the comments. Here in the sample they are:\nstatic const inb_gatt_att_desc_t trx_atts[] = { [TRX_DECL_CHAR_RX] = { .uuid = { 0x03, 0x28 }, .prop = ATT_CHAR_PROP_READ, .max_len = 0, .ext_prop = (0 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CHAR_VAL_RX] = { .uuid = {TRX_RX_UUID }, .prop = ATT_CHAR_PROP_WRITE|ATT_CHAR_PROP_WRITE_NO_RSP, .max_len = TRX_MAX_LEN, .ext_prop = (2 \u0026lt;\u0026lt;ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_DECL_CHAR_TX] = { .uuid = { 0x03, 0x28 }, .prop = ATT_CHAR_PROP_READ, .max_len = 0, .ext_prop = (0 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CHAR_VAL_TX] = { .uuid = {TRX_TX_UUID}, .prop = ATT_CHAR_PROP_NOTIFY | ATT_CHAR_PROP_INDICATE, .max_len = TRX_MAX_LEN, .ext_prop = (2 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CLIENT_CHAR_CFG_TX] = { .uuid = { 0x02, 0x29 }, //INB_ATT_DESC_SERVER_CHAR_CFG, .prop = ATT_CHAR_PROP_READ|ATT_CHAR_PROP_WRITE, .max_len = 0, .ext_prop = 0, }, }; int nb_att = sizeof(trx_atts)/sizeof(trx_atts[0]); inb_gatt_svc_desc_t *p_svc_desc = malloc(sizeof(inb_gatt_svc_desc_t) + nb_att * sizeof(inb_gatt_att_desc_t)); p_svc_desc-\u0026gt;start_hdl = 0;\tp_svc_desc-\u0026gt;prop = (2 \u0026lt;\u0026lt; ATT_SVC_PROP_UUID_LEN_SHIFT);\tmemcpy(p_svc_desc-\u0026gt;uuid, svc_uuid, 16); p_svc_desc-\u0026gt;nb_att = nb_att; memcpy(p_svc_desc-\u0026gt;atts, \u0026amp;trx_atts[0], nb_att * sizeof(inb_gatt_att_desc_t)); As shown above, the Inplay Transparent Data Transmission service contains two main characteristics, representing data input and output respectively. According to the GATT standard, each characteristic must first contain an attribute called Characteristic Declaration with a fixed UUID of 0x2803. In addition, the client can control whether the server can send data by notification or indicatation method. Therefore, for the characteristic of data output, a client characteristic configuration descriptor with a predefined UUID of 0x2902 should be added for the client to enable or disable the server data output.\nThe member prop defines the access method of the attribute, ATT_CHAR_PROP_READ, ATT_CHAR_PROP_WRITE, ATT_CHAR_PROP_NOTIFY, ATT_CHAR_PROP_INDICATE etc, which is clear in meaning by its name. For example, ATT_CHAR_PROP_NOTIFY should be specified for TRX_CHAR_VAL_TX which represents the data output, because TRX_CHAR_VAL_TX depends on the method of Notify. For TRX_CHAR_VAL_RX representing the data input, ATT_CHAR_PROP_WRITE should be specified, which means that the client sends data to the server through the method of GATT Write.\nThe member ext_prop defines some extended attributes. The definitions are shown as follows:\n/** * Extended properties bit field * * Bit [0-11] : Maximum Attribute Length or Value Offset pointer * Bit [12] : Encryption key Size must be 16 bytes * Bit [14-13]: UUID Length (0 = 16 bits, 1 = 32 bits, 2 = 128 bits, 3 = RFU) * Bit [15] : Trigger Read Indication (0 = Value present in Database, 1 = Value not present in Database) */ enum inb_att_ext_prop { /// Maximum Attribute Length ATT_EXT_PROP_MAX_LEN = 0x0FFF, ATT_EXT_PROP_MAX_LEN_SHIFT = 0, /// Attribute value Offset ATT_EXT_PROP_VAL_OFFSET = 0x0FFF, ATT_EXT_PROP_VAL_OFFSET_SHIFT = 0, /// Check Encryption key size Mask ATT_EXT_PROP_EKS = 0x1000, ATT_EXT_PROP_EKS_SHIFT = 12, /// UUID Length ATT_EXT_PROP_UUID_LEN = 0x6000, ATT_EXT_PROP_UUID_LEN_SHIFT = 13, /// Read trigger Indication ATT_EXT_PROP_RI = 0x8000, ATT_EXT_PROP_RI_SHIFT = 15, }; Commonly used bits include ATT_EXT_PROP_UUID_LEN and ATT_EXT_PROP_RI. ATT_EXT_PROP_UUID_LEN defaults to 00, which means that the UUID is 16Bytes instead of 2Bytes (like UUIDs reserved for SIG). It should be noted that if the prop of the attribute TRX_CHAR_VAL_TX is readable, the bit ATT_EXT_PROP_RI must be set in this field.\np_hdl points to unsigned short to retrieve the start attribute handle within service.\ncallback: Same as decription above.\nIn short, the main concern when creating a service is to define the structure of the Characteristic in the service and their accessing method, which will be passed to API inb_gatt_add_svc.\nServer Sending Data # As mentioned above, application defines service structure and the create API returns handler of first attribute within the service. Now handlers of all Characteristic are known. However, what concerns us more is TRX_CHAR_VAL_RX and TRX_CHAR_VAL_TX. More exactly, for the server, only the handle of TRX_CHAR_VAL_TX is needed.\nHandle of TX Characteristic = Start Handle + TRX_CHAR_VAL_TX + 1 The 1 in above formula actually represents the additional attribute \u0026ldquo;Service Declaration\u0026rdquo; in service.\nWith this handler, server can notify or indicate data to client by:\nres = inb_gatt_send_ntf(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); res = inb_gatt_send_ind(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); In above sample, p_srv-\u0026gt;hdl_svc holds the Start handle of service. The first parameter in the API represents a specific connection. After connecting with the other device, the protocol stack will return this value to identify the connection.\nData notification and Indication has differet operations, as refered to GATT protocol:\nServer-initiated updates are the only asynchronous (i.e., not as a response to a client’s request) packets that can flow from the server to the client. These updates send timely alerts of changes in a characteristic value without the client having to regularly poll for them, saving both power and bandwidth. There are two types of server-initiated updates: Characteristic Value Notification\nNotifications are packets that include the handle of a characteristic value attribute along with its current value. The client receives them and can choose to act upon them, but it sends no acknowledgement back to the server to confirm reception. Along with write without response, this is the only other packet that does not comply with the standard request/response flow control mechanism in ATT, as the server can send any number of these notifications at any time. This feature uses the handle value notification (HVN) ATT packet.\nCharacteristic Value Indication\nIndications, on the other hand, follow the same handle/value format but require an explicit acknowledgment from the client in the form of a confirmation. Note that although the server cannot send further indications (even for different character‐ istics) until it receives confirmation from the client (because this flows in the op‐ posite direction than the usual request/response pairs), an outstanding confirma‐ tion does not affect potential requests that the client might send in the meantime. This feature uses the handle value indication (HVI) and handle value confirma‐ tion (HVC) ATT packets.\ninb_gatt_send_ntf implements the above-mentioned function of Characteristic Value Notification. It is called by the server when needed (for example, when the sensor changes) instead of being polled by the client. After being called, it is cached in the ATT protocol stack, and then returns immediately whether the response from the peer ATT layer is received or not.\nAccordingly, inb_gatt_send_ind implements the above-mentioned function of Characteristic Value Indication. The main difference is that each call needs to wait for the response of the peer ATT layer before it can be completed and exit.\nFor example, assume that the parameter of Bluetooth connection is 1s. Call inb_gatt_send_ntf or inb_gatt_send_ind twice during the period. The application osThread that calls inb_gatt_send_ntf can continue to work. At the same time, at the next connection point, the data sent by the two calls can be received by the other side simultaneously. If the connection is suddenly interrupted, the data sent is lost. The thread calling inb_ gatt_ send_ind will get blocked until the next connection point has sent data and received the other party\u0026rsquo;s response successfully. It holds true for the next call. That is, for the same two packets, using inb_gatt_send_ind causes an interval of 2 seconds, but it will ensure that the sent data will not get lost.\nServer Receiving Data # The client sends data by writing TRX_CHAR_VAL_RX characteristic, and the server needs to process GATT_EVT_WRT_REQ messages as follows. In the sample, evt_wrt_req is registered to ble_app component to handle this event.\nstatic void evt_wrt_req(inb_evt_write_req_ind_t* ind, uint8_t* status) { *status = INB_ATT_ERR_INVALID_HANDLE; trx_svr_t *p_svr = \u0026amp;trx_svr; uint16_t handle = ind-\u0026gt;handle - p_svr-\u0026gt;hdl_svc - 1; int res = 0; switch (handle) { case TRX_CHAR_VAL_RX: { p_svr-\u0026gt;conid = ind-\u0026gt;conidx; if (p_svr-\u0026gt;rx_callback) { res = p_svr-\u0026gt;rx_callback(ind-\u0026gt;conidx, ind-\u0026gt;value, ind-\u0026gt;length); if (res == 0) { *status = INB_ERR_NO_ERROR; } else { *status = INB_GATT_ERR_WRITE; } } else { *status = INB_ERR_NO_ERROR; } } break; case TRX_CLIENT_CHAR_CFG_TX: { ... } break; } } void in_trx_svc_cbf(ble_app_cbf_t *p_cbf) { trx_svr_t *p_svr = \u0026amp;trx_svr; //GATT event p_svr-\u0026gt;cbf.gatt.evt_wrt_req = p_cbf-\u0026gt;gatt.evt_wrt_req; p_cbf-\u0026gt;gatt.evt_wrt_req = evt_wrt_req; p_cbf-\u0026gt;gatt.evt_rd_req = evt_rd_req; } Note it\u0026rsquo;s important to set *status to the right value so that ATT protocol will send response to client.\nServer notification enable and disable # There is a configuration attribute (TRX_CLIENT_CHAR_CFG_TX) for data sending, with which the client can enable or disable the server to send data. For example, the sensor is not required to report data at some specific time. Obviously, this attribute is also writing for the client, so it is similar to the server\u0026rsquo;s processing method of receiving data.\nstatic void evt_wrt_req(inb_evt_write_req_ind_t* ind, uint8_t* status) { *status = INB_ATT_ERR_INVALID_HANDLE; trx_svr_t *p_svr = \u0026amp;trx_svr; uint16_t handle = ind-\u0026gt;handle - p_svr-\u0026gt;hdl_svc - 1; int res = 0; switch (handle) { case TRX_CHAR_VAL_RX: { ... } break; case TRX_CLIENT_CHAR_CFG_TX: { p_svr-\u0026gt;conid = ind-\u0026gt;conidx; if (ind-\u0026gt;length == 2) { p_svr-\u0026gt;cfg[ind-\u0026gt;conidx] = *(uint16_t*)ind-\u0026gt;value; *status = INB_ERR_NO_ERROR; } else { *status = INB_GATT_ERR_WRITE; } } break; } } Enable or disable request is stored in variable p_srv-\u0026gt;cfg. When sending data, if it is disabled by client, data is not sent.\nint in_trx_notify(int conidx, uint8_t *buf, uint32_t len, bool ack) { if (len \u0026gt; TRX_MAX_LEN) { return INB_PLT_ERR_INVALID_PARAM; } int res = INB_ATT_ERR_APP_ERROR; trx_svr_t *p_svr = \u0026amp;trx_svr; if (p_svr-\u0026gt;cfg[conidx] \u0026amp; 0x1) { if (ack) res = inb_gatt_send_ind(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); else res = inb_gatt_send_ntf(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); if (res != INB_ERR_NO_ERROR) { PRINTD(DBG_ERR, \u0026#34;in_trx_notify: 0x%x\\n\u0026#34;, res); } } return res; } GATT Client # The client must know the corresponding handle of the attribute in service before any client operations. If both parties in the connection are devices developed by yourself, it means that you are already familiar with the structure of the service, UUID of the service and the starting handle, so this condition is naturally satisfied, and you only need to constantize it in the code. Otherwise, you will need to obtain it through the discover process.\nDiscovering Service by inb_gatt_sdp # This function starts sdp (Service Discover Procedure) in BLE stack and returns result through event. API prototype is as follows\n/** **************************************************************************************** * @brief Service Discovery Procedure * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] sdp_type\tService Discovery Type, @see enum inb_gatt_sdp_type * @param[in] p_sdp\tPointer to service discovery paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_sdp(int conidx, int sdp_type, inb_gatt_sdp_t *p_sdp, comp_cb callback); There are three value for sdp_type: GATT_SDP_DISC_SVC, GATT_SDP_DISC_SVC_ALL, GATT_SDP_DISC_SVC_ALL. Here in the sample, we use GATT_SDP_DISC_SVC, just as the name suggests, discover one certain service.\nstatic int discover_svc(trx_clt_t *p_trx_clt) { int ret=0; uint8_t sdp_buf[sizeof(inb_gatt_sdp_t)+INB_UUID_128_LEN]; //Discover now inb_gatt_sdp_t *p_sdp = (inb_gatt_sdp_t *)sdp_buf; p_sdp-\u0026gt;start_hdl = 1; p_sdp-\u0026gt;end_hdl = 0xFFFF; p_sdp-\u0026gt;uuid_len = INB_UUID_128_LEN; memcpy(p_sdp-\u0026gt;uuid, trx_clt.svc_uuid, INB_UUID_128_LEN); ret = inb_gatt_sdp(p_trx_clt-\u0026gt;peer_conidx, GATT_SDP_DISC_SVC, p_sdp, NULL); return ret; } Not only UUID of the service but also handle range is necessary. The range can be specified as 1~0xFFFF, which means searching all attributes. If the service is not within this handle range, discover fails either.\nAfter service is discovered, GATT_EVT_SDP_SVC event is sent to application. Here in the sample the event is retrieved by registered event handler evt_sdp_svc with ble_app component.\nstatic void evt_sdp_svc(inb_evt_sdp_svc_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt){ PRINTD(DBG_TRACE, \u0026#34;\u0026lt;%s\u0026gt;\u0026lt;%s\u0026gt;: Discover Service (%d, %d)\\r\\n\u0026#34;, MODULE_NAME, __func__, p_ind-\u0026gt;start_hdl, p_ind-\u0026gt;end_hdl); p_trx_clt-\u0026gt;start_hdl = p_ind-\u0026gt;start_hdl; p_trx_clt-\u0026gt;end_hdl = p_ind-\u0026gt;end_hdl; p_trx_clt-\u0026gt;cfg = 1; enable_ntf(p_trx_clt); } ... } int in_trx_clt_add(ble_app_cbf_t *p_cbf, osMessageQId qid, uint8_t svc_uuid[INB_UUID_128_LEN], int (*rx_callback)(int, uint8_t*, int)) { ... //register GATT event handler p_cbf-\u0026gt;gatt.evt_sdp_svc = evt_sdp_svc; return 0; } Finally, the start and end handle of service are retrieved and then inb_gatt_sdp returns.\nDiscovering Service by inb_gatt_discovery # API prototype is as follows:\n/** **************************************************************************************** * @brief Attributes Discovery * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] disc_type\tAttribute discovery type, @see enum inb_gatt_disc_type * @param[in] p_disc\tPointer to attribute discovery paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_discovery(int conidx, int disc_type, inb_gatt_disc_t *p_disc, comp_cb callback); This function provides another option to discovery not only service but single characteristic. In the sample, if we use this function to do service discovery, disc_type should be set to GATT_DISC_BY_UUID_SVC. Other parameters are similar to inb_gatt_sdp.\nAfter service is discovered, GATT_EVT_DISC_SVC event is sent to application. Register another event handler to ble_app component to retrieve discovery result.\nFinally, the start and end handle of service are retrieved and then inb_gatt_discovery returns.\nClient Sending Data # The only way that client sends data to server is via GATT write method. API prototype is as follows:\n/** **************************************************************************************** * @brief Write Attribute * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] wrt_type\tAttribute write type, @see enum inb_gatt_write_type * @param[in] p_write\tPointer to attribute write paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_write(int conidx, int wrt_type, inb_gatt_write_t *p_write, comp_cb callback); The most critical parameter is wrt_type, which corresponds to various write methods in the GATT protocol: GATT_WRITE, GATT_WRITE_NO_RESPONSE, GATT_WRITE_SIGNED, GATT_EXEC_WRITE. Here in the sample the GATT_WRITE or GATT_WRITE_NO_RESPONSE type is used depending on if ack is needed.\nFirst, the Characteristic in service must have write permissions. Reviewing the previous sample service definition, characteristics TRX_CHAR_VAL_RX and TRX_CLIENT_CHAR_CFG_TX have ATT_CHAR_PROP_WRITE permission. The previous attribute corresponds to the direction of the data flow, which is from the client to the server, while the latter is used for the client to control the enabling of data transmission from the server.\nWith the start handle of the service, the client can use the inb_gatt_write interface to send data to the server.\nThe p_write structure contains the parameters of the Write methods, as well as common parameters such as handle, offset and length. Note that for the GATT_WRITE type, the value of the auto_execute parameter is true.\nint in_trx_clt_send(int conidx, bool ack, uint8_t *p_data, uint16_t data_len) { int ret = -1; inb_gatt_write_t *p_write=NULL; trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false) { p_write = (inb_gatt_write_t*)malloc(sizeof(inb_gatt_write_t)+data_len); if (p_write) { p_write-\u0026gt;handle = p_trx_clt-\u0026gt;start_hdl+TRX_CHAR_VAL_RX+1; p_write-\u0026gt;auto_execute = true; p_write-\u0026gt;offset = 0; p_write-\u0026gt;length = data_len; memcpy(p_write-\u0026gt;value, p_data, data_len); ret = inb_gatt_write( p_trx_clt-\u0026gt;peer_conidx, ack ? GATT_WRITE : GATT_WRITE_NO_RESPONSE , p_write, NULL); free(p_write); } } return ret; } static int enable_ntf(trx_clt_t *p_trx_clt) { int ret = -1; inb_gatt_write_t *p_write=NULL; p_write = (inb_gatt_write_t*)malloc(sizeof(inb_gatt_write_t)+2); p_write-\u0026gt;handle = p_trx_clt-\u0026gt;start_hdl+TRX_CLIENT_CHAR_CFG_TX+1; p_write-\u0026gt;auto_execute = true; p_write-\u0026gt;offset = 0; p_write-\u0026gt;length = 2; memcpy(p_write-\u0026gt;value, \u0026amp;p_trx_clt-\u0026gt;cfg, p_write-\u0026gt;length); ret = inb_gatt_write( p_trx_clt-\u0026gt;peer_conidx, GATT_WRITE, p_write, NULL); free(p_write); return ret; } Client Receiving Data # One method for client to get data from server is notification/indication from server. When the server sends data, the client will receive GATT_EVT_NTF or GATT_EVT_IND event. Event handler needs to be registerd to ble_app component to process the data.\nstatic void evt_peer_evt_ntf(inb_evt_ntf_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false \u0026amp;\u0026amp; p_ind-\u0026gt;handle == p_trx_clt-\u0026gt;start_hdl + TRX_CHAR_VAL_TX + 1) { if (trx_clt.trx_clt_rx_cb) trx_clt.trx_clt_rx_cb(p_ind-\u0026gt;conidx, p_ind-\u0026gt;value, p_ind-\u0026gt;length); } //We\u0026#39;v done so let others handle it if (trx_clt.cbf.gatt.evt_peer_evt_ntf) trx_clt.cbf.gatt.evt_peer_evt_ntf(p_ind); } static void evt_peer_evt_ind(inb_evt_ind_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false \u0026amp;\u0026amp; p_ind-\u0026gt;handle == p_trx_clt-\u0026gt;start_hdl + TRX_CHAR_VAL_TX + 1) { if (trx_clt.trx_clt_rx_cb) trx_clt.trx_clt_rx_cb(p_ind-\u0026gt;conidx, p_ind-\u0026gt;value, p_ind-\u0026gt;length); inb_gatt_indication_cfm(p_ind-\u0026gt;conidx, p_ind-\u0026gt;handle); } //We\u0026#39;v done so let others handle it if (trx_clt.cbf.gatt.evt_peer_evt_ind) trx_clt.cbf.gatt.evt_peer_evt_ind(p_ind); } int in_trx_clt_add(ble_app_cbf_t *p_cbf, osMessageQId qid, uint8_t svc_uuid[INB_UUID_128_LEN], int (*rx_callback)(int, uint8_t*, int)) { ... //GATT event p_cbf-\u0026gt;gatt.evt_peer_evt_ntf = evt_peer_evt_ntf; p_cbf-\u0026gt;gatt.evt_peer_evt_ind = evt_peer_evt_ind; ... } The difference between GATT_EVT_NTF and GATT_EVT_IND is an additional inb_gatt_indication_cfm function must be called so that ATT protocol will send response to peer ATT protocol layer. That\u0026rsquo;s why indication is more reliable data transmission of GATT.\nClient can also directly poll data from server by ATT read method to characteristic that allow read access permission. In the sample, we don\u0026rsquo;t grant TRX_CHAR_VAL_TX characteristic read access, which can only be notified and indicated. But TRX_CLIENT_CHAR_CFG_TX characteristic is readable so that client can know if server is allowed notification or not.\n/** **************************************************************************************** * @brief Read Attribute * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] read_type\tAttribute read type, @see enum inb_gatt_read_type * @param[in] p_req\tPointer to attribute read paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_read(int conidx, int read_type, inb_gatt_read_req_t *p_req, comp_cb callback); The actual read result and value are retrived by GATT_EVT_RD_RSP_IND, by registering event handler evt_read_rsp_ind to ble_app component.\nvoid evt_read_rsp_ind(inb_evt_read_rsp_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false \u0026amp;\u0026amp; p_ind-\u0026gt;handle == p_trx_clt-\u0026gt;start_hdl + TRX_CLIENT_CHAR_CFG_TX + 1) p_trx_clt-\u0026gt;cfg = *(uint16_t*)p_ind-\u0026gt;value; } int in_trx_clt_add(ble_app_cbf_t *p_cbf, osMessageQId qid, uint8_t svc_uuid[INB_UUID_128_LEN], int (*rx_callback)(int, uint8_t*, int)) { ... //GATT event p_cbf-\u0026gt;gatt.evt_rd_rsp_ind = evt_read_rsp_ind; return 0; } "},{"id":28,"href":"/docs/in6xxe/user-guides/driver-integration/gpio-guide.html","title":"GPIO Guide","section":"Driver Integration","content":" GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:\nDigital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to \u0026ldquo;proj_drv_gpio\u0026rdquo;.\nConfigure GPIO to output and output high/low:\nint level = 0; hal_gpio_cfg_output(port, poin); hal_gpio_output(port, poin, level); Configure GPIO to input and get input value:\nint level; hal_gpio_cfg_input(port, poin, GPIO_PULL_UP); level = hal_gpio_input_status(port, poin); Interrupt # Each pin in one group share the same interrupt. Supports falling edge, rising edge and both edge.\nRefer to \u0026ldquo;proj_drv_gpio_interrupt\u0026rdquo;.\nConfigure interrupt for falling edge and rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_NO_PULL); hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 1, 1, 0); Wake up # All pins can be configured to wake up the chip by high level, low level, falling edge, rising edge, and both edges.\nRefer to \u0026ldquo;proj_drv_gpio_wup\u0026rdquo;.\nConfigure to wake up by rising edge:\nhal_gpio_cfg_input(port, pin, GPIO_PULL_DOWN); hal_gpio_cfg_wup_edge(port, pin, 1, 0); To output in sleep mode, set latch to 1:\n//output high in deep sleep and wake up hal_gpio_cfg_output(port, pin); hal_gpio_output(port, pin, 1); hal_gpio_sleep_pad_latch(port, pin, 1, 0); Wake up and get interrupt # After waking up, it can generate interrupt.\nRefer to \u0026ldquo;proj_drv_gpio_wup_interrupt\u0026rdquo;\n/// interrupt /// falling edge , wake up en hal_gpio_ext_int_prio(port, IRQ_PRI_Normal); hal_gpio_ext_int_reg(port, pin, NULL, gpio_intr_cb); hal_gpio_ext_int_unmask(port, pin, 0, 1, 1); /// wake up by edge ///\tfalling edge hal_gpio_cfg_wup_edge(port, pin, 0, 1); Reset chip/CPU # GPIO pin can be configured to reset the chip/CPU by falling edge or rising edge.\nRefer to \u0026ldquo;proj_drv_gpio_reset\u0026rdquo;.\nReset chip by falling edge\nhal_gpio_cfg_input(port, pin, GPIO_PULL_UP); hal_gpio_reset_chip(port, pin, port, pin, 1, 16); "},{"id":29,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-interrupt-sample.html","title":"GPIO Interrupt Sample","section":"Driver Examples","content":" GPIO Interrupt Sample # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.\n#define GPIO_INTERRUPT_EDGE RISE_EDGE Define the edge-trigger signal for GPIO interrupts, including RISE_EDGE and FALL_EDGE. RISE_EDGE represents an interrupt when the GPIO input has a rising edge, while FALL_EDGE represents an interrupt when the GPIO input has a falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur rise:... fall:... wup:... mains the gpio interrupt source. More information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO interrupt pin. Download the proj_drv_gpio_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, rise:... fall:... wup:... will be printed. In this example, due to the presence of the mask function in the callback, the interrupt will only be triggered once. "},{"id":30,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-reset-sample.html","title":"GPIO Reset Sample","section":"Driver Examples","content":" GPIO Reset Sample # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_reset in-dev/proj/driver/proj_drv_gpio_reset Configuration # #define GPIO_RESET_TEST_PORT 1 #define GPIO_RESET_TEST_PIN 2 Define the GPIO reset port and pin.\n#define RESET_EDGE RISING_EDGE Define the triggering of a GPIO reset signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. 1 means rising edge, 0 means falling edge.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nWaiting for reset signals: Input pin is GPIO1_2 Wait for falling edge to trigger PD1 reset reset success:CHIP ID = ...\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO reset pin and edge, then download proj_drv_GPIO_RESET. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that we reset development board suceess. "},{"id":31,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-sample.html","title":"GPIO Sample","section":"Driver Examples","content":" GPIO Sample # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.\nIn this example, we can achieve basic input and output functionality using GPIO.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.\n#define KEY_PORT 2 #define KEY_PIN 3 Define the GPIO input port and pin.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nLED cycle flashing when the GPIO_2_3 put up, the message KEY up will be printed. More information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO output pin and input pin, then download proj_drv_GPIO. Press the reset button and observe the log for the message CHIP ID =. Repeat the LED on/off cycle. If the GPIO input pin is high, the message KEY up will be printed. "},{"id":32,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-interrupt-sample.html","title":"GPIO Wake Interrupt Sample","section":"Driver Examples","content":" GPIO Wake Interrupt Sample # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk_interrupt in-dev/proj/driver/proj_drv_gpio_wuk_interrupt Configuration # #define PORT 2 #define PIN 3 Define the port and pin for testing GPIO wake-up and interrupts.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio according to Uart Log. The following are samples,\ngpio interrupt occur interrupt occur\nWake up power up src=\nPower down power down\nMore information may be found in debug guide page.\nTest Steps # Open Keil and select the GPIO wake-up and interrupt pin. Download the proj_drv_gpio_wuk_interrupt project. Press the reset button and observe the log for the text CHIP ID =. Toggle the light on and off. When the corresponding edge signal is detected on the GPIO input pin, power up src=andinterrupt occur will be printed. "},{"id":33,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-sample.html","title":"GPIO Wake Sample","section":"Driver Examples","content":" GPIO Wake Sample # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.\n#define WUP_TRIGGER FALLING_EDGE // wake up source Define the triggering of a GPIO wake signal, it can be either on the rising edge or the falling edge, depending on the system design and requirements. The following enum is the mode can be chosen\nenum{ HIGH, LOW, RISING_EDGE, FALLING_EDGE, BOTH_EDGE, }; Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log and LED. The following are samples,\nPower down: power down Wake up:power up src=23. number 23 means wake-up source, we can find its meaning in pm_ws.\nMore information may be found in debug guide page.\nTesting Steps # Open Keil and select the GPIO wake-up pin and edge, then download proj_drv_gpio_wuk. Press the reset button and observe the log for the message CHIP ID =. Input signal in set pin, we can find that development board wake up successfully. "},{"id":34,"href":"/docs/in6xx/getting-started/testing/hci_command.html","title":"HCI Command","section":"Testing and Debuging","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Note: HCI command is in hexadecimal, not ASCII characters. If you are using a serial tool to send the HCI command, make sure to set it to HEX mode for both sending and receiving. For example, in this document, \u0026ldquo;0x12\u0026rdquo; represents one byte with the value 0x12. Please do not enter \u0026lsquo;0\u0026rsquo;, \u0026lsquo;x\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo; as four separate bytes.\nCommand Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # Table 1\npacket type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 2\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding HCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,0x04, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 0x06, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 2\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x04, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: Don\u0026rsquo;t change TX power setting. 0x1 ~ 0x7F: PA gain. Note:\nSuggest set TX gain to 0x0, and use \u0026quot;Set TX Power\u0026quot; command to set TX power. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x05, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x08, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;, \u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\npacket number: TX packet number, 0 is TX forever. Note: If packet number is not 0, current is a little higher.\nComplete Event:0x04, 0x0E, 0x04, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nVendor TX end # Stop TX and send back TX packets, Command: 0x01, 0x53, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x53, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\npacket number: TX packet number Set Cap # Set XO cap Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF. And 0xFF means use default value. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap # Save XO cap value to flash Command: 0x01, 0x08, 0xFC, 0x00 Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3. Commands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 01, 0x04, 0x07, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number Set TRX Enable Pin # Command: 0x01, 0x44, 0xFC, 0x06, \u0026lt;bias port\u0026gt; \u0026lt;bias pin\u0026gt;, \u0026lt;tx en port\u0026gt;, \u0026lt;tx en pin\u0026gt;,\u0026lt;rx en port\u0026gt;, \u0026lt;rx en pin\u0026gt;\nbias port: PA bias port, set to 0xFF if it is invaild bias pin: PA bias pin, set to 0xFF if it is invaild tx en port: TX enable port tx en pin: TX enable pin rx en port: RX enable port rx en pin: RX enable pin Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x44, 0xFC, \u0026lt;status\u0026gt; Save Configuration # Save PA and tx power configuration to flash.\nCommand: 0x01, 0x57, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x57, 0xFC, \u0026lt;status\u0026gt; Use Default Configuration # Use default PA and tx power configuration, clear the setting on flash.\nCommand: 0x01, 0x58, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x58, 0xFC, \u0026lt;status\u0026gt; GPIO Output # Command: 0x01, 0x0B, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;output\u0026gt;\nport: GPIO port pin: GPIO pin output: GPIO output, 1 is high and 0 is low Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0B, 0xFC, \u0026lt;status\u0026gt; GPIO input # Command: 0x01, 0x0C, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;pull\u0026gt;\nport: GPIO port pin: GPIO pin pull: 0 is no pull up/down, 1 is pull up and 2 is pull down Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0C, 0xFC, \u0026lt;status\u0026gt; \u0026lt;GPIO input\u0026gt;\nGPIO input: 1 is high and 0 is low Get ADC sample # Command: 0x01, 0x43, 0xFC, 0x02, \u0026lt;ADC channel\u0026gt;, \u0026lt;parameter\u0026gt;\nADC channel: ADC channel\nparameter: If ADC channel is not 13, set this to 0x0. If ADC channel is 13, this value is register pmu_test_mux_ctrl[0:7]. Complete Event: 0x04, 0x0E, 0x08, 0x01, 0x43, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;Sample raw data byte 0\u0026gt;, \u0026lt;Sample raw data byte 1\u0026gt; \u0026lt;Sample converted data byte 0\u0026gt;, \u0026lt;Sample converted data byte 1\u0026gt;\nSample raw data: 16 bits ADC sample raw data.\nSample converted data: 16 bits converted data in millivolt.\nStart PWM # Start PWM Command: 0x01, 0x09, 0xFC, 0x09, \u0026lt;pwm id\u0026gt;, \u0026lt;period byte 0\u0026gt;, \u0026lt;period byte 1\u0026gt;, \u0026lt;period byte 2\u0026gt;, \u0026lt;period byte 3\u0026gt;, \u0026lt;high byte 0\u0026gt;, \u0026lt;high byte 1\u0026gt;, \u0026lt;high byte 2\u0026gt;, \u0026lt;high byte 3\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nperiod: PWM period, count in microsecond\nhigh: PWM high time, count in microsecond\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Stop PWM Command: `0x01, 0x0A, 0xFC, 0x00` Complete Event: `0x04, 0x0E, 0x04, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;` Set RTC32K Output # Output RTC32K signal on specail GPIO. Available pins are GPIO_0_2, GPIO_0_6, GPIO_1_0, GPIO_1_4, GPIO_1_8, GPIO_3_3 and GPIO_4_3. Command: `0x01, 0x46, 0xFC, 0x03, \u0026lt;enable\u0026gt;, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;` enable: 1 is enable, and 0 is disable\nport: GPIO port\npin: GPIO pin\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x46, 0xFC, \u0026lt;status\u0026gt;\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nI2C Read Register # I2C read register as master Command: `0x01, 0x59, 0xFC, 0x03, \u0026lt;i2c_id\u0026gt;, \u0026lt;slv_addr\u0026gt;, \u0026lt;reg_addr\u0026gt;` i2c_id: I2C id, 0 or 1. I2C 0 use GPIO0_0 and GPIO0_1, I2C 1 use GPIO4_0 and GPIO4_1.\nslv_addr: I2C slave address\nreg_addr: register address\nComplete Event: 0x04, 0x0E, 0x04, 0x02, 0x59, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;reg_val\u0026gt;\nreg_val: register value\nGet RTC clock # Get RTC clock Command: `0x01, 0x5A, 0xFC, 0x00` Complete Event: `0x04, 0x0E, 0x04, 0x01, 0x5A, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;rtc_clk byte 0\u0026gt;, \u0026lt;rtc_clk byte 1\u0026gt;, \u0026lt;rtc_clk byte 2\u0026gt;, \u0026lt;rtc_clk byte 3\u0026gt;` rtc_clk: RTC clock in HZ. Note: RTC need 1 second for calibration. Must wait for 1 second after power on, then run this command. Deep Sleep # Go to deep sleep mode Command: `0x01, 0x55, 0xFC, 0x04, \u0026lt;sleep_time byte 0\u0026gt;, \u0026lt;sleep_time byte 1\u0026gt;, \u0026lt;sleep_time byte 2\u0026gt;, \u0026lt;sleep_time byte 3\u0026gt;` sleep_time: sleep time in millisecond, must larger then 10. Chip will wake up after sleep_time.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x55, 0xFC, \u0026lt;status\u0026gt;\nUser Ddefined Command # Run user defined command. Command: `0x01, 0x47, 0xFC, 0x04, \u0026lt;para0\u0026gt;, \u0026lt;para1\u0026gt;, \u0026lt;para2\u0026gt;, \u0026lt;para3\u0026gt;` para0: parameter 0.\npara1: parameter 1.\npara2: parameter 2.\npara3: parameter 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x47, 0xFC, \u0026lt;status\u0026gt; \u0026lt;res byte0\u0026gt; \u0026lt;res byte1\u0026gt; \u0026lt;res byte2\u0026gt; \u0026lt;res byte3\u0026gt;\nres: return value of user defined function\nThe following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x05, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x06, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq offset code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x42, 0xFC, \u0026lt;status\u0026gt;\n"},{"id":35,"href":"/docs/in6xxe/getting-started/testing/hci_command.html","title":"HCI Command","section":"Testing and Debuging","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Command Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # Table 1\npacket type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 2\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding Table 3\ntx power: Value TX Power 0x00 Max Power 0x01 7dBm 0x02 6.5dBm 0x03 6dBm 0x04 5.5dBm 0x05 5dBm 0x06 4.5dBm 0x07 4dBm 0x08 3.5dBm 0x09 3dBm 0x0A 2.5dBm 0x0B 2dBm 0x0C 1.5dBm 0x0D 1dBm 0x0E 0.5dBm 0x0F 0dBm 0x10 -1dBm 0x11 -2dBm 0x12 -3dBm 0x13 -4dBm 0x14 -5dBm 0x15 -6dBm 0x16 -8dBm 0x17 -10dBm 0x18 -12dBm 0x19 -16dBm 0x1A -20dBm 0x1B -43dBm HCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,0x04, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 0x06, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 2\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x04, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: Don\u0026rsquo;t change TX power setting. 0x1 ~ 0x7F: PA gain. Note:\nSuggest set TX gain to 0x0, and use \u0026quot;Set TX Power\u0026quot; command to set TX power. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x05, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x08, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;, \u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\npacket number: TX packet number, 0 is TX forever. Note: If packet number is not 0, current is a little higher.\nComplete Event:0x04, 0x0E, 0x04, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nVendor TX end # Stop TX and send back TX packets, Command: 0x01, 0x53, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x53, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\npacket number: TX packet number Set Cap # Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap to Flash # Command: 0x01, 0x08, 0xFC, 0x01, \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3.\nCommands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 to 0x1A. Please refer to Table 3. Complete Event: 0x04, 0x0E, 01, 0x04, 0x07, 0xFC, \u0026lt;status\u0026gt;\nSet TX Gain # Command: 0x01, 0x51, 0xFC, 0x00, \u0026lt;TX Gain\u0026gt;\nTX Gain: TX gain, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power Table # Command: 0x01, 0x52, 0xFC, 0x00, \u0026lt;TX Power Table\u0026gt;\nTX Power Table: Range is 0x01 ~ 0x04. Default is 0x1. Table 1 is for low power mode. And table 4 is for high power mode. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x5B, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x5B, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number Set TRX Enable Pin # Command: 0x01, 0x44, 0xFC, 0x06, \u0026lt;bias port\u0026gt; \u0026lt;bias pin\u0026gt;, \u0026lt;tx en port\u0026gt;, \u0026lt;tx en pin\u0026gt;,\u0026lt;rx en port\u0026gt;, \u0026lt;rx en pin\u0026gt;\nbias port: PA bias port, set to 0xFF if it is invaild bias pin: PA bias pin, set to 0xFF if it is invaild tx en port: TX enable port tx en pin: TX enable pin rx en port: RX enable port rx en pin: RX enable pin Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x44, 0xFC, \u0026lt;status\u0026gt; GPIO Output # Command: 0x01, 0x0B, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;output\u0026gt;\nport: GPIO port pin: GPIO pin output: GPIO output, 1 is high and 0 is low Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0B, 0xFC, \u0026lt;status\u0026gt; GPIO input # Command: 0x01, 0x0C, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;pull\u0026gt;\nport: GPIO port pin: GPIO pin pull: 0 is no pull up/down, 1 is pull up and 2 is pull down Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0C, 0xFC, \u0026lt;status\u0026gt; \u0026lt;GPIO input\u0026gt;\nGPIO input: 1 is high and 0 is low Get ADC sample # Command: 0x01, 0x43, 0xFC, 0x02, \u0026lt;ADC channel\u0026gt;, \u0026lt;parameter\u0026gt;\nADC channel: ADC channel\nparameter: If ADC channel is not 13, set this to 0x0. If ADC channel is 13, this value is register pmu_test_mux_ctrl[0:7]. Complete Event: 0x04, 0x0E, 0x08, 0x01, 0x43, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;Sample raw data byte 0\u0026gt;, \u0026lt;Sample raw data byte 1\u0026gt; \u0026lt;Sample converted data byte 0\u0026gt;, \u0026lt;Sample converted data byte 1\u0026gt;\nSample raw data: 16 bits ADC sample raw data.\nSample converted data: 16 bits converted data in millivolt.\nStart PWM # Command: 0x01, 0x09, 0xFC, 0x01, \u0026lt;pwm id\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Command: 0x01, 0x0A, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;\nSet RTC32K Output # Command: 0x01, 0x46, 0xFC, 0x03, \u0026lt;enable\u0026gt;, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt; Output RTC32K signal on specail GPIO. Available pins are GPIO_0_2, GPIO_0_6, GPIO_1_0, GPIO_1_4, GPIO_1_8, GPIO_3_3 and GPIO_4_3.\nenable: 1 is enable, and 0 is disable\nport: GPIO port\npin: GPIO pin\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x46, 0xFC, \u0026lt;status\u0026gt;\nEnter Deep Sleep # Command: `0x01, 0x54, 0xFC, 0x00` Enter deep sleep mode, Complete Event: `0x04, 0x0E, 0x04, 0x01, 0x54, 0xFC, \u0026lt;status\u0026gt;` The following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x05, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x06, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nMeasure XO # Command: 0x01, 0x35, 0xFC, 0x02, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt; Measure DUT XO by PWM signal.\nport: DUT PWM port. pin: DUT PWM pin. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x35, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;ppm byte0\u0026gt;, \u0026lt;ppm byte1\u0026gt; -ppm: if ppm \u0026gt; 0, DUT clock is faster then tester clock. If ppm \u0026lt; 0, DUT clock is slower then tester clock.\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq offset code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x42, 0xFC, \u0026lt;status\u0026gt;\nGet HW ID # Get hardware ID Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x5B, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;id byte 0\u0026gt;, \u0026lt;id byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;id byte 3\u0026gt;\nid: 32bit HW ID "},{"id":36,"href":"/docs/in6xxe/examples-and-use-case/misc/hci-sample.html","title":"HCI Sample","section":"Misc Examples","content":" HCI Sample # Overview # HCI, as the Host Controller Interface, is a crucial component of the Bluetooth protocol stack. This interface lies within the hardware section of the Bluetooth communication module, providing a standardized communication mechanism between the host and controller elements of a Bluetooth device.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_ate_test_hci proj_ate_test_hci_no_os in-dev/proj/misc/proj_ate_test_hci in-dev/proj/misc/proj_ate_test_hci_no_os Configuration # #define EXT_PA 0 ///\u0026lt; 0: diable external PA, 1: enable external PA Define if use PA control. 0: diable external PA, 1: enable external PA\n#define BIAS_PORT 1 ///\u0026lt; external PA bias port #define BIAS_PIN 3 ///\u0026lt; external PA bias pin Define the Bias pin. If don\u0026rsquo;t use Bias pin, set it to 0xff\n#define TX_EN_PORT 1 ///\u0026lt; external PA TX EN port #define TX_EN_PIN 4 ///\u0026lt; external PA TX EN pin Define the Tx_en pin.\n#define RX_EN_PORT 2 ///\u0026lt; external PA RX EN port #define RX_EN_PIN 3 ///\u0026lt; external PA RX EN pin Define the Rx_en pin.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can enter command on GPIO_2_7, and get the status on GPIO_2_1. **Remember to set hex send and receive when testing HCI command.**The following are samples:\ncommand sent: 01030c00\nstatus received: 04 0E 04 01 03 0C 00\nMore information may be found in debug guide page. More information and command can be found in HCI Command.\nTest Steps # Open Keil and set EXT_PA to be 1 if needed, download proj_ate_test_hci_no_os. Press reset button and observe the text \u0026ldquo;main start\u0026rdquo; appear in the log. Send HCI command and we can get status on UART1. "},{"id":37,"href":"/docs/in6xxe/user-guides/driver-integration/i2c-guide.html","title":"I2C Communication","section":"Driver Integration","content":" I2C Guide # Overview # I2C (Inter-Integrated Circuit) is a simple serial communication protocol commonly used to connect microcontrollers with various electronic devices such as sensors and memories. It utilizes only two wires: a clock line (SCL) for synchronizing data transfer and a data line (SDA) for sending and receiving data. Key Features # Multi-Master Capability: Multiple masters can be connected to the same bus and communicate with different slave devices. Hardware Address Detection: Each device on the I2C bus has a unique address, allowing for easy identification and communication. Arbitration and Synchronization: The I2C protocol includes mechanisms for arbitration and synchronization, ensuring reliable data transfer even when multiple masters are present on the bus. Software Addressable: The I2C protocol supports software-addressable devices, allowing for flexible configuration and dynamic address assignment. I2C Bus Topology # The I2C bus consists of two main components:\nMaster Device: The master device initiates and controls the communication on the I2C bus. It generates the clock signal and determines which slave device to communicate with. Slave Device: Slave devices are peripheral devices that respond to requests from the master device. They can transmit or receive data based on the master\u0026rsquo;s instructions. The SDA (Serial Data) line is used for bidirectional data transfer, while the SCL (Serial Clock) line is used for synchronizing the data transfer between the master and slave devices.\nInitialization # Refer to \u0026ldquo;proj_drv_I2C_master/proj_drv_I2C_slave\u0026rdquo;.\nConfigure I2C settings according to the i2c_init_t struct.\ni2c_init_t init = {0}; init.prio = IRQ_PRI_Normal; /**\u0026lt; Interrupt priority */ init.speed = I2C_SPEED_100K; /**\u0026lt; I2C speed (more selections can be found in i2c_speed) */ init.arg = NULL; /**\u0026lt; Argument to be used in the callback */ init.callback = I2C_cb; /**\u0026lt; I2C callback after I2C operation is finished */ i2c_dev = hal_i2c_open(I2C0_ID, \u0026amp;init); /**\u0026lt; I2C0_ID can be replaced with I2C1_ID. If changed, update the setting in config.h */ I2C Master # Clock Generation: The master is responsible for generating the SCL (Serial Clock) signal, which synchronizes data transmission. Data Transfer Control: The master controls the start and end of data transmission by sending START and STOP signals. Device Addressing: Before data transmission, the master sends a 7-bit or 10-bit device address along with a read/write bit (R/W=1 for read, R/W=0 for write) to specify the intended operation. Master Read # res = hal_mi2c_read(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C master read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_mi2c_read_dma(hdl, tar, buffer, cmd_buf, buffer_len, poll, tmo); /** * @brief I2C master read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ Master Write # res = hal_mi2c_write(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C master write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_mi2c_write_dma(hdl, tar, buffer, buffer_len, cmd_buf, poll, tmo); /** * @brief I2C master write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ I2C Slave # Data Reception and Transmission: Once addressed by the master, the slave receives or transmits data based on the master\u0026rsquo;s instructions. Slave Read # res = hal_si2c_read(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_si2c_read_dma(hdl, tar, buffer, cmd_buf, buffer_len, poll, tmo); /** * @brief I2C slave read * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ Slave Write # res = hal_si2c_write(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ res = hal_si2c_write_dma(hdl, tar, buffer, buffer_len, poll, tmo); /** * @brief I2C slave write * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @param[in] tar The slave address. * @param[in] buffer The pointer to the received buffer. * @param[out] cmd_buf I2C DMA command buffer. * @param[in] buffer_len The receive buffer length. * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout in ms. * * @note Get more information in hal_i2c.h. When poll is set to 1, interrupts and callbacks will not be used. If tmo is set to 0, a callback must be configured. * @return @see enum i2c_error for the possible return code. */ "},{"id":38,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/i2c-sample.html","title":"I2C Sample","section":"Driver Examples","content":" I2C Sample # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.\nThis routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication. It enables serial communication of data between different development boards. The UART port prints the LOG, showing the data transmission and retrieval between the I2C Master and I2C Slave.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_I2C in-dev/proj/driver/proj_drv_I2C Configuration # #define TEST_CASE I2C_TEST_MASTER_XFER_BLOCKING_READ You can change the operation mode.\nAvailable modes for Master # I2C_TEST_MASTER_XFER_BLOCKING_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_READ I2C_TEST_MASTER_XFER_POLL_READ I2C_TEST_MASTER_XFER_BLOCKING_WRITE I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE I2C_TEST_MASTER_XFER_POLL_WRITE I2C_TEST_MASTER_XFER_BLOCKING_WRITE_READ I2C_TEST_MASTER_XFER_BLOCKING_DMA_WRITE_READ I2C_TEST_MASTER_XFER_POLL_WRITE_READ I2C_TEST_MASTER_XFER_ASYNC Slave mode # I2C_TEST_SLAVE_XFER #define I2C_SLAVE_ADDR 0x14 Set the address of the slave device in I2C communication.\n#define I2C_SPEED I2C_SPEED_100K Set the speed of the I2C communication.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both master and slave according to Uart Log and LED.\nWhen we transmit or receive data, we can get information on uart log. More information may be found in debug guide page.\nTest Steps # Master Setup and Download Open Keil, change the selected mode to master, compile, and download the project. Press the reset button and observe the LOG to see the text \u0026ldquo;master_xfer_blocking_read dma_en=0\u0026rdquo;, which represents the selected mode. Slave Setup and Download Open Keil, change the selected mode to slave, compile, and download the project. Press the reset button and observe the LOG to see the text which represents the selected mode., Testing Reset the slave first, then reset the master. We can see the data appearing in the LOG based on the selected mode of the master. After resetting both the slave and the master, we can observe the data appearing in the LOG based on the selected mode of the master. "},{"id":39,"href":"/docs/in6xx/getting-started/download/in_prog-guide.html","title":"InPlay Programmer Guide","section":"Download Image","content":" InPlay Programmer Guide # Introduction # The InPlay Programmer is a graphical chip configuration and programming tool for the PC that enables developers to configure and download programs to target boards using InPlay chips via UART. Developers should refer to the chip datasheet to thoroughly understand the configuration options based on their specific application requirements.\nThe main window of the GUI tool, as shown in Figure 1, is organized into five area:\nData communication interface selection and configuration area Application download area HCI FW configuration area Device configuration area Register/eFuse read-write area Efuse configuration area Authentication and encryption configuration area Note: All numbers entered in input fields are in hexadecimal format, and you do not need to include the \u0026ldquo;0x\u0026rdquo; prefix. For example, to set the address to \u0026ldquo;0x300000\u0026rdquo;, simply enter \u0026ldquo;300000\u0026rdquo;.\nUART Download # Prerequisites # Connect the DK board’s UART port to the PC. Set the chip to boot mode. Boot Mode # The chip has two modes: boot mode and normal mode. In boot mode, it can be configured and programmed via UART/JLink, while in normal mode, the chip runs the program already downloaded to it. A GPIO pin can be configured as the boot pin in software, and the chip will check the GPIO level at power-on to determine whether to enter boot mode. In the SDK\u0026rsquo;s demo project, GPIO2_6 is set as the default boot pin. If the chip has no loaded program (i.e., a blank chip), it will automatically enter boot mode on power-up. If a program is already loaded, ground the boot pin and then power cycle or reset the chip to enter boot mode. Connecting to the UART (Area 1) # Click on \u0026ldquo;Uart\u0026rdquo; in area 1 to automatically scan for UART ports on the PC. Select the DK board’s port from the dropdown list under \u0026ldquo;Port.\u0026rdquo; The program sets the baud rate to 115200 by default. Click Connect. If the connection is successful, a dialog will appear. The program will continue attempting to connect for up to five minutes. To cancel, close and reopen the program. Program Download (Area 2) # Ensure that BootRAM is checked in area 2. Click Browse to select the application binary file. Verify the Address is set to 0x300000. The program will automatically calculate the size; no adjustments are needed. Click Download. A dialog will appear upon successful download. Data File Download (Area 2) # Some programs may require downloading data files, such as calibration data or tokens/UUIDs, to specific locations. This step can be done after downloading the application binary file. Note: If no program has been downloaded previously, data files cannot be downloaded directly.\nUncheck Bootram. Click Browse to select the binary file containing the data. Set the Addr as required; for example, to load data at 0x37E000, set the address to 37E000. Size will be set automatically, but it can be adjusted as needed. Click Download. HCI Firmware Configuration (Area 3) # This section configures the HCI Firmware, including HCI Firmware\u0026rsquo;s UART, PA, and TX Power settings.\nHCI UART # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, UART 1 uses GPIO2_1 and GPIO2_7. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the UART ID, which can be either 0 or 1. Configure the TX Port and TX Pin. UART 0 allows GPIO0_2 or GPIO2_3, while UART 1 allows GPIO2_1 or GPIO1_7. Configure the RX Port and RX Pin. UART 0 allows GPIO1_0 or GPIO2_5, while UART 1 allows GPIO2_7 or GPIO1_8. PA Pin # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, no PA Pin is set. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the TX_EN Port, TX_EN Pin, RX_EN Port, RX_EN Pin, Bias Port, and Bias Pin. If a pin is not to be configured, set both Port and Pin to \u0026ldquo;FF\u0026rdquo;. TX Power # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, the TX Power is set to 0x18 (0dBm). To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the TX Power, which ranges from 0x0 to 0x7F. Boot Pin # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, the boot pin is GPIO2_6. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set port. Set pin. Generate Bin File # Must click the browse button (Area 2) to select the original bin file first.\nThen if you click \u0026ldquo;Download\u0026rdquo; bnutton, the configuration will be written into the flash but will not modify the original bin file. If you need to download it again, you must configure it again.\nClicking the \u0026ldquo;Generate Bin\u0026rdquo; button will create a bin file with the configured information. And it will not modify the original bin file. If download the generated bin file, don\u0026rsquo;t need to configure the HCI Firmware Configuration (Area 3). Just select all \u0026ldquo;Default Config\u0026rdquo; options.\nDevice Configuration (Area 4) # This section is used to configure device-related information, which will be stored separately at address 0x37F000. Therefore, if the configuration has already been set and downloaded, there is no need to configure it again for subsequent downloads.\nNote: Make sure to check \u0026ldquo;Device Config\u0026rdquo; in the SwiftConfigTool for this configuration to take effect.\nXO Cap # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. The default values are set in SwiftConfigTool. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the cap value, which ranges from 0x0 to 0xF. BD Address # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. The default values are set in SwiftConfigTool. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the BD address. Troubleshooting # DK board’s UART port not listed:\nUncheck UART, then re-check it to rescan for UART ports. Connection fails upon clicking Connect:\nEnsure the port is not occupied by another program. No success dialog after clicking Connect:\nVerify the selected port is correct. Confirm that the chip is in boot mode. Disconnect all connections to the chip, such as UART and JLink connections. Then pull down boot pin and reset the chip. After that, reconnect the serial port to the chip and click \u0026ldquo;Connect.\u0026rdquo; Download fails upon clicking Download:\nEnsure the correct binary file is selected. Verify Bootram is checked. Confirm Addr and Size settings are correct. Data file download fails upon clicking Download:\nVerify the correct binary file is selected. Ensure Bootram is unchecked. Confirm Addr and Size settings are correct. "},{"id":40,"href":"/docs/solutions/multiconnnet/introduction.html","title":"Introduction","section":"MultiConnNet","content":" Introduction to MultiConnNet System # The MultiConnNet is Inplay\u0026rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.\nThe system is comprised of two primary components: the gateway module and the node module.\nKey Features # Star Topology: The system employs a star connection model, with the gateway serving as the central node for bidirectional communication with multiple node modules, facilitating management and data transmission.\nMulti-Node Connectable: The MultiConnNet supports up to 128 nodes in network, making it suitable for large-scale deployments and meeting diverse application needs. Besides, all the nodes is connectable, which offers high reliability and data integrity on specific application.\nBidirectional Data Transmission: The system enables bidirectional data transmission, ensuring real-time communication between nodes and the gateway, which is ideal for applications requiring quick responses.\nPrivate SDR Protocol: Based on a private SDR protocol, the system offers greater flexibility and customization, allowing optimization according to specific requirements to enhance communication efficiency.\nSpectrum Utilization: Operating in the 2.4GHz frequency band, it effectively utilizes existing wireless spectrum resources, making it suitable for various indoor and outdoor environments.\nLow Power Node module can be in low power mode that allows them to run on battery power for several years. This makes them particularly suitable for remote or hard-to-reach environments in IoT application.\nGlossary of Acronyms and Important Terms # Access Address: All low level packets include the 4 octets Access Address, which is used to identify communications on a physical channel, and to exclude or ignore packets on different physical channels that are using the same PHY channels in physical proximity. This ensures that the transmission is indeed meant for the device that is receiving it.\nDevice Address: Each device in the MultiConnNet has its own 2 octets Device Address, which is used as source/target addresses for communication between the gateway and each node.\nGateway: The Gateway is the center device of the network, connecting and managing the surrounding node devices. It can connect up to 128 nodes simultaneously, operating at full capacity without entering a low-power sleep mode.\nNode: Node is peripheral device that connect to the network where the gateway is located after logging in. The nodes operate in a low-power state.\nPeriodic Advertising: Gateway sends periodic advertisement packets at regular intervals for synchronization of various nodes within the network. The interval at which the advertising packets are sent can be configured, allowing for flexibility based on application requirements.\nNetwork Pairing: Before the Node connects to Gateway, it sends its own information to the Gateway under a public Access Address and physical channel while also receiving network parameters from the gateway to establish the connection. This procedure is called Network Pairing.\nConnection Interval: After the nodes connect to the gateway, they will communicate periodically to determine the connection status; a timeout will indicate a disconnection. This period is called the connection interval. It must be a power of 2 multiple of the periodic advertising interval.\nNetwork Capacity # In MultiConnNet, the relationship between the Connection Interval and the Periodic Advertising Interval directly affects the connection capacity of nodes. Specifically, the Connection Interval must be a power of 2 multiple of the Periodic Advertising Interval.\nMaximum Nodes per Interval:\nEach periodic advertising interval corresponds to a specific maximum connection interval, which is determined by the formula\nMaximum Connection Interval = Periodic Advertising Interval×16 Minimum Connection Interval = Periodic Advertising Interval Each connection interval has a maximum number of nodes it can support. This capacity is fixed and should be considered when designing the network.\nAssuming the Periodic Advertising Interval is 50 milliseconds (ms), the following table lists available connection interval and corresponding maximum node count:\nConnection Interval (ms) Maximum connectable nodes 800 128 400 64 200 32 100 16 50 8 Mixed Connection Interval Trade-offs:\nWhen you introduce nodes with shorter connection intervals, the total number of nodes must be adjusted accordingly. For instance:\nIf you have 1 node with a 400 ms interval, you can only have 126 nodes with an 800 ms interval. Similarly, if you have 1 node with a 200 ms interval, you can have 124 nodes with an 800 ms interval (128 - 2). Generally, to determine the maximum number of nodes in a mixed connection interval scenario, you can follow this approach:\nThe formula states that the total time required by all nodes in the network (calculated as the sum of the time each type of node takes based on its connection interval and count) should not exceed the maximum allowable time frame represented by 16 × 8.\nConclusion:\nUsing this formula allows you to effectively manage and calculate the maximum allowable nodes in a MultiConnNet network with mixed connection intervals. Always ensure that the total time required by all nodes does not exceed the calculated limit, allowing for optimal network performance.\nData Throughput # Data throughput is dependent on connection interval. Lower connection interval, higher data throughput. Here is fomular that is used to estimate approximate data rate.\nThe maximum data rate will be (1000/50)*251 ≈ 5KBps when connection interval is 50 ms.\nPower Consumption # The Gateway is in full operation mode while node is cable of entering low power mode. It is also dependent on connection interval. Lower connection interval, higher power consumption. For maximum 800ms connection interval, node\u0026rsquo;s average current can be lower than 48uA.\n"},{"id":41,"href":"/docs/in6xxe/dk/introduction-to-in6xxe-dk.html","title":"Introduction to IN6XXE DK","section":"Development Kits","content":" Overview # IN6XXE DK is a development board for IN6XXE series chips. You can download the schematics:\nSCH_IN612LE-QFN48-DK-ver1.1\nSCH_IN612LE-QFN56-DK-ver1.1\nHardware description # Component Description 1 RF Connector 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.8V Power 5V to 1.8V 10 ADC port 11 Cortex_debug Debug port 12 Power ON Power switch of the 5V supply from USB 13 Jlink+UART0 JLINK and UART0, UART0 Tx is GPIO_0_2, Rx is GPIO_1_0 14 1.2V Test point 15 LEDs LEDs connected to GPIO,on when GPIO drives HIGH. LED1:GPIO_2_8, LED2:GPIO_3_2, LED3:GPIO_3_3 16 GPIO Test Pin GPIO pins 17 GPIO Test Hole GPIO pins 18 GPIO Button+Reset One reset button, other buttons are LOW active(when pressed, GPIO input LOW) 19 UART Jumper Control power supply of USB to UART chip; Control which GPIOs are connected to the USB to UART chip, default is UART1: GPIO_2_1:TX GPIO_2_7:RX GPIO_1_5:RTS GPIO_1_6:CTS see UART Configuration 20 UART to USB USB to UART chip 21 3.3V Power 5V to 3.3V 22 Type-C Power supply and connect to PC for UART port 23 External VBAT External supply to VBAT 24 External VDDIO External supply to VDDIO These components will be refered as \u0026ldquo;Component_xx\u0026rdquo;(xx is the component number) in this page.\nPower Supply # When the board is connected with USB and the switch is turned on, 5V, 3.3V and 1.8V power source will be valid, and 3 LEDs will indication the status:\nLED4: 5V LED5: 3.3V LED6: 1.8V However, how these power sources will supply IN6XXE chip is configured with Power Jumper(Component_7):\nCHIP_EN can always be connected to VBAT to reset the chip when powered on. VDDIO and VBAT are connected directly to the chip. VDDIO is power supply of IN6XXE\u0026rsquo;s IO, and the voltage level can be different with VBAT. These are confguration examples:\nConnections Description CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;3.3V,VBAT\u0026lt;-\u0026gt;3.3V Both VDDIO and VBAT are 3.3V, supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;1.8V,VBAT\u0026lt;-\u0026gt;3.3V VDDIO is 1.8V, VBAT is 3.3V, both supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;VBAT VBAT and VDDIO are powered by external power source, can be used when measuring power consumption of the chip Debug Port # There are three connectors(component 8, 11, 13) can be used as debug port, usually connected to J-Link.\nUART configuration # IN6XXE has two UART ports, UART0 and UART1. You can connect external USB to UART module to Component_13 if you use UART0.\nYou can also use the on board USB to UART chip, configured with Component_19:\nIf you want to use on board USB to UART chip, 1\u0026lt;-\u0026gt;2 should be connected.\nIf you want to use UART1(GPIO_2_1 as Tx, and GPIO_2_7 as Rx):\n3\u0026lt;-\u0026gt;4, 5\u0026lt;-\u0026gt;6 should be connected for UART Rx and Tx.\n7\u0026lt;-\u0026gt;8, 9\u0026lt;-\u0026gt;10 should be connected for flow control.\nYou can connect 4, 6 to other GPIOs if you use other GPIOs as UART port pins.\nCurrent measurement # If you want to measure current of IN6XXE, all pins of Component_19 should be disconnected.\nFor the Power Jumper, CHIP_EN\u0026lt;-\u0026gt;VBAT and VDDIO\u0026lt;-\u0026gt;VBAT should be connected.\nThen you can connect external power source to VBAT(Component_24) and GND(Component_6) to supply power to IN6XXE and measure the current.\n"},{"id":42,"href":"/docs/in6xx/getting-started/download/jflash-download-guide.html","title":"JFlash Programming","section":"Download Image","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XX chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XX series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay \u0026ldquo;IN6XX_C0_GIGA\u0026rdquo; device Note: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), select \u0026ldquo;IN6XX_C0_GIGA_8M\u0026rdquo; device.\nOpen the Bin file Click the file menu, select \u0026ldquo;Open data file\u0026rdquo;, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":43,"href":"/docs/in6xxe/getting-started/download/jflash-download-guide.html","title":"JFlash Programming","section":"Download Image","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XXE series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nCopy files:\nCopy IN6XXE to \u0026ldquo;C:\\Users\u0026lt;USER\u0026gt;\\AppData\\Roaming\\SEGGER\\JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nUbuntu # Copy IN6XXE to \u0026ldquo;$HOME/.config/SEGGER/JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nmacOS # Copy IN6XXE to \u0026ldquo;$HOME/Library/Application Support/SEGGER/JLinkDevices\u0026rdquo; (only support \u0026ldquo;J-Link Software and Documentation Pack\u0026rdquo; version 7.62 or later).\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay IN6XXE device Open the Bin file\nClick the file menu, select “Open data file”, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":44,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/keyboard-sample.html","title":"Keyboard Sample","section":"Driver Examples","content":" Keyboard Sample # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_keyboard in-dev/proj/driver/proj_drv_keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of keyboard on uart log.\npress button: press key: row:... col:... release button: release row:... col:... More information may be found in debug guide page.\nTest Steps # Open Keil and download the proj_drv_keyboard project. Press the reset button and observe the log for the text CHIP ID =. Press the button, we will get the status press button . After that, we release the button, we will get the status release button "},{"id":45,"href":"/docs/solutions/multiconnnet/command-set.html","title":"Module Instruction Set","section":"MultiConnNet","content":" MultiConnNet Module Instruction Set # The MultiConnNet is Inplay\u0026rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.\nThe system is comprised of two primary components: the Gateway module and the Node module. The module is connected to the HOST via UART interface, and this instruction set defines the data packet format between the module and the HOST.\nThe data packet originally issued by HOST is called Command and the module will return Response to HOST accordingly. The data packet originally issued by the module is called Event.\nCommand and Response # Command and corresponding Response are data packets consist of a sequence of bytes. The format of the data packet is as follows.\nSync Word ID Owner Body Len Body (1 byte) (1 byte) (2 bytes) (2 bytes) (variable) Figure 1: Command and response data packet format\nSync Word: Fixed 0x4A for command and corresponding response.\nID: unique command id.\nOwner: Represents who will actually excute the command or who send it for response. 0 represents local module, otherwise remote module\u0026rsquo;s device address.\nBody Len: is the length of variable body that follows.\nCommand can be executed by local module or remote module. If command is executed locally (Owner in command data packet is 0), the receiver module will send back a response data packet to the HOST immediately, indicating the result of execution. This response is referred to as Local Response (Owner is 0 in response data packet). If command is executed remotely (Owner in command data packet is non-zero), the receiver module will send back local response immediately, indicating whether the command is accepted or not. If accepted, a subsequent Transmission Done Event is then received by HOST indicates the command is actually passed-through to the remote module. If the result of transmission is success, additional response data packet from the remote module will then be forwarded back to the HOST. Since Owner field is actual device address (non-zero) in this response, it is referred to as Remote Response.\nCommands that execute remotely are only issued to gateway module. For node module, all commands are local command so that Owner field is ignored.\nConfiguration commands are those that must be sent at least once by HOST prior to other commands. Parameters by configuration command can be stored in flash so that system can automatically start running each time power on reset, without configuration command being issue again. Configuration command are local command only.\nData Transmission command is the only remote command that Remote Response is not generated since data is totally passed-through to HOST and completely user dependent.\nHere are details of MultiConnNet commands and corresponding responses:\nSerial Port Configuration (ID=1) # This command changes parameters of the serial port that interacts with HOST. It is for local only. It is optional, meaning that if not configured, the module will use following default UART configurations:\nGPIO_2_1 as UART TX and GPIO_2_7 as UART RX 921,600 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The command is as follows:\nOFFSET NAME LENGTH VALUE 4 TX GPIO 1 Specify which GPIO is multiplexed for UART TX function. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_2, TX GPIO=0x02. 5 RX GPIO 1 Same as TX GPIO 6 RTS GPIO 1 Same as TX GPIO. If 0xFF, RTS signal is not used. 7 CTS GPIO 1 Same as TX GPIO. If 0xFF, CTS signal is not used 8 baud rate 4 Support 921600, 460800, 230400, 115200, 57600, 38400, 19200 12 data bit 1 Data bit length. 5 - 8 13 polarity 1 0: None\n1: Odd\n2: Even 14 stop bit 1 Stop bit number 15 receive buffer size 4 Receive buffer size, Maximum 2048 19 reserved 1 0x00 Example:\n→ 4A 01 00 00 10 00 21 27 FF FF 00 C2 01 00 08 00 01 2C 01 00 00 00 ;GPIO_2_1, GPIO_2_7, 115200bps ← 4A 01 00 00 02 00 00 00 ;Local response Network Parameter Configuration (ID=2) # This command configure module\u0026rsquo;s network parameters. It is for local only. If network parameters are stored afterwords by Reset command, module can be run automatically without sending it again.\nFor gateway module, the command is as follows:\nOFFSET NAME LENGTH VALUE 6 gateway module device address 2 A 16-bit value that can only be taken from 0x1000 to 0xF000, where the lower 12 bits are all zeros. 8 access address on connection 4 Access Address when data communication after connection 12 access address on pairing 4 Access Address when pairing procedure 16 channel on pairing 1 Channel on which pairing procedure is. Example:\n;Device address (Gateway) is 0x1000, Access Addresses are 0x67453201 and 0xABABABAB, Channel on pairing is 37 → 4A 02 00 00 0B 00 00 10 01 23 45 67 AB AB AB AB 25 ← 4A 02 00 00 02 00 00 00 For node module, the command is as follows:\nOFFSET NAME LENGTH VALUE 6 node module device address 2 A 16-bit value that can only be taken from 0x0000 to 0x0FFF, where the upper 4 bits are all zeros. 8 gateway device address 2 A 16-bit value that can only be taken from 0x1000 to 0xF000, where the lower 12 bits are all zeros. 10 access address on pairing 4 Access Address when pairing procedure 14 channel on pairing 1 Channel on which pairing procedure is. 15 connection interval 2 Node's connection interval. 17 supervision timeout 4 Time in millisecond, that allowed for a device to receive data or signals from another device. If no data is received within this timeframe, the connection may be considered lost or disconnected. 21 pair interval 2 Time interval in millisecond for sending pairing interaction information. The smaller the interval, the faster the pairing will be successful, but power consumption will increase. 23 pairing duration 4 Duration of pairing procedure in millisecond. 0 if non stop. Example:\n;Node\u0026#39;s device address is 0x0100, access address on pairing is 0x67453201, connection interval is 800ms, supervision timeout is 20000ms, pair interval is 50ms and pairing is not stopped. → 4A 02 00 00 15 00 00 01 00 10 AB AB AB AB 25 20 03 20 4E 00 00 32 00 00 00 00 00 ← 4A 02 00 00 02 00 00 00 External Power Amplifier Control Configuration (ID=3) # This command sets up module\u0026rsquo;s external Power Amplifier (PA) Control function. It is for local only. This command is optional, meaning that if not configured, the module will use following default GPIOs:\nTX enable: GPIO_3_3 RX enable: GPIO_2_5 BIAS: unused The TX enable GPIO will automatically output high to open electronic circuits of power amplifier when RF is opened for transmission. RX enable GPIO and BIAS GPIO share similar working principles.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 TX GPIO 1 GPIO which is used to control Tx_En of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_3_3, it is 0x33. 7 RX GPIO 1 GPIO which is used to control Rx_En of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_2_5, it is 0x25. 8 BIAS GPIO 1 GPIO which is used to control bias of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. If no bias control, set it to 0xFF. Example:\n→ 4A 03 00 00 03 00 33 25 FF ;TX GPIO is GPIO_3_3, RX GPIO is GPIO_2_5, no BIAS ← 4A 03 00 00 02 00 00 00 ;Local response Get State (ID=10) # This command retrieves the module status. It is for local only.\nThe length of this command is 0. The response is as follows:\nOFFSET NAME LENGTH VALUE 6 state 1 Current module state.\n0: Not running, module may not be fully configured yet\n1: Running Example:\n→ 4A 0A 00 00 00 00 ;Try retrieving module status ← 4A 0A 00 00 01 00 01 ;Module is running normally Get Connection (ID=11) # This command retrieves the number of connected modules and corresponding device addresses. For nodes, a return value of 0 of number indicates not connected. It is for local only.\nThe length of this command is 0. The response is as follows:\nOFFSET NAME LENGTH VALUE 6 count 1 Number of connected devices 7 device address count*2 Device addresses of connected modules. Example:\n→ 4A 0B 00 00 00 00 ;Try retrieving the connection status of gateway ← 4A 0B 00 00 07 00 03 00 01 01 01 02 01 ;Gateway has connected with 3 nodes 0x0100, 0x0101 and 0x0102 → 4A 0B 00 00 00 00 ;Try retrieving the connection status of node ← 4A 0B 00 00 03 00 01 00 10 ;Node returns connection with gateway with device address 0x1000 Module Reset (ID=0x20) # This command resets the module. For node module, this command is local only (*Owner field is ignored. For gateway module it can be locally or remotely executed. The command is as follows:\nOFFSET NAME LENGTH VALUE 6 option 1 0: Reset\n1: Reset module with previous configuration cleared\n2: Reset module with previous configuration stored Example:\n→ 4A 20 00 00 01 00 02 ;Save configuration before reset for local module ← 4A 20 00 00 02 00 00 00 ;Local response → 4A 20 00 01 01 00 00 ;Reset remote module 0x0100 from gateway ← 4A 20 00 00 02 00 00 00 ;Local module accepts command ← A4 A2 04 00 00 01 00 00 ;Transmission done event ← 4A 20 00 01 02 00 00 00 ;Remote response from node 0x0100 Modue Run (ID=0x21) # This command start or stop running of module. For node module, this command is local only. For gateway module it can be locally or remotely execution. If Network Parameter Configuration is not stored, it is necessary to send this command to start the module, otherwise module will automatically start running after power on reset.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 running 1 0: Stop1: Start Example:\n→ 4A 21 00 00 01 00 01 ;Start running of local module (either gateway or node) ← 4A 21 00 00 02 00 00 00 ;Local response → 4A 21 00 01 01 00 00 ;Stop running of remote node 0x0100 (from gateway) ← 4A 21 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 01 00 00 ;Transmission done event ← 4A 21 00 01 02 00 00 00 ;Remote response from node with device address 0x0100 Module GPIO Output (ID=0x22) # The command allows the module\u0026rsquo;s specified GPIO pin outputs to a designated level. For node, this command is local only. For gateway it can be called locally or remotely.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 GPIO 1 GPIO which is configured as output functionality. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 level 1 Output level.\n0 : Low level\nother : High level Example:\n→ 4A 22 00 00 04 00 01 01 ;Node module\u0026#39;s GPIO_0_1 outputs high ← 4A 22 00 00 02 00 00 00 ;Local response → 4A 22 01 01 04 00 01 01 ;Remote control node 0x0101 module\u0026#39;s GPIO_0_1 to output high from gateway ← 4A 22 00 00 02 00 00 00 ;Local response ← A4 66 04 00 01 01 00 00 ;Transmission to node 0x0101 done ← 4A 22 01 01 02 00 00 00 ;Remote response received from node 0x0101 Module GPIO Input Trigger (ID=0x23) # This command allows module to trigger a GPIO input event when GPIO is in a specified state. For node module, this command is local only, but the event can be either sent to its HOST via UART or remote connected device over the air depending on target field in command. For gateway module, if the command is local and then the event can only be sent to HOST via UART regarding of target field in command. If the command is remote execution, the event can be either sent to remote HOST via its UART or remotely to connected device over the air. To short, target field defines whether the event will be sent to the remote connected device corresponding to the executor of this command, with the condition that this remote device MUST only be a gateway module.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 GPIO 1 GPIO which is configured as input functionality. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 internal pull up/down 1 0: no pull up/down\n1: internal pull up\n2: internal pull down 8 edge-triggered condition 1 0x00: falling edge\n0x01: rising edge\n0x02: both edge\n0xFF: none 9 target 1 0: local HOST\n1: remote connected device Example:\n→ 4A 23 00 00 04 00 04 01 00 01 ;node module GPIO_0_4 falling edge trigger with internal pull up enabled, event will be remotely sent to gateway. ← 4A 23 00 00 02 00 00 00 ;Local response → 4A 23 01 01 04 00 04 01 00 01 ;gateway remotely set node module (0x0101) GPIO_0_4 falling edge trigger with internal pull up enabled, event will be remotely sent to gateway. ← 4A 23 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 10 00 00 ;Transmission done event ← 4A 23 01 01 02 00 00 00 ;Remote response ... ← A4 A4 04 00 01 01 04 00 ;GPIO Input trigger event Data Transmission (ID=0x30) # This command initiates user data transmission either from Gateway to Node or Node to Gateway. Module will return local response first like any other commands and then Transmission Done Event indicating actual wireless transmission is finished or not.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 data variable length Banary byte data array Example:\n→ 4A 30 01 01 03 00 0A 0B 0C ;Send 3 bytes (0A 0B 0C) from gateway to node 0x0101 ← 4A 30 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 01 01 00 00 ;Transmission done event → 4A 30 00 10 03 00 0A 0B 0C ;Send 3 bytes from node to gateway 0x1000 ← 4A 30 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 10 00 00 ;Transmission done event Firmware Update command (ID=0x40) # This command initiates Firmware Update to module. For node, this command is local only, while for gateway it can be called locally or remotely. If remotely, node\u0026rsquo;s firmware is updated over the air. Firmware Update consists of 3 processes, Prepare, Write, Cancel. Each process is composed of different data packet.\nPrepare # The first process is to tell Node the firmware update over the air is going to begin, along with information including new firmware size, CRC verification, AES encryption etc.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 process 1 0 7 firmware size 4 firmware size 11 flag 1 Each bit set to 1 indicates that the corresponding function is enabled.\nbit 0: AES encryption\nbit 4: CRC check\nother: N/A 12 CRC 4 CRC value of part of firmware binary excluding the first 16K bytes. If CRC check in flag is not set, it's ignored. Example:\n→ 4A 40 01 01 0A 00 00 20 1B 01 00 00 00 00 00 00 ;OTA prepare to node 0x0101, firmware size is 72,480 bytes, no CRC check and AES encryption ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 00 00 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response received from node 0x0101 Write # This process is called several times to do actual firmware data transmission until finished.\nThe data packet is as follows:\nOFFSET NAME LENGTH VALUE 6 process 1 1 7 offset 4 firmware offset 11 data Len-7 data length that follows Example:\n→ 4A 40 01 01 \u0026lt;len\u0026gt; 01 00 00 00 00 ... ;OTA write firmware data to node 0x0101, offset is 0, size is \u0026lt;len\u0026gt; bytes ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 00 00 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response (4A 0B 02 00 00 00) received from node 0x0101 Cancel # This command cancel any on-going OTA firmware update process.\nOFFSET NAME LENGTH VALUE 6 process 1 0xFF Example:\n→ 4A 40 01 01 01 00 FF ;OTA cancel firmware update to node 0x0101 ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response (4A 0B 02 00 00 00) received from node 0x0101 Response # A Response is the data packet returned by the module, indicates whether the command has been accepted or not. The body of Response is a fixed length of two bytes called Result, following the same header as the corresponding command. The Response can be local response sent by local module, or remote response sent by remote module, which is included in the data of the Data Reception Event. Both local response and remote response share the same data structure.\nThe available Result values are as follows:\nNAME VALUE MEANING WL_ERR_NO_ERROR 0 Success WL_ERR_CMD 0x10010 Sync Word in data head error WL_ERR_CMD_ID 0x1002 ID in data head error WL_ERR_CMD_PARAM 0x1003 Parameter error WL_ERR_TIMEOUT 0x1004 Command executing timeout WL_ERR_BUSY 0x1005 Command is not acceptable due to system busy WL_ERR_NOT_READY 0x1006 System is not ready of well configured Event Description # An Event is the data packet actively sent by the module to the HOST. Events have Sync Word 0xA4 in their data packet and unique event identifier follows. The format of the data packet is as follows.\nSync Word ID Body Len Body (1 byte) (1 byte) (2 bytes) (variable) Figure 1: Event data packet format\nSync Word: Fixed 0xA4.\nID: unique event id.\nBody Len: is the length of variable body that follows.\nHere are details of MultiConnNet events:\nModule Ready Event (ID=0xA0) # This event indicates system is ready to accept command from HOST. It has no body so the body len field is 0.\nExample:\n← A4 A0 00 00 Connection Event (ID=0xA1) # This event indicates Gateway/Node has successfully connected or disconnected to each other.\nOFFSET NAME LENGTH VALUE 4 connection 1 0: disconnect\n1: connect 5 device address 2 Remote device address Example:\n← A4 A1 03 00 01 00 01 ;Gateway has connected with node 0x0100 Transmission Done Event (ID=0xA2) # This event indicates data has been actually transmitted over the air.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remove device address 5 result 2 Transmission result.\n0 : success\nother : protocol-level errors Example:\n← A4 A2 04 00 00 01 00 00 ;Gateway has transmitted data to node with device address 0x0100 Data Reception Event (ID=0xA3) # This event indicates data has been received from remote connected devices.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remote device address 6 data Len-2 Banary byte data array Example:\n← A4 A3 05 00 00 01 00 01 02 ;Gateway has received 3 bytes data from node 0x0100 GPIO Input Trigger Event (ID=0xA4) # This event indicates GPIO\u0026rsquo;s input status is triggered, which is configured by GPIO Input Configuration command. This event can be sent to local HOST or remote devices, depending on device address parameter in event data body.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remote device address, or local if 0. 6 GPIO 1 GPIO which input status is triggered. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 level 1 Current GPIO level Example:\n← A4 A4 04 00 01 01 04 00 ;Node 0x0101 GPIO_0_4 falling edge trigger "},{"id":46,"href":"/docs/in6xx/getting-started/download/mp-tool-guide.html","title":"MP Tool Guide","section":"Download Image","content":" MP Tool Guide # Introduction # The MP Tool is a tool for mass production downloading and testing, capable of downloading the main program and token, as well as testing RF performance. Please refer to this document for details.\n"},{"id":47,"href":"/docs/in6xxe/user-guides/nanosync-technology/trigger-handler-guide.html","title":"NanoSync Engine Guide","section":"NanoSync Technology","content":" NanoSync Engine Guide # Introduction # NanoSync engine(trigger handler block) which can be used to perform many real-time events or tasks without the CPU’s intervention.\nThe NanoSync engine operates based on triggers and handlers. When a trigger (also called an event) happens, a handler will be invoked. A handler consists of a sequence of hardware actions (also called hardware tasks), which can be automatically executed by the hardware without the CPU intervention. Typical triggers include GPIO input status change, timer time out, CPU interrupts etc.\nTerminology # Priority Queues # NanoSync engine supports three priority queues:\nHigh Priority Queue:\nSupports up to 8 defined triggers. Dedicated memory of 512 words. Middle Priority Queue:\nSupports up to 8 defined triggers. Use shared memory, maximum memory usage is 512 words. Low Priority Queue:\nSupports up to 16 defined triggers. Use shared memory, maximum memory usage is 512 words. Higher priority queue can preempt lower priority queue.\nTrigger id # In each queue, there are multiple triggers. And each trigger is assined a unique trigger id. The high priority and middle priority queues have 8 triggers, with trigger id ranging from 0 to 7. The low priority queue has 16 triggers, with trigger id ranging from 0 to 15.\nWhen multiple triggers within the same queue are triggered simultaneously, the trigger with the smallest trigger id will be executed first.\nTrigger Header # Every trigger has a header. Trigger headers are located at beginning of queue memory.\nTrigger Signals # There are 255 trigger signals. And 0xFF is invalid trigger signal(refer to enum trig_cond_idx for details). Each trigger signal corresponds to an external or internal signal. When receive the signal(rising edge/failling edge), it triggers the corresponding trigger and executing the corresponding trigger command.\nTrigger Command # A trigger can have multiple trigger commands. When activated, these commands will be executed sequentially.\nODC(output direct controls) # Used by output command. Has 127 output direct controls(refer to enum trig_odc_idx for details).\nMemory # High priority queue has 512 words(2KB) dedicated memory(trig memory). Middle and low priority queue use shared memory.\nTimer # Each priority queue has its own 24-bit timer.\nAHB/APB bus # Trigger handler can use APB or AHB bus to access peripheral registers.\nAHB bus: CPU can access register with AHB bus. Read and write opertations don\u0026rsquo;t have a fix lantency. The deviation is about 3us.\nAPB bus: CPU can\u0026rsquo;t access register with APB bus. Has fix latency, The deviation is less than 0.1us.\nTrigger Address # All trigger API use word address offset, not byte address. Address offset is start from 0x0.\nTrigger configuration # Enable HW trigger in share memory configuration. The size is low priority queue memory size plus middle priority queue memory size. Maximum size is 4K(0x1000). If enable sleep, should select \u0026ldquo;Reten Mem\u0026rdquo; to retention shared memory and trigger memory.\nTrigger command # Set timer command # This commamnd is used to config the timer.The timer will be initialized with the initial value specified by the command (or the value in the control register) and will start counting down towards 0. If the auto-reload bit of the command is set to 0x1, the timer will restart with the initial value or the value from the control register after reaching 0. If the auto-reload bit of the command is set to 0x0, the timer will stop. If the timer is already running at the time of this command execution, it will be reset to the initial value and restart. Upon reaching 0, the timer can generate an interrupt signal.\nWait timer command # This command is used to wait for the timer to expire. This command will block the subsequent commands until the timer reaches the value specified in the command. If the “stop timer” bit is 1, the timer will stop counting when the timer reaches the expected value. If the “stop timer” bit is 0, the timer will continue counting after it reaches the expected value. It is strongly recommended that this command is NOT used in the highest priority queue as this command might delay the execution of all following triggers in the highest priority queue and also all triggers in the middle and lowest priority queues.\nRegister read and compare command # This command reads a value from a specific register, applies the mask on the read value and then compares the masked value to the expected value. When conditions fails, it can jump to another address to run command.\nRegister write command # This command write 32 bits value to register.\nRegister read and write command # The command reads the register value first and only update the bits to the write value where the corresponding bits in the mask is 1. The actual write value is computed as:\nactual_write_value = (read_value \u0026amp; ( ~ mask )) | (write_value \u0026amp; mask). Register copy command # This command will read the source register address value, and copy data to destination register.\nRegister copy with mask command. # This command will read the source register address value, apply the mask and write the masked value to the destination register address. The destination register value will also be read and the non-mask portion will be unchanged and written back to the destination register address together with the masked source register read value.\nwritten_value = (destination_read_value \u0026amp; (~ mask)) | (source_read_value \u0026amp; mask). Output command # This command output signal with ODC(output direct controls). Refer to enum trig_hdl_idx for specific signal details. Each output command contains an output signal index, a toggle enable and an output value. If the index is larger than 127, the specific ODC is disabled. It is recommended to write 0x7F to all unused output signal index. If the toggle bit is 1 for a given output index, the corresponding output value will be ignored and the corresponding output signal will toggle its current output value to an opposite polarity.\nNotice that we will use a control register to initialize the output port value which will be controlled by the trigger handler before the handler module is enabled. See hal_trig_hdl_gpio_out_en for reference.\nNull command # This command is just a placeholder in the memory and will not execute any operation.\n"},{"id":48,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/pwm-sample.html","title":"PWM Sample","section":"Driver Examples","content":" PWM Sample # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.\nThis routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_pwm in-dev/proj/driver/proj_drv_pwm Configuration # #define PWM0_PERIOD_USEC 10000 Define the PWM period for PWM0.\n#define PWM0_HIGH_USEC 5000 Define the duration of the high level for PWM0.\n#define PWM4_PERIOD_USEC 10000 Define the PWM period for PWM4.\n#define PWM4_HIGH_USEC 3000 Define the duration of the high level for PWM4.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to terminal emulator.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;input any key to pause PWM\u0026rdquo; appearing in the log. This indicates that the PWM has started. Use a logic analyzer or an oscilloscope to connect to GPIO_0_0 (pwm0) and GPIO_1_8 (pwm4) to observe the corresponding square waves with the specified period and duty cycle. "},{"id":49,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/qdec-sample.html","title":"QDEC Sample","section":"Driver Examples","content":" QDEC Sample # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.\nThis routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).\nThe LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_qdec in-dev/proj/driver/proj_drv_qdec Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # The LOG is printed through the UART port, showing the count changes based on the events and direction of the rotary encoder.\nMore information may be found in debug guide page.\nConnection # Connect the VCC and GND of IN6xxE to the qdec board. Then, connect GPIO_1_3 to cha-x-0, GPIO_1_6 to chb-x-0, and GPIO_2_3 to idx-x-0.\nTest Steps # Open Keil and download the proj_drv_qdec project. Press the K1 button and observe the text main start... appearing in the log. Rotate the rotary encoder in the forward direction. The count will increase, and the text cnt is 0x... will be displayed. Note: Connecting GP13 to chb_x_0 and GP16 to cha_x_0 will not affect the program\u0026rsquo;s operation but will change the direction determination during the rotary encoder rotation.\n"},{"id":50,"href":"/docs/in6xx/getting-started/installation/quick-start.html","title":"Quick Start","section":"Installation","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_find_my\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/build/mdk/proj_ble_lp.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN612L\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Note: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), select \u0026ldquo;IN610_G8C0I\u0026rdquo; device.\nClick \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes. Note:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIf Keil displays the following warning dialog, please click the OK button and then select Cortex-M4 on the next page. In the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN602C0 GD25WD40C SPI FLASH \u0026ldquo;flm file by click \u0026ldquo;Add\u0026rdquo; button. Then set start addres to 0x210000 and set size to 0x1000.\nNote: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), flm file is \u0026ldquo;IN602C0 GD25WD80C SPI FLASH\u0026rdquo;.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":51,"href":"/docs/in6xxe/getting-started/installation/quick-start.html","title":"Quick Start","section":"Installation","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_adv_conn\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/build/mdk/proj_ble_test.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN6XXE\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Click \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes.\nNote:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIf Keil displays the following warning dialog, please click the OK button and then select Cortex-M4 on the next page. In the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN6XX SPI FLASH \u0026ldquo;flm file, set start addres and size.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":52,"href":"/docs/in6xxe/getting-started/installation/quick-start-with-gcc.html","title":"Quick Start with GCC","section":"Installation","content":" Quick Start Guide with GCC # Introduction # This document introduce how to use GCC for software development.\nPreparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install Arm GNU Toolchain (version \u0026ldquo;arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi\u0026rdquo; is recommended).\nInstall Make\nsudo apt-get update sudo apt-get install build-essential Generate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Use Wine to run it on Linux. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Unzip InPlay SDK to \u0026ldquo;~/inplay\u0026rdquo;. Open file \u0026ldquo;~/inplay/in-dev/proj/common/gcc/linux.mk\u0026rdquo;. Set \u0026ldquo;GNU_INSTALL_ROOT\u0026rdquo; to your GCC installation path. Build project \u0026ldquo;proj_ble_adv_conn\u0026rdquo;. cd ~/inplay/in-dev/proj/ble/proj_ble_adv_conn/build/gcc/ make all Use the following command to rebuild project: make cleanall make all "},{"id":53,"href":"/docs/in6xxe/getting-started/installation/run-zephyr-on-in6xxe.html","title":"Run Zephyr on IN6XXE","section":"Installation","content":" Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.\nInplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.\nSetup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows. You can follow Zephyr Getting Started Guide to setup a Zephyr development environment under Windows, it can be divided into following steps:\n1.Install host dependencies, including cmake, Python, devicetree compiler, etc.\nThese are necessary host tools needed to build Zephyr.\n2.Install west and Python dependencies\nBecause IN6XXE support is not merged into the official Zephyr project repository now, you should init west using below command:\nwest init -m https://github.com/InPlay-Inc/zephyr zephyrproject To support IN6XXE, an external module named \u0026ldquo;hal_inplay\u0026rdquo; is added, when you run west update, it will be cloned to your zephyr working directory automatically.\n3.Install Zephyr SDK\nYou only need to install arm-zephyr-eabi cross tool to support IN6XXE.\nBuild the application # Board name of IN6XXE is \u0026lsquo;inplaydk_in612le\u0026rsquo;, you can start with a simple \u0026ldquo;blinky\u0026rdquo; sample:\ncd zephyrproject/zephyr west build -p always -b inplaydk_in612le samples/basic/blinky Flash binary output # You should first refer to JFlash Download Guide to install InplayTools. After that, you can use Jlink to burn the binary output to the on-chip flash with command west flash.\nRun the sample # For the DK board, UART1 is configured as console in the source code, and the baud rate is 115200. There is an USB to UART chip(CH340) integrated on the board which is connected to UART1(GPIO21 as Tx, and GPIO27 as Rx), so you only need to connect the board to PC with USB Type-C cable to see logs or use shell. CH340 drivers should be installed first, you can download it from here. If the sample runs normally, you can see logs output to a serial terminal software like \u0026ldquo;putty\u0026rdquo;.\nSupported drivers # Only these drivers are supported now:\nGPIO pinctrl(partially implemented) UART(support tx and rx with interrupt, so you can use Zephyr shell) BLE hci driver "},{"id":54,"href":"/docs/in6xxe/examples-and-use-case/sdr/sdr-1-master-to-multiple-slave-sample.html","title":"SDR 1 to n Sample","section":"SDR Examples","content":" SDR 1 to n Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. In SDR broadcast systems, signal processing and transmission are both accomplished through software. This allows SDR broadcast equipment to support multiple modulation methods, coding techniques, and transmission protocols, thus achieving compatibility with various broadcast standards. Whether it\u0026rsquo;s the high-quality audio transmission of high-definition broadcasting or the extensive coverage of digital audio broadcasting, SDR delivers excellent performance.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_SDR_1_mst_to_N_slave_master proj_SDR_1_mst_to_N_slave_slave in-dev/proj/SDR/proj_SDR_1_mst_to_N_slave_master in-dev/proj/SDR/proj_SDR_1_mst_to_N_slave_slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nSDR TX success [TX]actual tx bytes=%d\nSDR RX success \u0026quot;[RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d,\u0026quot;\nMore information may be found in debug guide page.\nTest Steps # MASTER\nOpen Keil and download **proj_SDR_1_mst_to_N_slave_master **. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr master process according to the settings in sdr_mstr_trx_t. When the development board received , we will receive log like [TX]actual tx bytes=%d and [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, SLAVE\nOpen Keil and download proj_SDR_1_mst_to_N_slave_slave. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr slave process according to the settings in sdr_slv_trx_t. When the development board received , we will receive log like [TX]actual tx bytes=%d and [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, "},{"id":55,"href":"/docs/in6xxe/examples-and-use-case/sdr/sdr-broadcast-sample-.html","title":"SDR Broadcast Sample","section":"SDR Examples","content":" SDR Broadcast Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. The Master device typically plays a central role in control and management, while multiple Slave devices serve as nodes performing specific communication tasks.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_SDR_Broadcast_Mode_Master proj_SDR_Broadcast_Mode_Slave in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Master in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of development board according to Uart Log. The following are samples,\nSDR TX success [TX]actual tx bytes=%d\nSDR RX success \u0026quot;[RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d,\u0026quot;\nMore information may be found in debug guide page.\nTest Steps # Master\nOpen Keil and download proj_SDR_Broadcast_Mode_Master. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr broadcast process according to the settings in sdr_mstr_trx_t. In broadcast mode, master don\u0026rsquo;t receive. Slave\nOpen Keil and download proj_SDR_Broadcast_Mode_Slave. Press the reset button and observe the text CHIP ID = on the log while the device starts sdr addressless process according to the settings in sdr_slv_trx_t. When sdr communication astablished, we will receive log like [TX]actual tx bytes=%dand [RX]sa:0x%04x, da:0x%04x, status:%02x, ch=%d, rssi=%d, rxlen=%d, "},{"id":56,"href":"/docs/in6xxe/protocols-reference/smull/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"SMULL","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and sync address. Each packet from the slave has its own preamble and sync address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. The data exchange can be configured to operate in three different modes between a master and multiple salves.\nPrivate data exchange mode The master can be configured to send each slave a private packet at each frame. Each slave can be configured to send the master a private packet at each frame. Private packet: There is acknowledgement between the sender and the recipient.\nPublic data exchange mode The master can be configured to send a public packet to all the slaves at each frame.\nPublic packet: Slaves do the acknowledgement. The master does not proceed to next public packet unless the current public packet is acknowledged by all the slaves.\nBroadcasting mode The master can be configured to send a broadcast packet to all the slaves at each frame.\nBroadcast packet: Slaves do not acknowledge the reception of a broadcast packet.\nOverview of transparent data transmission # Many modern applications rely on wireless data transmission; however, end-users often lack knowledge or interest in the underlying wireless technologies. Consequently, we have designed a mechanism that allows users to conveniently utilize the powerful data transfer capabilities provided by SMULL without the need to understand the details of this protocol. Before starting the data transmission, it is necessary to configure the relevant parameters of SMULL to establish a network between the master and slave. By using the commands we provide, you can quickly establish the SMULL network. Please refer to the example provided below for more details. The schematic of the entire system, showing the connection between the host and IN618 module, is illustrated in Figure 3.\nTypically, the host refers to various devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default settings for the UART in our system are illustrated below.\nUART default settings # 115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # In order to facilitate software development with SMULL, we have designed a set of commands for programming. Users can effortlessly start the system by utilizing these commands.The command format is shown as following. Command Code Data Length Data 2 bytes 2 bytes variable bytes Get Slave Number: 0xA011 # This command gets the number of slaves in current network.\nSend: 0xA0 0x11 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x11 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Set Slave Number: 0xA012 # This command is used to configure the number of slaves.The slave number should be less than (or equal to) the maximum slave number (CFG_IPMAC_MAX_SLV_NUM).\nSend: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Response: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: the command sent is too short\nB0=0x02: number of slave is larger than the maximum value Notice:\nAfter successfully setting the slave number on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the slave number on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x13 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Sending this command to the master will not receive any response. Each slave in a network must have a unique ID.\nSend: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Response: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Slave ID is larger than or equal to the slave number which you set. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the slave ID will not be updated.\nGet SYNC Address (Network Address): 0xA015 # This command gets the SYNC address. Each established network should have a unique SYNC address (also known as network address).\nSend: 0xA0 0x15 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x15 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) SYNC Address = (B0 \u0026laquo; 24) | (B1 \u0026laquo; 16) | (B2 \u0026laquo; 8) | B3\nSet SYNC Address (Network Address): 0xA016 # This command can be used to set the SYNC address. The value 0x00000000 will be ignored and the address will not be updated. The value 0xFFFFFFFF also cannot be accepted.\nSend: 0xA0 0x16 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) Response: 0xA0 0x16 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: SYNC address is invalid. Notice:\nFor optimal performance, it is advisable to ensure that the SYNC address bit sequence does not contain four consecutive ones or zeros. Generally speaking, it is better to use a random value. For example,\n0x2954935B is a good value. There are no 4 consecutive ones or zeros in its bit sequence.\n0x10F10724 is not a good value. There are 4 consecutive ones or zeros in its bit sequence.\nAfter successfully setting the SYNC address on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the SYNC address on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet PHY Rate: 0xA017 # This command gets the PHY rate. The supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x17 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Set PHY Rate: 0xA018 # This command can be used to set the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Response: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: PHY Rate is invalid. Notice:\nAfter successfully setting the PHY rate on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the PHY rate on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x19 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x19 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: slave\nB0=0x01: master Set Mode: 0xA01A # This command is used to set the mode (master or slave) on the device. Each device will be configured as a master or a slave. In a network, only one device can be configured as a master.\nSend: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) B0 B0 should be 0 (slave) or 1 (master), other values are considered as invalid. Response: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Mode is invalid. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packet. Here, the downlink means the data are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1B 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Length = (B0 \u0026laquo; 8) | B1\nSet Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packet is 6 bytes. Ensure that the value you set is equal to or greater than 6. This length should be less than 200.\nSend: 0xA0 0x1C 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Response: 0xA0 0x1C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00, success; B0=0x01, The command sent is too short; B0=0x02, Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of downlink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of downlink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Maximum Length of Uplink Private Packet: 0xA01D # the maximum length of uplink private packet. Here, the uplink means the data are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1D 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Set Maximum Length of Uplink Private Packet: 0xA01E # This length should be less than 200.\nSend: 0xA0 0x1E 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 Maximum length of uplink private packet (MSB) B1 Maximum length of uplink private packet (LSB) Response: 0xA0 0x1E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of uplink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of uplink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Period of Heartbeat Packet: 0xA033 # In order to track the connection status of the network, heartbeat packet is periodically sent between the master and slave(s). Users can get the period of the heartbeat packet by issuing this command. The default value is 1000ms.\nSend: 0xA0 0x33 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x33 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) Set Period of Heartbeat Packet: 0xA034 # Users can change the period of the heartbeat packet by issuing this command.\nSend: 0xA0 0x34 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) If the period is zero, the default value (1000ms) will be used.\nResponse: 0xA0 0x34 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00:success\nB0=0x01:The command is too short Notice:\nThe minimum heartbeat period is 500ms. Thus, the period you set should be larger than or equal to 500ms. If the period is less than 500ms, it will be automatically set to 500ms.\nBroadcast SMULL Settings: 0xA040 # With this command, the master can broadcast the SMULL settings. Once the network has been established, the master can use this command to broadcast the new SMULL-related parameters to all the slaves. The slave will update its settings and reset automatically upon receiving new settings broadcasted by the master.\nSend: 0xA0 0x40 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Broadcast Duration (MSB) B1 Broadcast Duration B2 Broadcast Duration B3 Broadcast Duration (LSB) The broadcast duration in milliseconds indicates how long the broadcast will last. If this value is set to zero, the default value of 3000ms is utilized. To ensure successful reception by each slave, it is recommended to set this value to a minimum of 3000ms.\nResponse: 0xA0 0x40 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: The command is too short\nB0=0x02: In slave mode, this command will be ignored Get SMULL status: 0xA041 # This command gets the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x41 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: It means the SMULL is successfully initialized\nB0=0xFF: It means the SMULL is not initialized. Notice:\nIf the initialization of SMULL fails, any SMULL related command that is issued will result in receiving the following response containing an error code 0xFF.\nCommand Code 0x00 0x01 0xFF\nGet SMULL configurations: 0xA042 # The SMULL configurations consist of 7 parameters: mode, slave number, slave ID, PHY rate, SYNC address, maximum length of downlink private packet and maximum length of uplink private packet. You can get all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) The length of data in successful response differs from that in failure response.\nSuccessful response: 0xA0 0x42 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that is used in your application. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Failure response: 0xA0 0x42 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Set SMULL configurations: 0xA043 # As aforementioned, the SMULL configurations include 7 parameters. You can set these parameters all at once by issuing this command.\nSend: 0xA0 0x43 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that may be used in your application. This number must be less than or equal to the value of CFG_IPMAC_MAX_SLV_NUM. As of the current firmware, CFG_IPMAC_MAX_SLV_NUM is set at 64. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Response: 0xA0 0x43 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: A general error\nB0=0x02: Command length is short\nB0=0x03: Invalid SMULL mode\nB0=0x04: Invalid slave number\nB0=0x05: Invalid slave Id\nB0=0x06: Invalid PHY Rate\nB0=0x07: Invalid SYNC address\nB0=0x08: Invalid downlink packet size\nB0=0x09: Invalid uplink packet size Query Connection Status of Each Slave: 0xA044 # The user can get the connection status of each slave by issuing this command on the master side.\nSend: 0xA0 0x44 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x44 0x00 0x10 B0~B15\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x10 Data Length (LSB) B0 The connection status of slave0 ~ slave7 \u0026hellip; \u0026hellip; B15 The connection status of slave120 ~ slave127 The byte sequence of data B0~B15 is a bit-map, each bit is associated with a slave. B0 is associated with slave0 to slave7, while B1 is associated with slave8 to slave15, and so on. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to show what a response might look like.\nExample1: Assuming that the maximum number of slaves is set to four and that all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00\u0026hellip;0x00. However, in the case where only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00\u0026hellip;0x00.\nExample2: Assuming that the maximum number of slaves is set to nine and that all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, in the case where only slaves 0, 1, 6, 7 and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00..0x00.\nIf this command is executed on the slave side, the response would be 0xA0 0x44 0x00 0x01 0x01.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packet. However, the slave can only trasmit private packets. Below, we will provide a detailed explanation on how to use this command for both the master and the slave.\n①Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively simple.\nSend: 0xA0 0x48 D0 D1 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long ②Master transmits data. The master can transmit three types of packets to the slave: private, public and broadcast. In current firmware, we only support private packet.\nSend: 0xA0 0x48 D0 D1 T0 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) T0 Packet type\n0x00: broadcast\n0x01: public\n0x02: private S0 Slave ID. If sending a private packet, it is necessary to specify which slave it is sent to. B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long\nB0=0x03: Invalid slave ID Receive Data: 0xA049 # When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the user in the following format.\n0xA0 0x49 D0 D1 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x49 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) S0 If data is received by the master, S0 denotes the slave ID.\nIf data is received by the slave, S0 denotes the packet type (0 = broadcast, 1 = public, 2 = private). B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Get UART Configuration: 0xA063 # This command read the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Successful Response: 0xA0 0x63 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control Response with errors: 0xA0 0x63 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control The maximum supported baud rate is 2000000.\nResponse: 0xA0 0x64 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x65 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Response: 0xA0 0x66 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Chip Reset: 0xA0E1 # Typically, when the SMULL parameters are updated, it is recommended to reset the chip by issuing this command.\nSend: 0xA0 0xE1 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xE1 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Example # Before initiating data transmission, it is crucial to set up a network connection - a process also referred to as pairing. To guarantee effective network communication, it is imperative that the SMULL configurations of both the master and each slave must be identical, with the exception of the mode and slave ID. Employing UART for SMULL configuration paves the way for this essential uniformity between the master and all slave devices. To elucidate this setup procedure, we will walk through an illustrative example. The specifications for each network parameter are detailed hereinbelow.\nMode: (master: 0x01, slave: 0x00) Slave number: 4 Slave Id: (0x00 ~ 0x03), master will ignore this value Phyrate: 2M Address: 0x2954935B Maximum length of downlink packet: 10bytes Maximum length of uplink packet: 100bytes Two methods can be used to complete the configuration. Method 1 requires the use of command 0xA043, whereas method 2 entails a combination of commands 0xA01A, 0xA012, 0xA014, 0xA018, 0xA016, 0xA01C, 0xA01E. Once the configuration is completed successfully, it is necessary to execute the reset command.\nMethod1:\nThe command sequence issued by the master would be\n①0xA0 0x43 0x00 0x0C 0x01 0x04 0x00 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave (slave0~slave3) would be\n①0xA0 0x43 0x00 0x0C 0x00 0x04 ID 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nMethod2:\nThe command sequence issued by the master would be\n①0xA0 0x1A 0x00 0x01 0x01\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 0x00\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave would be\n①0xA0 0x1A 0x00 0x01 0x00\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 ID (different slave ID)\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nIn method2, the order of the command sequence is not mandatory. However, the command 0xA014 should be issued after 0xA012 and the reset command must be the final one.\n"},{"id":57,"href":"/docs/solutions/smull/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"SMULL Pass-through Network","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and network address. Each packet from the slave has its own preamble and network address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. Data exchange can operate in three modes between a master and multiple slaves.\nPrivate Data Exchange Mode The master can send each slave a private packet in every frame, and each slave can send a private packet to the master. Private packet: Acknowledgment occurs between the sender and recipient.\nPublic Data Exchange Mode The master can send a public packet to all slaves in each frame.\nPublic packet: Slaves provide acknowledgment. The master will not send the next public packet until all slaves have acknowledged the current one.\nBroadcasting Mode The master can send a broadcast packet to all slaves in each frame.\nBroadcast packet: Slaves do not acknowledge receipt of a broadcast packet.\nOverview of Transparent Data Transmission # Many modern applications rely on wireless data transmission, but end-users often lack knowledge or interest in the underlying technologies. We have designed a mechanism that enables users to leverage the powerful data transfer capabilities of SMULL without needing to understand the protocol details. Before initiating data transmission, the relevant SMULL parameters must be configured to establish a network between the master and slaves. Using our provided commands, you can quickly set up the SMULL network. Please refer to the example for more details. Figure 3 illustrates the entire system, showing the connection between the host and the IN618 module.\nTypically, the host refers to devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default UART settings in our system are as follows:\nUART Default Settings # 115,200 bps 8 bits No parity 1 stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # To facilitate software development with SMULL, we have designed a set of programming commands. Users can easily initiate the system using these commands. The command format is as follows:\nCommand Code Data Length Data 2 bytes 2 bytes variable bytes Table 1\nError Codes: Error Code Description 0x00 No errors 0x01 Wrong format 0x02 Unspecified error 0x03 Invalid parameter 0x04 Hardware error Table 2\nTX Power: Value TX Power 0x00 Max Power 0x01 7dBm 0x02 6.5dBm 0x03 6dBm 0x04 5.5dBm 0x05 5dBm 0x06 4.5dBm 0x07 4dBm 0x08 3.5dBm 0x09 3dBm 0x0A 2.5dBm 0x0B 2dBm 0x0C 1.5dBm 0x0D 1dBm 0x0E 0.5dBm 0x0F 0dBm 0x10 -1dBm 0x11 -2dBm 0x12 -3dBm 0x13 -4dBm 0x14 -5dBm 0x15 -6dBm 0x16 -8dBm 0x17 -10dBm 0x18 -12dBm 0x19 -16dBm 0x1A -20dBm 0x1B -43dBm SMULL Command # Get Slave Number: 0xA011 # This command gets the number of slaves in the current network. Send: 0xA0 0x11 0x00 0x00\nResponse: 0xA0 0x11 0x00 0x01 \u0026lt;slv num\u0026gt;\nslv num: Number of slaves. Set Slave Number: 0xA012 # This command configures the number of slaves. Send: 0xA0 0x12 0x00 0x01 \u0026lt;slv num\u0026gt;\nslv num: Number of slaves, from 1 to 127. Response: 0xA0 0x12 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Get Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nResponse: 0xA0 0x13 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Get Network Address (Access Address): 0xA015 # This command retrieves the network address. Each established network must have a unique network address (access address).\nSend: 0xA0 0x15 0x00 0x00\nResponse: 0xA0 0x15 0x04 \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt;\naddr: Network address, 4bytes. Get PHY Rate: 0xA017 # This command gets the PHY rate. Supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nResponse: 0xA0 0x17 0x00 0x01 \u0026lt;phy\u0026gt;\nphy: PHY rate. 0x01: 1 Mbps, 0x02: 2 Mbps Set PHY Rate: 0xA018 # This command sets the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 \u0026lt;phy\u0026gt;\nphy: PHY rate. 0x01: 1 Mbps, 0x02: 2 Mbps Response: 0xA0 0x18 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Get Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nResponse: 0xA0 0x19 0x00 0x01 \u0026lt;mode\u0026gt;\nmode: Device mode. 0x00: slave, 0x01: master Set Mode: 0xA01A # This command sets the device mode (master or slave). Only one device in a network can be configured as master.\nSend: 0xA0 0x1A 0x00 0x01 \u0026lt;mode\u0026gt;\nmode: Device mode. 0x00: slave, 0x01: master Response: 0xA0 0x1A 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Notice:\nAfter successful configuration, reset the chip by issuing command 0xA0E1, or the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packets, which are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nResponse: 0xA0 0x1B 0x00 0x02 \u0026lt;downlink packet length byte 1\u0026gt; \u0026lt;downlink packet length byte 0\u0026gt;\ndownlink packet length: Length of downlink private packet. Set Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packets is 6 bytes. Ensure the value set is equal to or greater than 8 and less than 200.\nSend: 0xA0 0x1C 0x00 0x02 \u0026lt;downlink packet length byte 1\u0026gt; \u0026lt;downlink packet length byte 0\u0026gt;\ndownlink packet length: Length of downlink private packet. Response: 0xA0 0x1C 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Get Maximum Length of Uplink Private Packet: 0xA01D # This command retrieves the maximum length of uplink private packets, which are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nResponse: 0xA0 0x1D 0x00 0x02 \u0026lt;uplink private packet length byte 1\u0026gt; \u0026lt;uplink private packet length byte 0\u0026gt;\nuplink private packet length: Length of uplink private packet. Set Maximum Length of Uplink Private Packet: 0xA01E # This length should be less than 200.\nSend: 0xA0 0x1E 0x00 0x02 \u0026lt;uplink private packet length byte 1\u0026gt; \u0026lt;uplink private packet length byte 0\u0026gt;\nuplink private packet length: Length of uplink private packet. Response: 0xA0 0x1E 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Get Maximum Length of Broadcast Packet: 0xA01F # This command retrieves the maximum length of broadcast packets.\nSend: 0xA0 0x1F 0x00 0x00\nResponse: 0xA0 0x1F 0x00 0x02 \u0026lt;broadcast packet length byte 1\u0026gt; \u0026lt;broadcast packet length byte 0\u0026gt;\nbroadcast packet length: Length of broadcast packet. Set Maximum Length of Broadcast Packet: 0xA020 # This length should be less than 200.\nSend: 0xA0 0x20 0x00 0x02 \u0026lt;broadcast packet length byte 1\u0026gt; \u0026lt;broadcast packet length byte 0\u0026gt;\nbroadcast packet length: Length of broadcast packet. Response: 0xA0 0x20 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See Table 1. Get SMULL Status: 0xA041 # This command retrieves the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nResponse: 0xA0 0x41 0x00 0x01 \u0026lt;status\u0026gt;\nstatus: Device status. 0: idle, 1: pair, 2: connecting, 3: connected Get SMULL Configurations: 0xA042 # The SMULL configurations consist of 8 parameters: mode, slave number, slave ID, PHY rate, network address, maximum length of downlink private packet, maximum length of uplink private packet, and maximum length of broadcast packet. You can retrieve all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nResponse: 0xA0 0x42 0x00 0x0E \u0026lt;mode\u0026gt; \u0026lt;slv num\u0026gt; \u0026lt;slv id\u0026gt; \u0026lt;phy\u0026gt; \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt; \u0026lt;downlink packet length byte 1\u0026gt; \u0026lt;downlink packet length byte 0\u0026gt; \u0026lt;uplink packet length byte 1\u0026gt; \u0026lt;uplink packet length byte 0\u0026gt; \u0026lt;broadcast packet length byte 1\u0026gt; \u0026lt;broadcast packet length byte 0\u0026gt;\nmode: 0: slave, 1: master slv num: Slave Number. slv id: Slave ID. 0~(slave number – 1). Master will ignore this value. phy: PHY Rate. 1: 1 Mbps, 2: 2 Mbps. addr: network Address. downlink packet length: Maximum Length of Downlink Private Packet. uplink packet length: Maximum Length of Uplink Private Packet. broadcast packet length: Maximum Length of Broadcast Packet. Set SMULL configurations: 0xA043 # As mentioned earlier, the SMULL configurations consist of 8 parameters. You can set these parameters all at once by issuing the following command.\nSend: 0xA0 0x43 0x00 0x0E \u0026lt;mode\u0026gt; \u0026lt;slv num\u0026gt; \u0026lt;slv id\u0026gt; \u0026lt;phy\u0026gt; \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt; \u0026lt;downlink packet length byte 1\u0026gt; \u0026lt;downlink packet length byte 0\u0026gt; \u0026lt;uplink packet length byte 1\u0026gt; \u0026lt;uplink packet length byte 0\u0026gt; \u0026lt;broadcast packet length byte 1\u0026gt; \u0026lt;broadcast packet length byte 0\u0026gt;\nmode: 0: slave, 1: master slv num: Number of slaves. slv id: Slave ID. Ranges from 0 to (slave number – 1). The master will ignore this value. phy: PHY Rate. 1: 1Mbps, 2: 2Mbps. addr: Network Address downlink packet length: Maximum length of the downlink private packet. uplink packet length: Maximum length of the uplink private packet. broadcast packet length: Maximum length of the broadcast packet. Response: 0xA0 0x43 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1. Get RSSi: 0xA045 # This command get RSSI of the remote device.\nSend: 0xA0 0x45 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave id for master mode. Set it to 0 for slave mode. Response: 0xA0 0x45 0x00 0x02 \u0026lt;error code\u0026gt; \u0026lt;rssi\u0026gt;\nerror code: Refer to Table 1. rssi: RSSI. It is int8 value, use this fomular to get RSSI value : rssi-256 Start Pairing: 0xA110 # This command initiates the pairing process.\nSend: 0xA1 0x10 0x00 0x03 \u0026lt;pair num / require id\u0026gt; \u0026lt;timeout byte 1\u0026gt; \u0026lt;timeout byte 0\u0026gt;\npair num / require id: pair num: Used in master mode to specify the number of slaves to pair with. If set to 0, it will pair with all remaining unpaired slaves. require id: Used in slave mode. Specifies the desired slave ID that the slave expects, although the master may assign a different ID. If set to 0xFF, it uses the slave ID saved in flash memory. timeout: Timeout for pairing, measured in milliseconds. A value of 0 means no timeout. Response: 0xA1 0x10 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. Stop Pairing: 0xA147 # This command stops the pairing process.\nSend: 0xA1 0x47 0x00 0x00\nResponse: 0xA1 0x47 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. Delete All Pair Information: 0xA113 # This command deletes all pairing information. It is only available in master mode.\nSend: 0xA1 0x13 0x00 0x00\nResponse: 0xA1 0x13 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. Delete Pair Information: 0xA114 # This command un-pairs one device. It is only available in master mode.\nSend: 0xA1 0x14 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID Response: 0xA1 0x14 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. Get Connection Status of All Slaves: 0xA044 # This command allows the user to retrieve the connection status of each slave by issuing it from the master side. It is only available for the master.\nSend: 0xA0 0x44 0x00 0x00\nResponse: 0xA0 0x44 0x00 0x10 \u0026lt;connect status byte 0\u0026gt; \u0026lt;connect status byte 1\u0026gt;... \u0026lt;connect status byte 15\u0026gt;\nconnect status: Connection status of each slave. 1: connected, 0: disconnected. byte 0: the connection status of slave0 to slave7. byte 1: the connection status of slave8 to slave15. byte 15: the connection status of slave120 to slave127. The byte sequence of connect status is a bitmap, where each bit is associated with a slave. Byte 0 corresponds to slave0 to slave7, while Byte 1 corresponds to slave8 to slave15, and so forth. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to illustrate possible responses: Example 1: Assuming that the maximum number of slaves is set to four and all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00...0x00. Conversely, if only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00...0x00. Example 2: If the maximum number of slaves is set to nine and all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, if only slaves 0, 1, 6, 7, and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00...0x00.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packets, while the slave can only transmit private packets. Below, we will provide detailed instructions on how to use this command for both the master and the slave.\n① Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively straightforward.\nSend: 0xA0 0x48 \u0026lt;data length byte 1\u0026gt; \u0026lt;data length byte 0\u0026gt; \u0026lt;data byte 0\u0026gt; \u0026lt;data byte 1\u0026gt;....\u0026lt;data byte n\u0026gt;\ndata length: The length of the data. data: The actual data being transmitted. Response: 0xA0 0x48 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. ② Master transmits data. The master can transmit three types of packets to the slave: private, public, and broadcast. In the current firmware, we only support private and broadcast packets.\nSend: 0xA0 0x48 \u0026lt;data length byte 1\u0026gt; \u0026lt;data length byte 0\u0026gt; \u0026lt;packet type\u0026gt; \u0026lt;slv id\u0026gt; \u0026lt;data byte 0\u0026gt; \u0026lt;data byte 1\u0026gt;....\u0026lt;data byte n\u0026gt;\ndata length: The length of the data, which includes packet type and slv id. packet type: Packet type, where 0x00 indicates broadcast, 0x01 indicates public, and 0x02 indicates private. slv id: If the packet type is private, this byte represents the ID of the slave. For broadcast, 0 indicates stopping the broadcast, while 1 indicates continuously broadcasting this data packet. data: The actual data being transmitted. Response: 0xA0 0x48 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to Table 1. Set TX Power: 0xA0F5 # This command set TX power.\nSend: 0xA0 0xF5 0x00 0x01 \u0026lt;tx power\u0026gt;\ntx power: TX Power, see table 2. Response: 0xA0 0xF5 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Get UART Configuration: 0xA063 # This command reads the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nResponse: 0xA0 0x63 0x00 0x08 \u0026lt;baud rate byte 3\u0026gt; \u0026lt;baud rate byte 2\u0026gt; \u0026lt;baud rate byte 1\u0026gt; \u0026lt;baud rate byte 0\u0026gt; \u0026lt;data bits\u0026gt; \u0026lt;stop\u0026gt; \u0026lt;parity\u0026gt; \u0026lt;fc\u0026gt;\nbaud rate: The baud rate, with a maximum of 2000000. data bits: Data bits, range is 5 to 8. stop: Stop bits, where 0 indicates 1 stop bit and 1 indicates 2 stop bits. parity: Parity, where 0 indicates no parity, 1 indicates odd parity, and 2 indicates even parity. fc: Flow control, where 1 indicates enable and 0 indicates disable. Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 \u0026lt;baud rate byte 3\u0026gt; \u0026lt;baud rate byte 2\u0026gt; \u0026lt;baud rate byte 1\u0026gt; \u0026lt;baud rate byte 0\u0026gt; \u0026lt;data bits\u0026gt; \u0026lt;stop\u0026gt; \u0026lt;parity\u0026gt; \u0026lt;fc\u0026gt;\nbaud rate: The maximum baud rate is 2000000. data bits: The number of data bits, which can range from 5 to 8. stop: Stop bits configuration, where 0 indicates 1 stop bit and 1 indicates 2 stop bits. parity: Parity setting, where 0 means no parity, 1 represents odd parity, and 2 represents even parity. fc: Flow control, where 1 means enabled and 0 means disabled. Response: 0xA0 0x64 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nResponse: 0xA0 0x65 0x00 0x04 \u0026lt;baud rate byte 3\u0026gt; \u0026lt;baud rate byte 2\u0026gt; \u0026lt;baud rate byte 1\u0026gt; \u0026lt;baud rate byte 0\u0026gt;\nbaud rate: The maximum baud rate is 2000000. Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 \u0026lt;baud rate byte 3\u0026gt; \u0026lt;baud rate byte 2\u0026gt; \u0026lt;baud rate byte 1\u0026gt; \u0026lt;baud rate byte 0\u0026gt;\nbaud rate: The maximum baud rate is 2000000. Response: 0xA0 0x66 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. Misc Command # Chip Reset: 0xA0E1 # Reset the chip.\nSend: 0xA0 0xE1 0x00 0x00\nNo response\nFactory Reset: 0xA0EA # Reset the chip.\nSend: 0xA0 0xEA 0x00 0x00\nNo response\nGet Hex version: 0xA123 # Retrieve the version in hexadecimal format.\nSend: 0xA1 0x23 0x00 0x00\nResponse: 0xA1 0x23 0x00 0x04 \u0026lt;version bytes 3\u0026gt; \u0026lt;version bytes 2\u0026gt; \u0026lt;version bytes 1\u0026gt; \u0026lt;version bytes 0\u0026gt;\nversion: Version number in hexadecimal format. Get UUID: 0xA0EC # Retrieve the version in hexadecimal format.\nSend: 0xA0 0xEC 0x00 0x00\nResponse: 0xA0 0xEC 0x00 0x06 \u0026lt;UUID bytes 5\u0026gt; \u0026lt;UUID bytes 4\u0026gt; \u0026lt;UUID bytes 3\u0026gt; \u0026lt;UUID bytes 2\u0026gt; \u0026lt;UUID bytes 1\u0026gt; \u0026lt;UUID bytes 0\u0026gt;\nDummy Command: 0xA035 # Dummy command, do nothing.\nSend: 0xA0 0x35 0x00 0x00\nResponse: 0xA0 0x35 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. BLE Command # Set Chip Mode: 0xA0EE # Set chip mode Send: 0xA0 0xEE 0x00 0x01 \u0026lt;mode\u0026gt;\nmode: chip mode, 0:SMULL only, 1: SMULL and BLE concurrently Response: 0xA0 0xEE 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. Note: Must reset chip after set chip mode. Get Chip Mode: 0xA0ED # Get chip mode Send: 0xA0 0xED 0x00 0x00\nResponse: 0xA0 0xED 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. Start Advertising: 0xA302 # Start BLE advertising\nSend: 0xA3 0x02 0x00 0x00\nResponse: 0xA3 0x02 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. Stop Advertising: 0xA303 # Stop BLE advertising\nSend: 0xA3 0x03 0x00 0x00\nResponse: 0xA3 0x03 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. BLE Disconnect: 0xA304 # Send BLE disconnect command\nSend: 0xA3 0x04 0x00 0x00\nResponse: 0xA3 0x04 0x00 0x01 \u0026lt;error code\u0026gt; error code: Refer to table 1 for details. OTA Command # OTA Start: 0xA119 # Initiate the OTA command, available only for the master.\nSend: 0xA1 0x19 0x00 0x01 \u0026lt;type\u0026gt;\ntype: OTA PDU type, where 0 indicates broadcast and 2 indicates private PDU. Response: 0xA1 0x19 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA remote Update para: 0xA11D # The master updates the slave connection parameters for OTA, available only for the master.\nSend: 0xA1 0x1D 0x00 0x02 \u0026lt;slv id\u0026gt; \u0026lt;pkt len\u0026gt;\nslv id: Slave ID. Use 0xFF to broadcast to all slaves. pkt len: Maximum length of the OTA packet. Response: 0xA1 0x1D 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA local Update para: 0xA118 # Update the connection parameters for OTA.\nSend: 0xA1 0x18 0x00 0x01 \u0026lt;pkt_len\u0026gt;\nslv id: Slave ID. Use 0xFF to broadcast to all slaves. Response: 0xA1 0x18 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA local default para: 0xA11C # Reset connection parameters to default settings.\nSend: 0xA1 0x1C 0x00 0x00 \u0026lt;pkt len\u0026gt;\nResponse: 0xA1 0x1C 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA End: 0xA11A # Complete the OTA process.\nSend: 0xA1 0x1A 0x00 0x00\nResponse: 0xA1 0x1A 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA cmd: 0xA11B # The master sends OTA commands to the slave, available only for the master.\nSend: 0xA1 0x1B \u0026lt;len byte1\u0026gt; \u0026lt;len byte0\u0026gt; \u0026lt;slv id\u0026gt; \u0026lt;cmd\u0026gt; ...\nlen: Command length. slv id: Slave ID. Use 0xFF to broadcast to all slaves. cmd: OTA command bytes. Response: 0xA1 0x1B 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: Refer to table 1 for details. OTA result: 0xA11E # Retrieve the OTA result, available only for the master.\nSend: 0xA1 0x1E 0x00 0x00\nResponse: 0xA1 0x1E 0x00 0x11 \u0026lt;error code\u0026gt; \u0026lt;result byte 0\u0026gt; \u0026lt;result byte 1\u0026gt; ... \u0026lt;result byte 15\u0026gt;\nerror code: Refer to table 1 for details. result: 1 indicates success, while 0 indicates failure. byte 0: Result for slaves 0 to 7. byte 1: Result for slaves 8 to 15. \u0026hellip; byte 15: Result for slaves 120 to 127. Event # The event is a command that the device sends to the host.\nReady: 0xC102 # Indicates the completion of initialize. Must send UART command after receiving ready event.\nNotification: 0xC1 0x02 0x00 0x00\nReceive Data: 0xA049 # When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the host in the following format.\nNotification: 0xA0 0x49 \u0026lt;command length byte 1\u0026gt; \u0026lt;command length byte 0\u0026gt; \u0026lt;slv id/packet type\u0026gt; \u0026lt;data byte 0\u0026gt; \u0026lt;data byte 1\u0026gt; ...\ncommand length: Length of the command. slv id/packet type: For the master, this is the slave ID. For the slave, this is the packet type (0 = broadcast, 1 = public, 2 = private). data: Packet data. Pair End: 0xC003 # Indicates the completion of the pairing process.\nNotification: 0xC0 0x03 0x00 0x02 \u0026lt;error\u0026gt; \u0026lt;paired num\u0026gt;\nerror: Result of the pairing process; 0 indicates no error. paired num: Number of slaves that have been paired, applicable only in master mode. Pair One: 0xC002 # Indicates the successful pairing with one slave. This is available only in master mode.\nNotification: 0xC0 0x02 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Master Connect: 0xC007 # Indicates a successful connection to one slave. This is available only in master mode.\nNotification: 0xC0 0x07 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Master Disconnect: 0xC008 # Indicates a disconnection from one slave. This is available only in master mode.\nNotification: 0xC0 0x08 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Status: 0xC004 # Indicates a change in the device status, which will trigger this event.\nNotification: 0xC0 0x04 0x00 0x01 \u0026lt;status\u0026gt;\nstatus: Device status, where 0 indicates idle, 1 indicates pairing, 2 indicates connecting, and 3 indicates connected. Note: For the master, the connected status means all slave devices are connected. For the master, the connecting status means at least one slave is disconnected. Error: 0xC001 # Indicates an error has occurred. When in release mode, the device may reset or perform a factory reset.\nNotification: 0xC0 0x01 0x00 0x01 \u0026lt;error\u0026gt;\nerror: Error code indicating the type of issue. OTA Ack: 0xC100 # Indicates the result of an OTA command.\nNotification: 0xC1 0x00 \u0026lt;length byte 1\u0026gt; \u0026lt;length byte 0\u0026gt; \u0026lt;data byte 0\u0026gt; \u0026lt;data byte 1\u0026gt; ...\nlength: Length of the command. data: Result data indicating the outcome. Delete Slave Device : 0xC103 # Delete slave device pair information before enter pair mode\nNotification: 0xC1 0x03 \u0026lt;mode\u0026gt;\nmode: 0: delate all slave devices, 1: only delete slave devices that is in disconnect status. Debug Command # The debug command is intended for debugging purposes only. Please note that it SHOULD NOT be used in actual projects. This command has not been fully tested and may be removed or modified in future versions.\nSet Debug Mode: 0xA11F # Send: 0xA1 0x1F 0x00 0x01 \u0026lt;mode\u0026gt;\nmode: 1 for debug mode, 0 for release mode. Response: 0xA1 0x1F 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Read RAM Log: 0xA115 # The master reads the log stored in the slave\u0026rsquo;s RAM. This command is only available in master mode, and the master prints the log to the log UART.\nSend: 0xA1 0x15 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Response: 0xA1 0x15 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Reset RAM Log: 0xA116 # The master resets the slave\u0026rsquo;s log pointer, allowing the master to re-read the log from the slave. This command is only available in master mode.\nSend: 0xA1 0x16 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Response: 0xA1 0x16 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Read Slave Flash Log: 0xA124 # Read the log stored in the slave\u0026rsquo;s flash memory.\nSend: 0xA1 0x24 0x00 0x00\nResponse: 0xA1 0x24 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Reset Slave Flash Log: 0xA125 # Reset the pointer for the slave\u0026rsquo;s flash log.\nSend: 0xA1 0x25 0x00 0x00\nResponse: 0xA1 0x25 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Dump Flash Log: 0xA126 # Dump the contents of the flash log.\nSend: 0xA1 0x26 0x00 0x00\nResponse: 0xA1 0x26 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Erase Flash Log: 0xA127 # Erase the contents of the flash log.\nSend: 0xA1 0x27 0x00 0x00\nResponse: 0xA1 0x27 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Set Command UART ID: 0xA117 # Set the command UART ID. If the command UART ID is the same as the log UART ID, the hexadecimal characters of the command will be printed in the log UART.\nSend: 0xA1 0x17 0x00 0x01 \u0026lt;uart id\u0026gt;\nuart id: Command UART ID. Response: 0xA1 0x17 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Remote Command: 0xA201 # Send a command from the master to the slave.\nSend: 0xA2 0x01 \u0026lt;len byte 1\u0026gt; \u0026lt;len byte 0\u0026gt; \u0026lt;slv id\u0026gt; \u0026lt;cmd byte 0\u0026gt; \u0026lt;cmd byte 1\u0026gt; ...\nlen: Command length. slv id: Slave ID. cmd: Command bytes. Response: 0xA2 0x01 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. GPIO Config: 0xA120 # Configure GPIO settings.\nSend: 0xA1 0x20 0x00 0x05 \u0026lt;port\u0026gt; \u0026lt;pin\u0026gt; \u0026lt;pinmux\u0026gt; \u0026lt;oe_ie\u0026gt; \u0026lt;pull_up_down\u0026gt;\nport: GPIO port. pin: GPIO pin. pinmux: GPIO pinmux. oe_ie: OE/IE setting, where 0 = High Z, 1 = input, 2 = output, 3 = input and output. pull_up_down: Pull up/down setting, where 0 = no pull up/down, 1 = pull up, 2 = pull down. Response: 0xA1 0x20 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. GPIO Output: 0xA121 # Configure GPIO output level.\nSend: 0xA1 0x21 0x00 0x03 \u0026lt;port\u0026gt; \u0026lt;pin\u0026gt; \u0026lt;output\u0026gt;\nport: GPIO port. pin: GPIO pin. output: Output level, where 1 = high and 0 = low. Response: 0xA1 0x21 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. GPIO Input Status: 0xA122 # Get the status of GPIO input.\nSend: 0xA1 0x22 0x00 0x02 \u0026lt;port\u0026gt; \u0026lt;pin\u0026gt;\nport: GPIO port. pin: GPIO pin. Response: 0xA1 0x22 0x00 0x02 \u0026lt;error code\u0026gt; \u0026lt;status\u0026gt;\nerror code: See table 1. status: GPIO input status, where 1 = high and 0 = low. Get Superframe Duration: 0xA03A # This command retrieves the superframe duration in slots. Refer to Figure 2 for an illustration of the superframe.\nSend: 0xA0 0x3A 0x00 0x00\nResponse: 0xA0 0x3A 0x00 0x02 \u0026lt;superframe duration byte 1\u0026gt; \u0026lt;superframe duration byte 0\u0026gt;\nsuperframe duration: Duration of the SMULL superframe. Stop HBT timer： 0xA128 # This command stop the heartbeat timer.\nSend: 0xA1 0x28 0x00 0x00\nResponse: 0xA1 0x28 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Start HBT timer： 0xA129 # This command restart the heartbeat timer.\nSend: 0xA1 0x29 0x00 0x00\nResponse: 0xA1 0x29 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Read Register # This command stop the heartbeat timer.\nSend: 0xA1 0x2C 0x00 0x04 \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt;\nResponse: 0xA1 0x2D 0x00 0x05 \u0026lt;error code\u0026gt; \u0026lt;value byte 3\u0026gt; \u0026lt;value byte 2\u0026gt; \u0026lt;value byte 1\u0026gt; \u0026lt;value byte 0\u0026gt;\nerror code: See table 1. Write Register # This command stop the heartbeat timer.\nSend: 0xA1 0x2D 0x00 0x04 \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt; \u0026lt;value byte 3\u0026gt; \u0026lt;value byte 2\u0026gt; \u0026lt;value byte 1\u0026gt; \u0026lt;value byte 0\u0026gt;\nResponse: 0xA1 0x2D 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Deprecated Command # These commands will be deprecated in future versions and should not be used in any new projects.\nGet Firmware Version Number: 0xA0EB # This command retrieves the firmware version.\nSend: 0xA0 0xEB 0x00 0x00\nResponse: 0xA0 0xEB 0x00 0x06 \u0026lt;version byte 0\u0026gt; \u0026lt;version byte 1\u0026gt; ... \u0026lt;version byte 6\u0026gt;\nversion: Firmware version. The version number is a string formatted as \u0026ldquo;v\u0026lt;hex num byte 2\u0026gt;.\u0026lt;hex num byte 1\u0026gt;.\u0026lt;hex num byte 0\u0026gt;\u0026rdquo;. See \u0026ldquo;Get Hex version\u0026rdquo;. Set network Address (Network Address): 0xA016 # This command sets the network address. The value 0x00000000 will be ignored, and the address will not be updated. The value 0xFFFFFFFF is also not accepted.\nSend: 0xA0 0x16 0x00 0x04 \u0026lt;addr byte 3\u0026gt; \u0026lt;addr byte 2\u0026gt; \u0026lt;addr byte 1\u0026gt; \u0026lt;addr byte 0\u0026gt;\naddr: Network address. Response: 0xA0 0x16 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Successful Pairing Notification: 0xA03B # This command indicates that all slaves have been successfully paired with the master. This notification is automatically sent to the host when the pairing process is complete.\nNotification: 0xA0 0x3B 0x00 0x01 \u0026lt;error\u0026gt;\nerror: Result of the pairing process. Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Each slave in a network must have a unique ID. Only available for slave.\nSend: 0xA0 0x14 0x00 0x01 \u0026lt;slv id\u0026gt;\nslv id: Slave ID. Response: 0xA0 0x14 0x00 0x01 \u0026lt;error code\u0026gt;\nerror code: See table 1. Best Practice for Pairing # The slave can enter pairing mode using the command A1 10 00 03 FF 00 00, setting the slave ID to 0xFF and the timeout (tmo) to 0x00. This way, if it has already paired, the slave ID remains unchanged. If it has not been paired before, the slave ID will start from 0. The master can enter pairing mode using the command A1 10 00 03 00 00 00, setting the pair number to 0x00, which means it will wait until all slaves have completed pairing before exiting. First, use the \u0026ldquo;Delete All Pair Info\u0026rdquo; command to clear all pairing information. Then, let the master enter pairing mode before allowing each slave to enter pairing mode one by one. This way, the slave IDs will start from 0, allowing for confirmation of each slave\u0026rsquo;s ID. The master should first configure the necessary parameters (such as slave number, uplink/downlink packet length, broadcast packet length, and PHY) before entering pairing mode. Best Practice for Debugging # First, ensure the master is in debug mode. If the slave cannot conveniently print logs, the master can send the \u0026ldquo;Read RAM Log\u0026rdquo; command to retrieve the slave\u0026rsquo;s logs. It may be necessary to send this command multiple times to gather all logs. If the slave experienced an error and restarted, the master can send the \u0026ldquo;Read Slave Flash Log\u0026rdquo; command to retrieve logs from when the slave encountered the error. Both the master and slave can use the \u0026ldquo;Dump Flash Log\u0026rdquo; command to print logs from when errors occurred. If the slave cannot conveniently receive commands via the serial port, the master can use the \u0026ldquo;Remote Command\u0026rdquo; to send commands to the slave. This is equivalent to sending commands directly via the serial port. The master can use a broadcast packet (with slave ID set to 0xFF) to send commands to all slaves or use a private packet to send commands to a specific slave. For example, A2 01 00 08 FF A1 10 00 03 00 00 00 can be used to put all slaves into pairing mode. If the slave cannot conveniently use the serial port for commands, the \u0026ldquo;Remote Command\u0026rdquo; can be used to send \u0026ldquo;GPIO Config\u0026rdquo; and \u0026ldquo;GPIO Output\u0026rdquo; commands to toggle the GPIO pin of an LED, allowing the current slave ID to be determined. If the PC lacks sufficient serial ports, the command UART can be set to 0x1 using \u0026ldquo;Set Command UART ID\u0026rdquo;, making it the same as the log UART. This allows commands to be sent and logs to be viewed simultaneously through the log UART. Best Pratice for BLE # Set chip mode to 1 on master and all slave devices. Reset master and slave devices. (Optional) Re-pairing with all slave devices. Start advertising. Use phone to connect with master or slave. Send command to device through BLE RX characteristic . Check command response through BLE TX characteristic. BLE service UUID is \u0026ldquo;ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\u0026rdquo; BLE RX characteristic UUID is \u0026ldquo;28be4a4a-cd67-11e9-a32f-2a2ae2dbcce4\u0026rdquo;. Send command to device by GATT write. BLE TX characteristic UUID is \u0026ldquo;28be4cb6-cd67-11e9-a32f-2a2ae2dbcce4\u0026rdquo;. Device send response by GATT notify. "},{"id":58,"href":"/docs/in6xxe/user-guides/driver-integration/spi-guide.html","title":"SPI Communication","section":"Driver Integration","content":" SPI Guide # Overview # SPI, which stands for Serial Peripheral Interface, is a high-speed, full-duplex, synchronous communication bus that allows data transmission between a microcontroller and peripheral devices. It utilizes a master-slave model, with the master device controlling a set of slave devices. SPI requires four signal lines:\nSCLK for synchronization\nMOSI for data transmission from master to slave\nMISO for data transmission from slave to master\nSSN for selecting the slave device to communicate with.\nInit # Master # Refer to \u0026ldquo;proj_drv_spi_master\u0026rdquo;.\nConfigure spi master:\nspi_config_t config = {0}; config.dfs = SPI_DFS_8_BITS; //data frame size config.cs = 0; //slave select, only available for master SPI config.phase = 1; //phase config.polarity = 1; //polarity config.speed = 100000; //speed in Hz, only available for master SPI config.intr_prio = IRQ_PRI_Normal; //interrupt priority config.arg = NULL; //The variables needed in callback config.callback = spi_callback; //when spi process finished, callback set here will be invoked void *hdl = hal_spi_open(MSPI_ID, \u0026amp;config); //use MSPI_ID when it play the role as spi master Slave # Refer to \u0026ldquo;proj_drv_spi_slave\u0026rdquo;.\nConfigure spi slave:\nspi_config_t config = {0}; config.dfs = SPI_DFS_8_BITS; //data frame size config.phase = 1; //phase config.polarity = 1; //polarity config.intr_prio = IRQ_PRI_Normal; //interrupt priority config.arg = NULL; //The variables needed in callback config.callback = spi_callback; //when spi process finished, callback set here will be invoked config.trig_queue = TRIG_HP_QUEUE; //trigger queue void *hdl = hal_spi_open(SSPI1_ID, \u0026amp;config); Output(TX) # If data needs to be transferred from MOSI(when using master tx) or MISO(when using slave tx), we can use hal_spi_tx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nIf we want a faster speed, we can use the DMA mode, that is, replacing hal_spi_tx with hal_spi_tx_dma.\nstatic uint8_t tx_buf[256]; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_tx(hdl, tx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len); /* int hal_spi_tx(void *hdl, void *buffer, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *buffer: buffer need to tx buffer_len: tx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process. *actual_size: actual tx size. */ Input(RX) # If data needs to be received from MOSI(when using master tx) or MISO(when using slave tx), we can use hal_spi_rx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nIf we want a faster speed, we can use the DMA mode, that is, replacing hal_spi_rx with hal_spi_rx_dma.\nstatic uint8_t rx_buf[256]; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_rx(hdl, rx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len);\t/* int hal_spi_Rx(void *hdl, void *buffer, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *buffer: buffer recived buffer_len: rx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process *actual_size: actual rx size */ TRX # If bidirectional data transmission is required, we can use hal_spi_trx. We can set a timeout when we require a timeout to interrupt the SPI process in case of a delay, or we can simply set a callback during SPI initialization when there is no need for interruption.\nstatic uint8_t tx_buf[256]; static uint8_t rx_buf[256]; uint16_t trx_len = 0; int ret = 0; for (int i = 0; i \u0026lt; sizeof(tx_buf); i++) { tx_buf[i] = i; } memset(rx_buf, 0, sizeof(rx_buf)); ret = hal_spi_trx(hdl, tx_buf, rx_buf, sizeof(tx_buf), 0, APP_SPI_TIMEOUT, \u0026amp;trx_len);\t/* int hal_spi_trx(void *hdl, void *wbuf, void *rbuf, uint16_t buffer_len, int poll, uint32_t tmo, uint16_t *actual_size); *hdl: handle return when we use hal_spi_open *wbuf: buffer need to transfer *rbuf: buffer received buffer_len: rx buffer length poll: if need to use poll.when use poll mode, timeout should not be set to 0. tmo: timeout for spi process *actual_size: actual rx size */ Cancel SPI process # when we want to stop and cancel spi process, we can use hal_spi_cancel.\nint ret = hal_spi_cancel(hdl); //hdl: handle return when we use hal_spi_open Close SPI # when SPI case finished, we can close SPI device with hal_spi_close.\nint ret = hal_spi_close(hdl); //hdl: handle return when we use hal_spi_open "},{"id":59,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/spi-sample.html","title":"SPI Sample","section":"Driver Examples","content":" SPI Sample # Overview # SPI (Serial Peripheral Interface) communication is a synchronous serial transmission specification typically used for communication between microprocessing control units (MCUs) and peripheral devices. This communication method is characterized by its high speed, full-duplex, and synchronous nature, achieving data transmission through four wires (MISO, MOSI, SCLK, CS/SS) on chip pins.\nSPI communication consists of a master device and one or more slave devices. The master device initiates synchronized communication with the slave devices to complete data exchange. During the communication process, the master device configures and generates clock signals, which are used to synchronize data transmission. Each clock cycle transmits one bit of data, so the speed of data transmission is determined by the frequency of the clock signal.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_SPI in-dev/proj/driver/proj_drv_SPI_master in-dev/proj/driver/proj_drv_SPI_slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of both master and slave according to Uart Log and LED.\nWhen we transmit or receive data, we can get information on uart log. More information may be found in debug guide page.\nTest Steps # Master Setup and Download Open proj_drv_SPI_master, compile, and download the project. Press the reset button. Slave Setup and Download Open proj_drv_SPI_slave, compile, and download the project. Press the reset button. Testing Reset the slave first, then reset the master. We can see the data appearing in the LOG based on the selected mode of the master. master exchange data with slave. Each time the SPI master and slave receive data, the values range from 0x00 to 0xFF. "},{"id":60,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/timer-sample.html","title":"Timer Sample","section":"Driver Examples","content":" Timer Sample # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.\nThis routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_timer in-dev/proj/driver/proj_drv_timer Configuration # #define TEST_CASE SIMPLE_TIMER_ONCE After displaying \u0026ldquo;Select a number to test:\u0026rdquo; on the log, you can input a number between 0 and 2 to select a mode, including:\nenum { SIMPLE_TIMER_ONCE = 0, SIMPLE_TIMER_RELOAD, TIMER_EMIT, TIMER_CAPTURE, TIMER_MANUAL, };\tSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\n#define TMR_ID TMR0_ID Select the TMR ID to be used. This configuration is only effective for SIMPLE_TIMER_ONCE and SIMPLE_TIMER_RELOAD in the TEST CASE.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the status of gpio to Uart Log.\nSIMPLE_TIMER_ONCE: Start the timer and print \u0026ldquo;tmr_cb\u0026rdquo; after a timeout.\nSIMPLE_TIMER_RELOAD: Start the timer and continuously print \u0026ldquo;tmr_cb\u0026rdquo;.\nTIMER_EMIT: Start the timer and continuously emit Signal 2 on GPIO_2_7, Signal 3 on GPIO_2_8, and toggle Signal 1 on GPIO_2_2.\nTIMER_CAPTURE: Start the timer and continuously capture the signal on GPIO_0_3.\nTIMER_MANUAL: Start the timer in manual mode, where it counts down each time the corresponding register is written.\nMore information may be found in debug guide page.\nTest Steps # Open Keil and download the project. Press the reset button and observe the text test case: %d on the log, where %d represents the selected mode. Simple Timer Example: Depending on whether it is RELOAD or not, the callback may or may not appear repeatedly. If it is ONCE, it will stop after tmr cb. Emit \u0026amp; Capture: Two IN628E boards are required for testing. Download the emit program to Board 1 and the capture program to Board 2. After downloading, connect the signal pins (GPIO_2_7, GPIO_2_8, or GPIO_2_2) of Board 1 to the receiving signal pin (GPIO_0_3) of Board 2. Reset both boards simultaneously to receive signals on Board 2. "},{"id":61,"href":"/docs/in6xx/protocol-reference/ble/transparent-data-transmission-component-programming-guide.html","title":"Transparent Data Transmission Component Programming Guide","section":"BLE","content":" Overview # The component documented here is a software component that utilizes BLE GATT protocol to fulfill transparent data transmission over BLE devices. It is based on Inplay BLE application framework and provides set of simple APIs for the convenience of application development. Please refer to GATT Programming Guide for details.\nThe component consists of the Server and the Client part. The server is composed of GATT based services. It includes two characteristic values with one representing receiving (Rx) and the other representing sending (TX) and a client characteristic configuration descriptor. Once a client is connected, the server will notify the client of the maximum size of data transmission it supports through MTU exchange. The client obtains the handles of the characteristics including Rx, TX and Configure through the method of GATT Discover Service so that it can send data through the method of GATT Write. The server sends data to the other party through the method of GATT Notify.\nAll the functions of component must be called after BLE is initialized by ble_app_run().\nServer # Generally speeking, the peer who will generate data and provide it to the other peer without active request, will act as GATT server. The method in which server transmits data is called notify or indicate. These are included among in_trx_svc.c under proj/common/util directory.\nTo use the server of component, first step application should do is to call in_trx_svc_add to add GATT service to the server. Here is prototype of API.\n/** **************************************************************************************** * @brief Add trx service * * @param[in] uuid\tCustomized service and characteristic UUID. If NULL, default UUIDs are used. *\t@see TRX_SVC_UUID, TRX_TX_UUID, TRX_RX_UUID * @param[in] start_hdl\tService\u0026#39;s start attribute handle. If 0, start handle is allocated by protocol *\tstack and returned. Otherwise, start handle is designated and function may *\treturn failed if it is already allocated. * @param[in] max_data_len\tmax data size to transmit/receive * @param[in] rx_callback\tThis callback will be called in gatt write request funtion * @param[in] p_cbf\tEvent callback which is previously passed into ble_app_config(). * * @return \u0026gt;0: Success. The value is service\u0026#39;s start handle * \u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_svc_add(uint8_t uuid[3][INB_UUID_128_LEN], uint16_t start_hdl, int max_data_len, ble_app_cbf_t *p_cbf, int (*rx_callback)(int, uint8_t*, int)); If the service has security requirment, call following function to set security\n/** **************************************************************************************** * @brief set service\u0026#39;s SMP right * * @param[in] perm\tpermission @see enum inb_att_perm * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_svc_set_perm(enum inb_att_perm perm); Now Transparent Data Transmission service is created and application is able to transmit and receive data once it is connected with peer client.\nThe server transmits data to the client by:\n/** **************************************************************************************** * @brief Trx notify function * * @param[in] conidx\tID allocated by BLE stack after the connection is established with peer device * @param[in] buf\tnotify data buffer * @param[in] len notify data length * @param[in] ack gatt indicate method is used when true * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_notify(int conidx, uint8_t *buf, uint32_t len, bool ack); Application is informed by rx_callback function when the data is received from the client.\nint (*rx_callback)(int conidx, uint8_t *p_data, int data_len) The first parameter of the callback function represents the ID allocated by BLE stack after the connection is established with peer device; the second refers to the data, while the third represents the data length. Note that this callback function is running at the internal task, it is not recommended to call other BLE APIs in the callback function.\nClient # Accordingly, the peer who will receive data and consume it from the other peer, will act as GATT client. The method in which client transmits data is called write. These are included among in_trx_client.c under proj/common/util directory.\nSimilar to server component, first step application should do is to call in_trx_clt_init to initialize client. Here is prototype of API.\n/** **************************************************************************************** * @brief Init trx client * * @param[in] svc_uuid\tService UUID * @param[in] start_hdl\tService\u0026#39;s start attribute handle. If it is not 0, start handle *\tis designated and thus Service Discovery Procedure is not performed. * @param[in] max_data_len\tmax data size to transmit/receive * @param[in] p_cbf Event callback which is previously passed into ble_app_config(). * @param[in] rx_callback\tThis callback will be called in gatt notification event * * @return\t\u0026gt;0: Success. The value is service\u0026#39;s start handle *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_clt_init(uint8_t svc_uuid[INB_UUID_128_LEN], uint16_t start_hdl, int max_data_len, ble_app_cbf_t *p_cbf, int (*rx_callback)(int, uint8_t*, int)); The param is very similar to server API in_trx_svc_add. The only small difference is that if start_hdl is 0, the client needs to initiate the SDP process to obtain information about the service, and the duration of this process depends on the size of the connection interval. The client will automatically adjust the connection parameters to the minimum before the SDP process to quickly complete it, and then adjust them back to the original application-defined connection parameters.\nThe SDP is started by calling in_trx_clt_enable when client divice is connected with peer server device and connection is acceptable.\n/** **************************************************************************************** * @brief Enable trx client * * @param[in] conidx\tID allocated by BLE stack after the connection is established *\twith peer device * @param[in] bd_addr\tpeer device\u0026#39;s BLE mac address * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_clt_enable(int conidx, uint8_t bd_addr[BLE_BDADDR_LEN]); It is usually called when GAP_EVT_CONN_REQ or GAP_EVT_BOND_REQ with its request as PAIRING_SUCCEED is recieved and corresponding event handler is called. Here is sample in proj_in_trx_client_UART in SDK.\nint main(void) { ... //Register application\u0026#39;s event handler ble_app_cbf_t* cbf = ble_app_get_default_cb(); cbf-\u0026gt;gap.evt_conn_ind = ble_conn_ind; ... static void ble_conn_ind(inb_evt_conn_req_t *p_req, inb_conn_cfm_t *p_cfm) { int ret; int i; conn_info_t *p_conn_info; //If it is in target_info, it must be a slave p_conn_info = conn_info_get_by_addr((bd_addr_t*)p_req-\u0026gt;peer_addr.addr); if (p_conn_info) { p_conn_info-\u0026gt;peer_conidx = p_req-\u0026gt;conidx+1; p_conn_info-\u0026gt;state = STATE_CONNECTED; //Only for Slave in_trx_clt_enable(p_req-\u0026gt;conidx, p_req-\u0026gt;peer_addr.addr); } } Till now, client is ready to exchange data with peer server. To transmit data call:\n/** **************************************************************************************** * @brief Trx Client send function * * \u0026amp;param[in] conidx\tID allocated by BLE stack after the connection is established * @param[in] ack\tuse GATT_WRITE_NO_RESPONSE write method if false * @param[in] buf\tnotify data buffer * @param[in] len notify data length * * @return Possible return @see enum inb_error. **************************************************************************************** */ int in_trx_clt_send(int conidx, bool ack, uint8_t *p_data, uint16_t data_len); The parameters are the same as those of the server interface.\nThe application of Tranparent Data Transmission component can be summarized in the following UML Sequence Diagram:\n"},{"id":62,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/trigger-example-guide.html","title":"Trigger Sample","section":"Driver Examples","content":" Trigger Sample # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger. Three types of priority can be chosen, TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE.\n#define OUTPUT_PORT 0 #define OUTPUT_PIN 1 define the output pin.\n#define TIRG_COND_PORT 0 #define TIRG_COND_PIN 3 define the trigger condition pin.\n#define DEBUG_PORT 0 #define DEBUG_PIN 4 define the debug pin.\n#define TEST_OUTPUT_CMD 0 //test output #define TEST_REG_WR_CMD 0 //test register write #define TEST_TIMER_CMD 1 //test set timer and wait timer #define TEST_REG_CP_CMD 0 //test compare the value in register #define TEST_REG_MASK_CP_CMD 0 //test mask compare the value in register #define TEST_REG_RW_CMD 0 //test register read and write #define TEST_RD_CMP_CMD_WAIT 0 // //test read and compare the value in register(wait) #define TEST_RD_CMP_CMD_NO_WAIT 0 //test read and compare the value in register(not wait) Change the operation mode.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get the trigger interrupt status on UART log.\nTEST_OUTPUT_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, it will output a high or low voltage level on the output pin based on whether it\u0026rsquo;s a rising or falling edge.\nTEST_REG_WR_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, value set will be written to register.\nTEST_TIMER_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, timer will be set, start and then stop.\nTEST_REG_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address.\nTEST_REG_MASK_CP_CMD When TRIG_CON_PIN experiences a rising edge or a falling edge, copy 4 bytes from source address to destination address with mask.\nTEST_REG_RW_CMD\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, read and write the register.\nTEST_RD_CMP_CMD_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nTEST_RD_CMP_CMD_NO_WAIT\nWhen TRIG_CON_PIN experiences a rising edge or a falling edge, compare the value in register with the expected value.\nMore information may be found in debug guide page.\n​\nTest Steps # Open Keil and select the desired functionality, then download proj_drv_trig. Press the K1 button and observe the text \u0026ldquo;main start\u0026rdquo; appearing in the log. When the trigger pin is triggered, you will see something like \u0026ldquo;irq 0x5\u0026rdquo; in Figure 1-1, where 5 represents the status. At the same time, the corresponding functionality will be implemented based on the selected option. "},{"id":63,"href":"/docs/in6xxe/user-guides/driver-integration/uart-guide.html","title":"UART Communication","section":"Driver Integration","content":" UART Guide # Overview # The Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol that enables serial data transmission between devices. It is widely used for communication between microcontrollers and various peripherals, such as computers, sensors, and other embedded systems.\nInitialization # Before using the UART interface, it needs to be properly initialized. Configure the UART settings according to the uart_init_t struct:\nuart_init_t init = {0}; init.baud_rate = 115200; /**\u0026lt; Baud rate (e.g., 9600, 115200, etc.) */ init.data_len = 8; /**\u0026lt; Data length (5, 6, 7, or 8 bits) */ init.stop_bit = 1; /**\u0026lt; Stop bit (1 or 2 bits) */ init.parity_en = 0; /**\u0026lt; Enable parity bit (0: disabled, 1: enabled) */ init.even_parity = 0; /**\u0026lt; Parity type (0: odd, 1: even) */ init.fc = 0; /**\u0026lt; Flow control (0: disabled, 1: enabled) */ init.no_intr = 0; /**\u0026lt; Interrupt mode (0: enabled, 1: disabled) */ init.prio = IRQ_PRI_Normal; /**\u0026lt; Interrupt priority */ init.rx_arg = NULL; /**\u0026lt; Argument for RX callback */ init.rx_cb = rx_cb; /**\u0026lt; RX callback function */ init.tx_arg = NULL; /**\u0026lt; Argument for TX callback */ init.tx_cb = tx_cb; /**\u0026lt; TX callback function */ uart_hdl = hal_uart_open(UART0_ID, \u0026amp;init); UART Transmission # UART TX by Interrupt # res = hal_uart_tx(hdl, buffer, buffer_len, poll); /** * @brief UART TX by interrupt * @note This function can be in either block or non-block mode. If TX completion callback function is not specified, this function will be blocked until TX completed. Otherwise, this function will return (non-block) without waiting for the TX completion. Later on, the TX completion callback function will be called from the driver\u0026#39;s interrupt service routine to indicate transfer completed, the exact transmit bytes, and any errors. * * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer to TX * @param[in] buffer_len Data buffer length * @param[in] poll 0: interrupt mode, 1: polling mode. * * @return Driver error return code, @see enum uart_err */ UART TX by DMA # res = hal_uart_tx_dma(hdl, buffer, buffer_len, poll); /** * @brief UART TX by DMA * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer pointer for TX * @param[in] buffer_len Data buffer length. Max 2047 for DMA transmission. * @param[in] poll 0: interrupt mode, 1: polling mode, disable interrupt in polling mode. * * @return Driver error return code, @see enum uart_err */ UART Reception # UART RX by Interrupt # res = hal_uart_rx(hdl, buffer, buffer_len, poll, tmo, actual_rx_len); /** * @brief UART RX by interrupt * @note This function can be in either block or non-block mode. If RX completion callback function is not specified, this function will be blocked until RX completed. Otherwise, this function will return (non-block) without waiting for the RX completion. Later on, the RX completion callback function will be called from the driver\u0026#39;s interrupt service routine to indicate transfer completed, the exact receive bytes, and any errors. * * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer to RX * @param[in] buffer_len Data buffer length * @param[in] poll 0: interrupt mode, 1: polling mode. * @param[in] tmo Timeout for block call. 0: means non-block call, need to set callback function. * @param[out] actual_rx_len Blocking call return the exact RX bytes * * @return Driver error return code, @see enum uart_err */ UART RX by DMA # res = hal_uart_rx_dma(hdl, buffer, buffer_len, poll, tmo, actual_rx_len); /** * @brief UART RX by DMA * @param[in] hdl Uart handle from the open API * @param[in] buffer Data buffer pointer for RX * @param[in] buffer_len Data buffer length. Max 2047 for DMA transmission. * @param[in] poll 0: interrupt mode, 1: polling mode, disable interrupt in polling mode. * @param[in] tmo Timeout for block call, 0: means non-block call, need to set callback function. * @param[out] actual_rx_len Blocking call return the exact RX bytes * * @return Driver error return code, @see enum uart_err */ Cancel UART RX # res = hal_uart_cancel_rx(hdl); /** * @brief Cancel UART RX * @note This function is used for both DMA and non-DMA modes. * @param[in] hdl The handle from the previous \u0026#34;open\u0026#34; function. * @return Driver error return code, @see enum uart_err */ "},{"id":64,"href":"/docs/in6xxe/examples-and-use-case/driver-examples/uart-sample-guide.html","title":"UART Sample","section":"Driver Examples","content":" UART Sample # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.\nIn this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.\nHardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_UART in-dev/proj/driver/proj_drv_UART Configuration # #define MODE 2 Change the operating mode by replacing the number 2 with 0, 1, or 2.\n0 is POLL mode, 1 is INTR mode, and 2 is DMA mode.\n#define EN_FLOW_CTRL 0 0 indicates disabled flow control, 1 indicates enabled flow control.\n#define UART_BAUDRATE 115200 Set the baud rate for UART.\nBuilding # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.\nDebug # We can get information simply on UART log.\nMore information may be found in debug guide page.\nTest Steps # Without Flow Control Open Keil and download the project. Press the reset button and observe the text \u0026ldquo;use poll mode\u0026rdquo; on the log, where \u0026ldquo;poll\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. With Flow Control Use the in_config tool to open the inc/in_config.h file in the corresponding project folder, check GPIO 1-5 and GPIO 1-6 under the peripheral section for MUX1, and connect them to CTS and RTS, respectively. Save the changes and open Keil to download the project. Open the debugger, check RTS or other flow control switches, and observe the text \u0026ldquo;use DMA mode\u0026rdquo; on the log, where \u0026ldquo;DMA\u0026rdquo; represents the selected mode. Input some characters in the input box and press \u0026ldquo;Send\u0026rdquo;. We receive the content that was just sent. "},{"id":65,"href":"/docs/solutions/multiconnnet/user-guild.html","title":"User Guild","section":"MultiConnNet","content":" MultiConnNet User Guild # Proper module configuration is essential before the MultiConnNet network can operate normally. However, it is necessary to understand the essential information beforehand.\nBoot Mode: The module can enter Boot mode when GPIO_0_4 is connected to GND during power-up or reset, allowing for firmware flashing, storage resetting, and other operations.\nInteractive Interface: By default, UART1 is used as interface between HOST and module, with GPIO_2_1 and GPIO_2_7 as TX and RX function, 921600 baud rate, 8N1. This can be reconfigured.\nLog Interface: By default, UART0 is used as log interface, with GPIO_0_2 as TX function, 921600 baud rate, 8N1. If interactive interface is changed, log interface changed automatically. For example, if interactive interface change to UART0，log interface will change to UART1 with GPIO_2_1 as TX function.\nPA Control IO: By default, GPIO_3_3 is used as TX enable function and GPIO_2_5 as RX enable function, no BIAS control. It can be reconfigured.\nConfiguration # The module is in a non-operational state until the network parameters are configured. There are two methods to configure the module\u0026rsquo;s network parameters: real-time configuration through the interactive interface, and static configuration via BLE connection. Regardless of the method used, the configuration commands are the same as what are documented in MultiConnNet Instruction Set.\nReal-Time Configuration # During real-time configuration, once the system is powered on and the module is ready (ready event sent), the HOST can send commands to the module through the interactive interface to configure and start the module, allowing it to operate as required. By sending different configuration parameters each time the module is powered on, different operations can be executed, hence the term \u0026ldquo;real-time configuration.\u0026rdquo;\nBLE Connection Static Configuration # When the module is in a non-operational state, it will start a connectable BLE advertisement. When a Master device, such as a smartphone, connects to the module, it can send commands to the module via the corresponding GATT Service to configure and start the module, enabling it to work as required.\nGenerally, configuration commands are sent first, followed by Run command to start the operation to test if the module operates correctly. Then restart the module and repeat the previous configuration, and store them. After that, when the module is powered on, it will automatically run, hence the term \u0026ldquo;static configuration.\u0026rdquo; Once the module can run automatically, it can only receive the corresponding commands through real-time configuration.\nHere is an example of the configuration steps for the gateway and node using the nRF Connect app on a smartphone.\nGateway Configuration # Step 1: Scan for the broadcast named \u0026ldquo;gateway\u0026rdquo; and click \u0026ldquo;connect\u0026rdquo; to establish a connection.\nStep 2: Once connected, a GATT service for configuration commands will appear.\nStep 3: Send the Network Parameter Configuration command 4A 05 1 01 23 45 67 AB AB AB AB 01 00 00 10 32 00 40 00 by GATT Write method, to configure gateway’s network parameters. The response to this command is sent back by GATT Notify method.\nStep 4: If everything goes well, restart the gateway and repeat Steps 1 to 3. Finally, send Reset command 4A 01 01 02 by GATT Write method, to save configuration before reboot. Then it will automatically run, even after power lost.\nFor detailed parameters in above command, please refer to the instruction set documentation.\nNode Configuration # Step 1: Scan for the broadcast named \u0026ldquo;node\u0026rdquo; and click \u0026ldquo;connect\u0026rdquo; to establish a connection.\nStep 2: Once connected, a GATT service for configuration commands will appear.\nStep 3: Send the Network Parameter Configuration command 4A 05 15 00 01 00 10 AB AB AB AB 25 20 03 20 4E 00 00 32 00 00 00 00 00 by GATT Write method, to configure the node’s network parameters. The response to this command is sent back by GATT Notify method. In this example, node’s device address is 0x0100. For configuring other nodes, this address must be different.\nStep 4 (option): Send the GPIO Input Configuration command 4A 07 04 04 01 00 01 by GATT Write method, to configure node’s GPIO_0_4 as input function and send its GPIO Input Trigger event to remote Gateway.\nStep 5: Send the Run command 4A 08 01 01 by GATT Write method, to start operation to test if previous configurations work correctly. Optionally, pull GPIO_0_4 to ground to trigger GPIO input event and remote gateway should receive corresponding event.\nStep 6: If everything goes well, restart the node and repeat Steps 1 to 4. Finally, send Reset command 4A 01 01 02 by GATT Write method, to save configuration before reboot. Then it will automatically run, log into the gateway, and maintain the connection, even after power lost.\nReset Configuration # There are two methods to reset the module:\n1. Real-time via Interactive Interface: Send the Reset command 4A 01 01 01 to the module through the interactive interface, with the option parameter set to 1. For detailed instructions, please refer to the MultiConnNet Module Instruction Set.\n2. Reset via JLINK: Use the Segger J-Flash tool to erase the Flash memory. For specific instructions on using the tool, refer to the JFlash Programming Guide. Execute the following command to erase the Flash at the specified address:\nGPIO Control # If optionally GPIO Input Configuration command is sent to node model (Step 4 in Node\u0026rsquo;s Configuration), the corresponding GPIO Input Trigger Event is sent to either local HOST or the remote gateway after being triggered locally, depending on the target field in the command.\nHere is gateway log snapshot:\nAccordingly, Gateway can also use GPIO Output command to control either local or remote node\u0026rsquo;s GPIO output level, depending on the \u0026ldquo;target device address\u0026rdquo; field in command. For example, send 4A 0A 04 04 01 00 01 to gateway to output GPIO_0_4 high on the node device of 0x0100. If there is a LED driven by GPIO_0_4 on node, LED can be turned on or off remotely.\nLow Power Mode # The Node\u0026rsquo;s UART Rx signal of the interactive interface needs to be grounded manually, for example GPIO_2_7, to let driver stop working and then module is able to enter sleep mode. Setting the UART Rx signal of the interactive interface to high can wake the module up from sleep mode, and communication recovers.\nData transmission # Data transmission can be categorized into two types: one is the remote control functionality like discussed earlier using GPIO control; the other is real-time data transmission via the interactive interface (UART) through sending data commands. For detailed commands, please refer to the instruction set documentation.\nDue to the remote control functionality in GPIO control, please ensure that the data sent by real-time data transmission does not start with 0x4A or 0xA4, to avoid the module mistakenly interpreting it as its own command.\nDemo Host Implementation on Windows # TBD\n"},{"id":66,"href":"/docs/solutions/stellar/stellar-gateway-wireless-communication-protocol-implementation-guide.html","title":"Wireless Communication Protocol","section":"Stellar","content":" Stellar Gateway Wireless Communication Protocol Implementation Guide # Purpose # This guide offers a comprehensive overview of the Stellar Gateway Wireless Communication Protocol, focusing on its practical implementation. Covering the design, functional operation, command structure, and safety precautions, it is tailored for developers, system integrators, and technical professionals who seek a deep understanding of how to effectively employ and optimize devices using the Stella Gateway Wireless Protocol.\nDefinition Glossary # BLE (Bluetooth Low Energy): A power-efficient version of the classic Bluetooth wireless technology. It\u0026rsquo;s designed for short bursts of long-range radio connection, making it perfect for IoT (Internet of Things) applications.\nSDR (Software Defined Radio): A radio communication system where traditional hardware components like modulators, demodulators, and tuners are instead implemented in software. This allows for more flexibility and adaptability in handling various frequencies and communication types.\nGATT (Generic Attribute Profile): A specification that describes in detail how attributes (data) are transferred once devices have connected using BLE.\nGATT Handler: Refers to the specific GATT characteristic or descriptor handle, which identifies a particular piece of data on a BLE device.\nBLE Peripheral: Refer to BLE standard Peripheral devices that gateway supports. It can be either BLE advertiser only (BLE beacon) or connectable peripheral devices.\nBLE Data Exchange: Refers to BLE data transmission and reception with connectable BLE Peripheral following standard BLE GATT protocol.\nSDR Network Address: InPlay SDR devices use two-layer addressing to support network communications. There are network address and device address. The network address is shared by all the devices in an SDR basic network.\nSDR Device Address: Each InPlay SDR device is assigned to have a 16-bit address. This address can be used to facilitate private data communication in a network with multiple SDR devices.\nSDR Broadcast: A kind of wireless signal transmission by SDR on broadcast channel, which does not concern if signals are actually received no not. In this case, SDR Device Address is not necessary.\nSDR Private Data Exchange: A kind of wireless signals transmission by SDR on non-broadcast channel between given SDR node and Stellar Gateway. If acknowledgement is not received from peer, communication is considered failed. In this case, SDR Device Address is necessary for both two sides of communication, in Stellar world, Stellar Gateway and SDR Node.\nSDR Node: Refer to slave devices by SDR in the Stellar Gateway network. It can be device that transmit SDR Broadcast only, or one that support SDR Private Data Exchange simultaneously.\nScanner Module: A functional component of Stellar Gateway that actively searches for available devices or signals of either SDR Broadcast or BLE advertisement within its vicinity.\nTransceiver Module: A functional component of Stellar Gateway that can transmit and receive signals of either SDR Private Data Exchange or BLE Data Exchange.\nController: Refers to the dedicated hardware or software component responsible for overseeing, managing, and directing the operations and data flow of the unit. It ensures that signals are received, processed, and transmitted appropriately, interfacing with both the Scanner Module and the Transceiver Module to achieve optimal performance.\nError Code: A system-defined numeric value that signifies a specific type of error or issue encountered during command execution.\nIntroduction # The Stellar Gateway Wireless Communication Protocol Implementation Guide delves deep into the Stellar Gateway Wireless Module\u0026rsquo;s practical use. This module is an integral component in today\u0026rsquo;s wireless communication ecosystems. It effectively integrates the Scanner and Transceiver modules, with the Controller MCU as the primary interface and managerial component.\nSystem Diagram # The Stellar Gateway system block diagram is shown in Figure1. The Stella Gateway contains 4 IN612Ls as key parts of Stella Gateway Wireless Modules. From the functional point of view, they can be subdivided into Scanner and Transceiver Module. Also present in the gateway is the Controller module, which serves as the connection between these two wireless modules and an interaction with the host.\nScanner Module: # Its primary function is to scan SDR Broadcasts or BLE Advertisements. It incorporates three IN612Ls, with each one designated to scan a specific channel.\nTransceiver Module: # One IN612L is in this module which dedicated on SDR P2P Data Exchange or BLE Data Exchange with connectable BLE Peripheral.\nController: # A third-party MCU typically processes commands from the host. Upon receiving these commands, it interprets them and sends the relevant data structure to both the Scanner and Transceiver for radio activities. Furthermore, this Controller acquires advertising or broadcasting reports from the Scanner, filters these reports, and subsequently sends a singular event to the Host. In Stella Gateway, the Controller uses AT32F413 and its development is beyond the scope of this document. Please visit ARTERY website for AT32F413 SDK and any reference development documents. This document aims to explain the data exchange protocols between the Controller and the Scanner/Transceiver.\nFigure 1: Stella Gateway diagram\nCommunication Interface # The interface between each IN612L and the Controller is USART bus. For AT32F413 controller, the USART ports with 612Ls are USART1, USART2, USART3, UART4.\nThe default USART parameters are as follows:\n921600 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled For interface between Controller and Host, Please refer to Stella Gateway Hardware User Guide for more details.\nCommand Description # Data exchanged between the Controller and Scanner/Transceiver is formatted as a byte array. All values follow the Big-endian convention (MSB first).\nModule Reset # This command is used to reset any IN612L in Scanner or Transceiver. It is essential for system maintenance and troubleshooting. The Reset command is unique in that no response is returned upon its execution.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 1 Command Id for \"Reset\" 1 Reset Option 1 1 System Reset Response: N/A\nExample:\n→01 01\nModule Configure # This command configures the type of IN612L, either as Scanner or Transceiver, as well as the SDR Broadcast access address and SDR P2P Data Exchange access address. It’s core setting command that must be executed first for system initialization. Once executed, it should NOT be called again unless the “Reset” command is issued.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 2 Command Id for \"Configure\" 1 Module 1 0: Scanner\n1: Transceiver Module type that IN612L configures to 2 SDR broadcast network address 4 32 bit Number Network address of SDR broadcast. If 0, SDR broadcast is not available 6 SDR private network address 4 32 bit Number Network address of SDR private data exchange. If 0, SDR private data exchange is not available 10 SDR address 2 0x0001 - 0xFF SDR address for gateway when SDR private data exchange. Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 2 Command Id for \"Configure\" 1 Result 2 Error Code Command Error Code Example:\n//Configure 612L as Scanner. SDR Broadcast on netword address 0x11223344, SDR Private Data Exchange on network address 0x33445566, and gateway\u0026rsquo;s SDR address is 1.\n→02 00 44 33 22 11 66 55 44 33 01 00\n//Configure 612L as Transceiver. SDR Broadcast on netword address 0x11223344, SDR Private Data Exchange on network address 0x33445566, and gateway\u0026rsquo;s SDR address is 1.\n→02 01 44 33 22 11 66 55 44 33 01 00\n//Command successful.\n←02 00 00\nModule Start Control # This command provides dynamic operational control (start or stop) of the Scanner or Transceiver. Only IN612L with same Module type which is set via “Configure” command can accept this command with same “Module” parameters.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 3 Command Id for \"Module Start Control\" 1 Module 1 0 , 1 0: Scanner\n1: Transceiver 2 SDR Channel 1 1 - 40 Channel SDR broadcast on. Available only for \"Scanner\" module. 3 SDR Window 2 0 - 4000 SDR broadcast scan time in microseconds. Available only for \"Scanner\" module. 0 to stop SDR scan. If SDR is not supported, its value is skipped. 5 BLE Channel 1 0 , 37 - 39 If 0, scan in turn on all three BLE advertising channel; or else scan on fixed channel. 6 BLE Window 2 0 - 4000 BLE advertising scan time in microseconds. Available only for \"Scanner\" module. 0 to stop BLE scan. 8 PHY 1 0: 1M\n1: 2M\n2: 125K\n3: 500K Physical rate 2 Sync Interval 2 0 , 100 - 60000 The time interval at which the Transceiver will transmit a synchronization signal. 0 to stop synchronization signal transmission. The shorter synchronize interval is, the more frequently SDR nodes wake up to exchange data with gateway and raise date rate of SDR Private Data Exchange accordingly. The cost is power consumption of the node. Available only for \"Transceiver\" module. If SDR is not supported, its value is skipped. Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 3 Command Id for \"Module Start Control\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Start SDR broadcast only scan every 1000ms on channel 15 on 1M PHY.\n→03 00 0F E8 03 00 00 00 00\n//Start BLE advertising only scan every 1000ms on all 37 to 39 channels on 125K coded PHY.\n→03 00 00 00 00 00 E8 03 02\n//Start Transceiver with sync interval 100ms.\n→03 01 64 00\n//Error Scanner parameter not set (0x0111).\n←03 11 01\nSet Scan Filter # This command allows setting a filter for the Scanner based on specific criteria to help in narrowing down and focusing on specific data while scanning. This command is allowed be executed dynamically while Scanner has started. Another way is to stop Scanner first, set the filter and start again, which makes scan report more clear and accurate. This command is acceptable for Scanner only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 4 Command Id for \"Set Scan Filter\" 1 Len 1 0 - 10 Filter bytes array length 2 Filter \u0026lt;Len\u0026gt; Bytes array Filter raw bytes array Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 4 Command Id for \"Set Scan Filter\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Set filter manufacturer ID 0x004c (Apple Inc).\n→04 02 4C 00\n//Command successful.\n←04 00 00\nSDR Multicast Data # This command initiates SDR multicast data to SDR nodes. Multicast data is transmitted over synchronizing signals in Transceiver as a result all kinds of SDR nodes can receive data. But it’s up to SDR node’s implementation (group id match etc.) whether data is acceptable. This command is acceptable for Transceiver module only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 5 Command Id for \"SDR Multicast Data\" 1 Group Id 1 0 - 255 Group Id that SDR node belongs to 2 Duration 2 unsigned short Time that the command executes in ms. 0 to stop. 4 Len 1 1 - 251 SDR multicast data length 5 Date \u0026lt;Len\u0026gt; - Multicast data Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 5 Command Id for \"Set Scan Filter\" 1 Result 2 16bits unsigned integer Command Error Code Example:\n//Send multicast data \u0026ldquo;00 01\u0026rdquo; to SDR nodes with group id 1 for 1000ms\n→05 01 03 e8 02 00 01\n*//Command completes successfully\n←05 00 00\nSDR Private Data Exchange # This command initiates SDR Private Data Exchange between Transceivers and single SDR nodes that support private data exchange. It’s direct, private two-way communication between node and gateway. This command is acceptable for Transceiver only.\nCommand:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 6 Command Id for \"SDR Private Data Exchange\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 6: SDR Node that support Private Data Exchange 7 Len 1 1 - 251 SDR Private Data length 8 Data \u0026lt;Len\u0026gt; byte array SDR Private Data Response:\nOFFSET NAME LENGTH VALUE NOTE 0 Command Id 1 6 Command Id for \"SDR Private Data Exchange\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 4: SDR Broadcast only Node 6: SDR Node that support Private Data Exchange 7 Result 2 16bits unsigned integer Command Error Code Example:\n//Send data \u0026ldquo;00 01\u0026rdquo; to SDR node [0x01, 0x01, 0x06]\n→06 01 00 00 00 01 06 02 00 01\n*//Command completes successfully\n←06 01 00 00 00 01 06 00 00\nBLE Connection # TBD\nBLE GATT Service Discovery # TBD\nBLE GATT Read # TBD\nBLE GATT Write # TBD\nEvent Description # When scanning, due to high-capacity nodes that gateway supports and limited resources of 612L, SDR Broadcast Report and BLE Advertising Report are dispatched in a structured manner, where the data frame is of a fixed size of 39 bytes. In this context:\nAn SDR broadcast signifies a method by which a software-defined radio sends information.\nA BLE advertisement indicates that a Bluetooth Low Energy device is publicly broadcasting data, often for discovery by other devices.\nFor this notification, if payload of an SDR broadcast or BLE advertisement exceeds 31 bytes, scanner will discard the rest and hense the payload is not complete.\nDuring private data exchange, transceivers are devices that both transmit and receive data. In this context, Transceiver event may be either data from given SDR node when engaged in SDR Private Data Exchange or BLE GATT Notification Data from BLE connectable peripheral.\nSDR Broadcast Report # The SDR Broadcast Report is an event in which the Scanner notifies the system when it captures an SDR broadcast. The detailed information about this broadcast is tabulated in the format mentioned, which includes the event ID, virtual ID of the SDR node, the group ID of the SDR node, etc. The event example demonstrates the structure in which the data is presented.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x64 Event Id for \"SDR Broadcast Report\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 4 4: SDR Broadcast only Node 6: SDR Node that support Private Data Exchange 7 Time Stamp 2 unsigned short Time stamp in 10ms unit when SDR broadcast is captured 9 RSSI 1 signed char Received Signal Strength Indicator in dBm 10 Len 1 1 - 27 SDR broadcast payload length 11 Payload \u0026lt;Len\u0026gt; byte array SDR broadcast payload Example:\n//SDR Broadcast from node [0x44,0x01,0x04], RSSI is 0xB6 (-74dBm), payload \u0026ldquo;D4 0A\u0026rdquo;\n←64 44 00 00 00 01 04 51 86 B6 02 D4 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nBLE Advertising Report # The BLE Advertising Report is an event when the Scanner captures a BLE advertisement. Information related to this event includes the event ID, BLE Mac Address, timestamp of the event, Received Signal Strength Indicator (RSSI), and other relevant data. An example to depict this structure is also provided.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x65 Event Id for \"BLE Advertising Report\" 1 MAC Adddress 6 - MAC Address of BLE advertiser (Beacon) 7 Time Stamp 2 unsigned short Time stamp in 10ms unit when advertisement is captured 9 RSSI 1 signed char Received Signal Strength Indicator in dBm 10 Flag 1 - Bit 7:1 Reserved Bit 0 0: Non-connectable\n1: Connectable 11 Len 1 1 - 27 BLE advertisement payload length 12 Payload \u0026lt;Len\u0026gt; byte array BLE advertisement payload Example:\nBLE advertising from 00:01:02:03:04:AB, RSSI is 0xAC (-84dBm), payload \u0026ldquo;07 09 49 6E 50 6C 61 79\u0026rdquo;\n←65 AB 04 03 02 01 00 94 C1 AC 01 07 09 49 6E 50 6C 61 79 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSDR Private Data Reception # The SDR Private Data Reception event signifies the reception of data directly from given SDR node. This event captures the essence of the data being transmitted from given SDR node that support private data exchange, which include details such as the virtual ID, group ID, type of SDR node, and the data itself. The accompanying example provides clarity on the data structured representation.\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x66 Event Id for \"SDR Private Data Recepiton\" 1 Virtaul ID 4 unsigned long Virtual ID of SDR node 5 Group ID 1 unsigned char Group ID that SDR node belongs 6 SDR Node Type 1 6 4: SDR Broadcast only Node (Beacon)\n6: SDR Node that support Private Data Exchange 7 Len 1 unsigned char Data Length 8 Data \u0026lt;Len\u0026gt; byte array Data Example:\n//SDR private data reception from node [0x44,0x01,0x06], data \u0026ldquo;D4 0A\u0026rdquo;\n←66 44 00 00 00 01 06 02 D4 0A\nBLE Data Reception # The BLE Data Reception is an event where the Transceiver receives data from BLE connectable node via GATT notification/indication method. The specifics of this event encapsulate the event ID, BLE peripheral\u0026rsquo;s MAC Address, and the data length received, along with the actual data payload. An example is provided to elucidate the structured format of the received data.\nEvent:\nOFFSET NAME LENGTH VALUE NOTE 0 Event Id 1 0x67 Event Id for \"BLE Data Recepiton\" 1 BLE MAC Address 6 - MAC address of peer BLE peripheral 7 Handle 2 unsigned short Handle of GATT characteristic that notify or indicate 9 Len 1 0 - 255 Data length 10 Data \u0026lt;Len\u0026gt; byte array Data Example:\n//BLE notify data from 11:22:33:44:55:66, handle is 0x0010, data is \u0026ldquo;D4 0A\u0026rdquo;.\n←67 66 55 44 33 22 11 10 00 02 D4 0A\nError Code # The error codes serve as a standardized way of communicating issues or successes between a device or system and its user or another system. Recognizing and understanding these codes can assist in diagnosing problems, troubleshooting, and ensuring smoother operations.\nError Code Description 0 Command was executed correctly 0x1001 Command was executed with error 0x0111 Not Ready 0x100A Error Command ID 0x100B Error Busy 0x100D Error Parameter 0x100E Error Timeout Others BLE error "}]