[{"id":0,"href":"/docs/in6xx/getting-started/testing/rtt-viewer-guide.html","title":"Rtt Viewer Guide","section":"Testing and Debuging","content":" RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection.\nConfiguration # Install J-Link # Should install in-dev\\tools\\ InPlayToolsSetup.exe first, get more information in JFlash Programming Guide\nConfig in in_config Config Tool # Usage # Auto Detection\nChoose IN6XX in Target Device\nClick OK to see the Log\nManual Detection\nChoose IN6XX in Target Device, and press Address , enter .map document(located in ) and search for address of _SEGGER_RTT.\nInput the address in the blank.\nNote:\nWhen the chip is reset or enters sleep mode, J-Link will disconnect. When the chip is running again, you need to click Connect to reconnect before the log is displayed.\n"},{"id":1,"href":"/docs/solutions/find-my/find-my-sdk-guide.html","title":"Find My Sdk Guide","section":"Find My","content":" InPlay Find My SDK Guide # Overview # The IN610 Find My SDK is compliant with the most recent versions of both Apple’s Find My Network Accessory Specification and Google’s Find My Device Network Accessory Specification. This guide provides detailed instructions for configuring, compiling, and installing the IN610 Find My SDK to implement an IN610-based Find My Network Accessory. A typical hardware block diagram for a Find My accessory is as below:\nThe accessory\u0026rsquo;s key components consist of the IN610 Bluetooth Low Energy (BLE) System-on-Chip (SoC), a key, a buzzer, and a motion sensor. The key acts as an input for one of the GPIOs on the IN610 BLE SoC, facilitating crucial user interactions such as restoring factory settings and turning the device on or off. The buzzer serves to emit sounds to aid in locating items, and when combined with the motion sensor, it can trigger an alarm to prevent unwanted tracking.\nThe SDK includes all essential hardware drivers and offers easy customization to meet your specific product needs.\nRequired tools # Before using the Find My SDK, users must install the necessary tools.\nCompiler and build tools # The SDK supports both Keil and GCC. Users can build their applications using either of tools.\nKeil # If Keil is used to build the project, below tools should be installed:\nTool URL or the path in the SDK Notes Keil MDK https://www.keil.com/download/product/ It is recommended to use version 5.29 or higher of the IDE for building the project. InPlayInc.DeviceFamilyPack.1.0.6.pack in-dev/tools Included in the SDK. Integrate IN610 support into Keil. GCC # Users can also build the project using GCC on either Windows or Linux. The required tools are ARM GCC and Make.\nARM GCC\nThe recommended ARM GCC toolchain is gcc-arm-none-eabi-9-2020-q2. It can be downloaded from the Downloads | 9-2020-q2-update – Arm Developer page. When installing the ARM GCC toolchain, ensure that the installation path does not contain special characters such as \u0026ldquo;(\u0026rdquo; or \u0026ldquo;)\u0026rdquo;.\nGNU make utility\nFor Windows, download the Make utility from Make for Windows and install it on your PC. If you\u0026rsquo;re using Ubuntu, install Make using the following commands:\nsudo apt-get update\rsudo apt-get install build-essential After installing Make on Windows or Ubuntu, ensure you add its path to the PATH environment variable.\nImage and token programming tools # Once users successfully build the project, they can download the application image to the IN610 using either the J-Link or UART interface. These are required tools:\nTool URL or path in the SDK Notes SEGGER J-Link https://www.segger.com/downloads/jlink/ Version 7.62 or higher is recommended. InPlayToolsSetup.exe in-dev/tools Included in the SDK. Add IN610 support for J-Flash The Windows application \u0026ldquo;inplay_programmer\u0026rdquo; included in the SDK (in-dev/tools/in_prog) can be used to download the application image by using UART.\nThe \u0026ldquo;in610_fmna_program\u0026rdquo; shown in below table is used to load the Apple token to IN610 either using J-Link or UART.\nTool URL or path in the SDK Notes Python 3.x https://www.python.org/downloads/ The In610_fmna_program utilizes a Python script to upload the Apple Find My token to the internal flash memory of the IN610. in610_fmna_program in-dev/proj/proj_ble_find_my/tools Included in the SDK. A toolset designed for loading the Apple Find My token to the internal flash memory of the IN610. Source code and software architecture # The source code for the Find My project is located in the in-dev/proj/proj_ble_find_my directory:\nbuild gcc: GCC build directory mdk: Keil MDK project file: proj_ble_lp.uvprojx inc: in_config.h is platform configuration file, fm_config.h is the Find My SDK configuration file. boards: Specific board configuration files lib: Apple and Google Find My libraries src app: Application layer, key operation definitions, storage, power on/off etc. bsp: Board Support Package, some necessary device drivers fmna: Apple Find My Network Accessory Specification related code nearby: Google Find My Device Network Accessory Specification related code utils tools in610_fmna_program: Tool to load Apple’s token to IN610 chip UARP: Apple’s UARP tools The architecture of the IN610 Find My software is illustrated as below:\nSoftware configuration # The configuration options for the IN610 Find My SDK are specified in the file \u0026ldquo;in-dev/proj/proj_ble_find_my/inc/fm_config.h\u0026rdquo;. This file includes a file named \u0026ldquo;fm_models.h\u0026rdquo;, which includes some hardware related macros. At the beginning of the file \u0026ldquo;fm_models.h\u0026rdquo;, a macro prefixed with \u0026ldquo;USE_\u0026rdquo; is defined to specify the target board. By default, the macro USE_DK is defined for InPlay\u0026rsquo;s IN610DK board:\n#define USE_DK //DK board, B0-07102021 If you want to adapt the SDK to a custom hardware platform, you need to define a new macro, such as USE_CUSTOMER_BOARD, and provide a corresponding platform configuration file, such as \u0026ldquo;in_config_customer.h\u0026rdquo;, in the boards directory.\nBSP configuration # The SDK\u0026rsquo;s Board Support Package (BSP) includes device drivers for key inputs, buzzer, and motion sensor functionalities. These drivers\u0026rsquo; source code can be found in the \u0026ldquo;bsp\u0026rdquo; directory.\nKey driver # The bsp_gpio_key.c file acts as the key driver, enabling features like single press, double press, and long press etc. To enable the GPIO key driver, set the macro USE_GPIO_KEY to 1 in the fm_config.h file. The key can be connected to any available GPIO pin, and the desired GPIO can be specified using the macro defined in fm_models.h:\n#define GPIO_KEY_PORT 0 // The GPIO port to which the key is connected.\r#define GPIO_KEY_PIN 0 // The pin of the GPIO port that connects to the key.\r#define GPIO_KEY_ACTIVE 1 // The active level of the GPIO key input. Note: The GPIO key input should always be active at a high level. In DK board, S3 is used as the GPIO Key, which is connected to GPIO_0_0.\nBuzzer driver # The bsp_buzzer.c file serves as the buzzer driver, utilizing PWM waveforms to drive a buzzer.\nBuzzers are classified into two types: magnetic buzzers and piezo buzzers. Magnetic buzzers produce sound by passing current through a coil, generating a magnetic field that moves a diaphragm to create sound waves. Piezo buzzers operate using the piezoelectric effect, where an alternating current causes a piezoelectric material to expand and contract, producing sound vibrations.\nTo generate a sound both magnetic buzzers and piezo buzzers require a PWM signal. The frequency of this PWM signal corresponds to the pitch of the note you want to play. Magnetic buzzers draw more current than piezo buzzers due to their fundamental design and operating principles. It is recommended to use piezo buzzers.\nThe IN610 features three GPIOs that support PWM:\nGPIO Port Number Pin Number PWM ID GPIO_0_2 0 2 PWM2_ID GPIO_1_7 1 7 PWM3_ID GPIO_1_8 1 8 PWM4_ID Users can select which GPIO to use for PWM by configuring the corresponding macro in fm_model.h:\n#define BUZZER_PWM_ID PWM2_ID //PWM id corresponding to the GPIO For magnetic buzzers, users can configure the active level of the PWM using the following macro. The active level defines the state in which the PWM signal enables a higher current to flow through the coil:\n#define BUZZER_ACTIVE_LEVEL 1 The buzzer driver allows users to customize sounds by defining buzzer sequences for various states of the Find My accessory device. Each entry in the sequence can specify how long the buzzer remains active, how long it stays inactive, and the PWM frequency during its active state. In the SDK, the following buzzer sequences are available and defined in \u0026ldquo;app_buzzer.c\u0026rdquo;:\nBuzzer sequence variable When to be used g_power_on_seq The Find My accessory is powered on g_power_off_seq The Find My accessory is powered off g_play_sound_seq Played when playing sound through App, or unwanted tracking with motion detected g_reset_seq Factory reset successfully g_unpair_seq Unpaired successfully g_paired_seq Paired successfully Examples of buzzer sequence definitions are available in the app_buzzer.c file. One such example is the power-on sequence, which users can configure to play sounds when the device is powered on:\nbuzzer_seq_t g_power_on_seq = {\r.evt = g_power_on_evts,\r.repeat_count = 1,\r.seq_len = 3,\r}; The g_power_on_seq buzzer sequence consists of three entries (defined by seq_len), each specifying its on duration (in 10 ms), off duration, and PWM frequency (in Hz). The repeat count is set to 1, meaning the entire sequence (comprising the three entries) will play once.\nUsers can call the bsp_buzzer_start_seq function to play a buzzer sequence, as shown in the following example:\nbsp_buzzer_start_seq(\u0026amp;g_power_on_seq). Motion sensor driver # The \u0026ldquo;bsp_acc.c\u0026rdquo; is the motion sensor driver. Currently, the SDK supports only the LIS2DH12 as the motion sensor. The driver allows users to specify the IN610 I2C interface in use, along with one GPIO pin that can receive interrupts from the motion sensor.\nThe bsp_acc.c file serves as the motion sensor driver. Currently, the SDK supports only the LIS2DH12 motion sensor. The driver allows users to configure the IN610 I2C interface and specify the GPIO pin for receiving interrupts from the motion sensor.\nThe IN610 offers two options for the I2C interface, as outlined in below table:\nI2C ID SCL\tSDA I2C0_ID GPIO_0_0 I2C1_ID GPIO_4_0 Users can select the desired interface by setting the I2C_BUS macro in fm_models.h as follows:\n#define I2C_BUS I2C0_ID // Select I2C0 for the interface The I2C address of the LIS2DH12 is determined by its SA0 pin state. If the SA0 pin is high (internally pulled-up by default), the address is 0x19. Configure this address using the I2C_ADDR macro:\n#define I2C_ADDR 0x19 // I2C address of the motion sensor chip The LIS2DH12 motion sensor generates interrupts via its INT1 and INT2 pins. The SDK uses the INT2 pin for the interrupt source for the IN610 device. When the sensor is stationary, the INT2 pin outputs a high signal. Upon detecting motion, the pin transitions to low. When returning to a stationary state, it remains low for a brief period before returning to high. Users can specify the GPIO pin on the IN610 device connected to the INT2 pin using the INT2_PORT and INT2_PIN macros in fm_models.h, as shown below:\n#define INT2_PORT 2 //The port of the 2nd GPIO which can receiver interrupt from the motion sensor.\r#define INT2_PIN 8 // The pin of the 2nd GPIO which can receiver interrupt from the motion sensor. Battery driver # The “bsp_battery.c” file functions as the battery driver for monitoring the battery voltage of the Find My accessory device. If the battery directly supplies power to the IN610, the internal ADC channel (ADC_CH14) can be used to measure the supply voltage directly. If the battery does not directly supply power to the IN610, external ADC channels of the IN610 (ADC_CH0 is recommended) must be utilized to measure the battery level. It is important to note that for external ADC channels, the input signal range must remain within [0, 2.0V]. Users are advised to implement a suitable voltage divider to ensure that the input signal range is between [50 mV, 1950 mV] for optimal linearity.\nThe driver enables users to define battery levels as \u0026ldquo;Full,\u0026rdquo; \u0026ldquo;Medium,\u0026rdquo; \u0026ldquo;Low,\u0026rdquo; and \u0026ldquo;Critical Low\u0026rdquo; based on the measured battery voltage (in millivolts, mV). These levels can be customized by modifying an array in the bsp_battery.c file, which maps specific voltage ranges to corresponding battery levels.\nFor rechargeable batteries, two threshold sets must be configured:\ng_vbat_thr in the bsp_battery.c file for batteries not in a charging state. g_vbat_chrg_thr for batteries in a charging state. For non-rechargeable batteries, thresholds can be defined using g_vbat_thr.\nThe SDK provides example thresholds for reference. For a non-rechargeable battery, the provided examples indicate the following:\nA voltage of 2810 mV or higher corresponds to \u0026ldquo;Full.\u0026rdquo; A voltage between 2650 mV and 2810 mV corresponds to \u0026ldquo;Medium.\u0026rdquo; A voltage between 2513 mV and 2650 mV corresponds to \u0026ldquo;Low.\u0026rdquo; A voltage below 2513 mV corresponds to \u0026ldquo;Critical Low.\u0026rdquo; Users can adjust the values to align with the specific characteristics of their battery.\nThe following macros can be defined in fm_models.h for configuring the battery driver:\n#define USE_CHARGER // Define this macro if a rechargeable battery is used\r#define BATT_TYPE 2 // Indicates a rechargeable battery; this value is used to initialize Find My libraries\r#define BAT_VOL_ADC_CH ADC_CH0 // Specifies the ADC channel used to sample battery voltage\r#define BAT_VOLTAGE_DIV ((1.2+1.5)/1.2) // Battery voltage divider configuration\r#define BAT_STABLE_DELAY (200000) // Delay (in microseconds) for battery voltage stabilization after reset; set to 0 for ADC_CH0. For mixed-signal pins, additional delay may be needed due to pull-up resistors. If a GPIO pin is connected to the charger for detecting the charging state, it can be defined as follows:\n#define GPIO_CHARG_DET 2,5 Note: If GPIO_CHARG_DET is not defined, the software cannot detect the charging state. Consequently, the g_vbat_chrg_thr parameter will not be used.\nTo ensure the tracker powers off automatically when the battery is low, define the following macro in bsp_battery.h to set the power-off voltage for the rechargeable battery:\n#define BAT_POWER_OFF_VOL 3300 // Power off battery voltage in millivolts (mV) If a load switch is used to control the battery voltage sampling, you can define the GPIO pin to manage the load switch as follows:\n#define GPIO_BAT_ADC_EN 1, 8 // Define GPIO to enable load switch\r#define ADC_EN_ACTIVE 1 // Define active level of the GPIO Boot Pin # The boot pin is utilized to signal the boot ROM of the IN610 that a firmware image or data (like Apple token) needs to be downloaded to the flash memory. In the SDK, the default boot pin is GPIO_1_6. If the boot pin is low during the transition of the chip from disabled to enabled (when the CHIP_EN pin goes from low to high), the chip will remain in the boot ROM, awaiting commands from any UART interface to initiate the firmware download. Users can also connect a J-Link to the IN610 in this state.\nSDK configuration # Several SDK configuration macros are defined in the fm_config.h file, as detailed in the following sub-sections.\nDebug option # The Keil project includes two targets: tracker (release version) and tracker_d (debug version). The differences between these targets are outlined in below table:\nTarget Linked libraries FMND_DEBUG defined? Description tracker fmna_lib.lib, nearby_lib.lib No Debug messages will not be output via UART. The \u0026ldquo;Debug Control Point\u0026rdquo; outlined in the \u0026ldquo;Find My Network Accessory Specification\u0026rdquo; is not activated. Less flash memory is needed. tracker_d fmna_lib_d.lib, nearby_lib_d.lib Yes Debug messages will be output via UART. The \u0026ldquo;Debug Control Point\u0026rdquo; outlined in the \u0026ldquo;Find My Network Accessory Specification\u0026rdquo; is activated. More flash memory is needed. Note:\nThe default debug UART interface is UART1 in the IN610 device, GPIO_2_1 as TXD and GPIO_2_7 as RXD. And the baud rate is 921600. If non-debug version libraries (libraries without \u0026ldquo;_d\u0026rdquo; suffix) are used, RAM log are not supported. Supported protocol # The SDK supports both the Apple Find My and Google Find My Device protocols. The tracker can be configured to support either one or both.\nIf the tracker is configured for one protocol, it can only join the corresponding predefined network. If configured for both, the end user can choose whether the tracker joins the Apple or Google network during a factory reset or the first-time power-on. To support the Apple Find My protocol, define the following macro in fm_config.h:\n#define USE_APPLE_TRACKER To support the Google Find My Device protocol, define the following macro:\n#define USE_GOOGLE_TRACKER Watchdog # Set the following macro to enable the IN610’s AON Watchdog. It is recommended to keep this enabled. To disable the WDT, set the macro to 0:\n#define USE_WDT 1 RAM log # Set the following macro to \u0026ldquo;1\u0026rdquo; to enable log printing to RAM. You can dump the logs using the InPlayOTA application. This option should be disabled for release versions:\n#define USE_RAM_LOG 1 DFT (Design for Test) BLE service # DFT service is a BLE service used to write SN, token or dump log. If users don’t need these features, users should set these options to “0”.\n#define USE_DFT_SVC 1 // If set to \u0026#34;1\u0026#34;, a BLE service will be included for testing purposes. For details, refer to app_dft.c.\r#define USE_DFT_ADV 0 // If set to \u0026#34;1\u0026#34;, an additional BLE advertisement for testing purposes will be enabled for 1 minute when entering pairing state. Google FMDN and Apple FMNA configuration # The configuration options for Google FMDN can be set using the nearby_cfg_t structure when calling nearby_init to initialize the Nearby library. Refer to nearby_user.h for the structure definition.\nSimilarly, the configuration options for Apple FMNA can be set using the fmna_cfg_t structure when calling fmna_init to initialize the FMNA library. Refer to fmna_user.h for the structure definition.\nIn app_power_state.c, the initialization is implemented as follows:\nGoogle FMDN is initialized with: nearby_init(\u0026amp;nearby_cfg, reset_reason, \u0026amp;g_app_cfg.fmdn_data); Apple Find My Network is initialized with: fmna_init(\u0026amp;fmna_cfg, \u0026amp;nv_data); The configuration options are defined as global variables (fmna_cfg and nearby_cfg). Certain members of these structures are initialized using macros.\nModel setup configuration # For the Google tracker, it is essential to correctly configure the model ID and anti-spoof private key; For the Apple tracker, the product data should be set correctly. They are defined as macros in \u0026ldquo;in-dev/proj/proj_ble_find_my/inc/fm_private.h\u0026rdquo;.\nNote: By default, these essential macros are set to invalid values. If they are not modified, the tracker will not work.\nMODEL_ID: Model ID distributed by Google ANTI_SPOOF_PRIV_KEY: Anti-Spoofing Private Key distributed by Google Refer to Fast Pair|Google for Developers to know how to register a model with Google.\nThe Anti-Spoofing Private Key distributed by Google is BASE64 encoded, it should be converted to hexadecimal format, some online tools can be used to do this:\nhttps://base64.guru/converter/decode/hex\nFor example, if the Base64-encoded private key string is: \u0026ldquo;AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyA=\u0026rdquo;\nConvert it to hexadecimal:\n\u0026ldquo;0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20\u0026rdquo;\nThen, define the private key in fm_private.h as follows:\n#define ANTI_SPOOF_PRIV_KEY \\\r0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, \\\r0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, \\\r0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, \\\r0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, For the Apple tracker, the product data must be set accurately which is also defined in \u0026ldquo;fm_private.h\u0026rdquo; as FMNA_PRODUCT_DATA.\nCertain common options must be configured for both Apple and Google, including firmware version number, manufacturer name, model name, capability, category, and battery type. Definitions for some macros related to capability, category, and battery type can be found in \u0026ldquo;fm_constants.h\u0026rdquo;.\nRF related configuration # Certain RF-related configurations must be adjusted to align with the hardware setup. For the IN610 chip, the gain code parameter is used to configure the RF Tx power. Typically, the following values are used:\ngain_code = 0x18: Tx power set to 0 dBm gain_code = 0x78: Tx power set to 4 dBm However, these values may vary depending on hardware specifics, such as the RF matching network.\nIn the IN610 SDK, the Tx power for each advertisement can be configured independently. During a connection, the Tx power used matches that of the corresponding advertisement.\nFor Apple Find My, the Tx power must be set to higher than 4 dBm. The relevant settings are members of the fmna_cfg_t structure:\ntx_pwr: Represents the Tx Power Level characteristic of the Tx Power Service for FMNA and should reflect the Bluetooth LE TRP (Total Radiated Power). tx_gain_code: Configures the Tx power setting of the chip for FMNA advertisements. For Google Find My, two types of advertisements are used: Fast Pair and FMDN. Fast Pair advertisements are active during pairing and FMDN advertisements are used after pairing.\nThe configurations are members of the nearby_cfg_t structure:\nfp_calibrated_adv_tx_pwr: The calibrated Fast Pair Tx power at 0m distance, measured in dBm. Refer to Fast Pair Materials and Technical Notes | Google for Developers on the Google Developers site. fp_tx_gain_code: Configures the Tx power setting for Fast Pair advertisements and must be lower than fmdn_tx_gain_code. fmdn_tx_gain_code: Configures the Tx power setting for FMDN advertisements. Apple Find My Serial Number interface # The serial number for Apple Find My is retrieved by the Apple Find My library using the function fmna_plat_get_serial_number in the file fmna_platform.c. By default, the serial number is generated from the chip UUID. However, if USE_NV_SN is set to \u0026ldquo;1\u0026rdquo;, the serial number can be read from flash memory instead.\nFunction interface # Functions declared in “fmna_platform.h” and “fmna_platform_uarp.h” are called by fmna lib. Functions defined in “nearby_platform_os.c” are called by nearby lib. Functions declared in “fmna_user.h” and “nearby_user.h” are APIs called by user application, which are implemented in fmna lib and nearby lib.\nFlash layout # The flash address 0x0 is mapped to 0x00300000 in the CPU addressing space. Below table provides detailed information about the flash layout.\n512KB Flash: # Address range Description 0x0 ~ 0x4000 Boot options and Boot RAM 0x4000~0x40000 Application bank A 0x40000~0x7B000 Application bank B 0x7B000~0x7E000 Pair information and keys 0x7E000~0x7F000 Apple software authentication token 0x7F000~0x80000 Reserved, can be used to store SN, etc. 1MB Flash: # Address range Description 0x0 ~ 0x4000 Boot options and Boot RAM 0x4000~0x80000 Application bank A 0x80000~0xFB000 Application bank B 0xFB000~0xFE000 Pair information and keys 0xFE000~0xFF000 Apple software authentication token 0xFF000~0x100000 Reserved, can be used to store SN, etc. Note: The SDK supports firmware upgrades using A/B banks. At any given time, the application program is stored in either Application Bank A or Application Bank B. Keil can only program firmware to Bank A. If the firmware is upgraded to Bank B, the sector at address 0x3000 must be erased before running a program loaded with Keil.\nUI customization # A Find My Accessory typically supports several operations, including enabling or disabling the Find My Network, performing a factory reset, and reading the serial number. This section offers guidance on how to customize these operations within the SDK.\nFind My Network disable/enable # The enable/disable function for Find My Network has been implemented as a power on/off feature in the SDK. When in power off state, the chip will enter deep sleep mode, which is a state where the system consumes minimal power. The user interface for power on/off is defined in app_key.c. To trigger power on/off operations, call the function app_power_set_state.\nNote: By default, a long press of the button for 3 seconds will initiate the power-on operation. To trigger the power-off operation, quickly press the button three times, then long press it for 5 seconds immediately afterward.\nFactory Reset # In app_key.c, you can initiate a factory reset by calling the function do_factory_reset.\nNote: By default, quickly press the button 5 times will trigger factory reset.\nRead Serial Number # In app_key.c, you can enable reading the serial number by calling the function enable_serial_read.\nNote: By default, a double press of the button activates the serial number read mode.\nMultiple BLE applications coexist # When multiple BLE applications are running simultaneously, they typically exhibit the following characteristics:\nEach application has its own type of advertising packets. Each application performs different actions during connection and disconnection. Each application defines its own unique GATT services. Multiple BLE applications can run simultaneously with the SDK, this is achieved through the following steps:\nWhen establishing a connection, map the connection index to the corresponding BLE application based on the type of advertising packet associated with the connection. Subsequently, in the callback function for the same connection index, invoke the callback function of the corresponding BLE application for processing. This feature is implemented in \u0026ldquo;app_ble.c\u0026rdquo;, user can register a BLE application with \u0026ldquo;app_ble_register\u0026rdquo; function. Each BLE application is defined with a \u0026ldquo;app_ble_t\u0026rdquo; type structure which is composed by a few BLE callback functions. BLE callback functions not implemented for the application should be filled with “NULL”. The \u0026ldquo;check_adv_actv\u0026rdquo; callback function is used to check if an activity index is related to the application, it should return 1 if this is true.\nBuild the project and load the program to the flash # Build the project with Keil # The Keil project file is “in-dev/proj/proj_ble_find_my/build/mdk/proj_ble_lp.uvprojx”, open it with Keil and then select the appropriate target (refer to Debug option). If the build is successful, a file named \u0026ldquo;ble_find_my.bin\u0026rdquo; will be generated in the \u0026ldquo;in-dev/proj/proj_ble_find_my/build/mdk\u0026rdquo; directory. That file is the firmware image users need to load it to the IN610\u0026rsquo;s flash.\nBuild the project with GCC # Follow below steps to build the project.\nUnzip InPlay SDK to any directory. If you\u0026rsquo;re using Ubuntu, open the file in-dev/proj/common/gcc/linux.mk and set the GNU_INSTALL_ROOT to the path of your ARM GCC installation. For Windows users, modify the in-dev/proj/common/gcc/windows.mk file instead. Note that in windows.mk, you should use forward slashes \u0026ldquo;/\u0026rdquo; as the path separator, rather than backslashes \u0026ldquo;\\\u0026rdquo;. For Ubuntu users, navigate to the “in-dev/proj/proj_ble_find_my/build/gcc directory and execute the following command in your terminal: make -j4 This will build a release version by default (No logs will output). If you want to build a debug version, run below command:\nmake -j4 EN_DEBUG=1 Run below command to clean the project, then you can rebuild the project:\nmake clean If the build is successful, a file named \u0026ldquo;ble_find_my.bin\u0026rdquo; will be generated in the \u0026ldquo;in-dev/proj/proj_ble_find_my/build/gcc\u0026rdquo; directory. That file is the firmware image users need to load it to the IN610\u0026rsquo;s flash.\nNote: If you build the project on Windows, PowerShell or Command Prompt are not supported. It is recommended to install Git for Windows and execute the \u0026ldquo;make\u0026rdquo; command in \u0026ldquo;Git Bash\u0026rdquo; shell.\nLoad the image to IN610L flash # The boot pin signals the boot ROM of the IN610 to initiate firmware image download to the flash memory. If the device is already programmed, its state may be uncertain (e.g., it could be in deep sleep or active mode). In such cases, the boot pin assists in preparing the device for image loading. Follow these steps to load an image to the flash:\nConnect the boot pin to ground (not required if the device has never been programmed). Perform a power cycle on the device or toggle the CHIP_EN pin from low to high. Use the preferred tool to load the image to the device’s flash memory. Load the image with J-Link # Flash Programming with Keil\nKeil supports flash programming via J-Link. For configuration details on the programming utility in Keil for IN610L, refer to Quick Start | InPlay Doc. After building the project, users can use Keil to load the image into the device\u0026rsquo;s flash memory.\nFlash Programming without Keil\nIf Keil is unavailable, users can load the firmware binary (e.g., ble_find_my.bin) using J-Link. Refer to IN610 J-Flash Download Guide.\nLoad the image with UART # If J-Link is unavailable, users can load the firmware binary (e.g., ble_find_my.bin) using \u0026ldquo;InPlay Programmer\u0026rdquo; tool through UART. Refer to InPlay Programmer Guide.\nRun the program # The default debug UART port is UART1, using GPIO_2_1 for Tx and GPIO_2_7 for Rx, with a baud rate of 921600. If the program is a debug version and executes successfully, logs will be output through the UART port.\nLoad Software Authentication Token / UUID # Every Apple Find My accessory must have a unique token issued by Apple Inc. This token will be utilized once during the pairing of the accessory, and a new token will be provided during the pairing process, which should then be stored in non-volatile memory. This section explains the process of loading software authentication tokens on Windows.\nToken item format # A token item in excel file is as: A token item has an UUID and a base64-encoded token value.\nRun the script # In610_fmna_program.py is the python script to load the token. It can support both J-Link and UART.\nLoad token with J-Link # Before running the script, follow JFlash Programming | InPlay Doc to make sure you can program IN610 flash with J-Link. You should also add the directory path that contains \u0026ldquo;J-Link.exe\u0026rdquo; to the PATH environment variable. You can refer Add to the PATH on Windows 10 and Windows 11 | Architect Ryan to know how to do this.\nTo load the token, connect J-Link to IN610 chip and run the script as below:\n512KB flash python ./in610_fmna_program.py --mfi-token [token-UUID] [token-base64] 1MB flash python ./in610_fmna_program.py --mfi-token [token-UUID] [token-base64] --flash 1 where token-UUID represents the UUID of the token and token-base64 is the base64-encoded token value.\nThis is an example:\n512KB flash python ./in610_fmna_program.py --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ 1MB flash python ./in610_fmna_program.py --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ --flash 1 Load token with UART # Before running the script, check section Load the image to IN610L flash to ensure the chip is in Boot ROM mode and ready to download an image via UART. To load the token, connect your PC to any UART port on the IN610 chip. Then, include the \u0026ldquo;\u0026ndash;com\u0026rdquo; parameter to specify the COM port number used for the connection. This is an example:\npython ./in610_fmna_program.py --com 89 --mfi-token 9748f95c-1678-4c73-9a77-15ed5c5473c9 MYG9ME0CAQECAQEERTBDAh8fGFpEniKAqaM+PoxcZc95fXq1p71bCC6KXoeB+89TAiAG8hHm33V/peyFz7f4Cqe+TmuoqW8qnVW+Z1nLXqD/gjBsAgECAgEBBGQxYjAJAgFmAgEBBAECMBACAWUCAQEECDfGbPyNAQAAMBECAgDKAgEBBAgAAAAAAAAACDAWAgIAyQIBAQQNMjYyOTgzLTczMDExMTAYAgFnAgEBBBB/5DXuqMpN+JOWBM/IEzc+ Generate UARP file # UARP is Apple’s Unified Accessory Restore Protocol. IN610 Find My SDK support firmware update compliant with UARP. Related files for this section are in proj_ble_find_my/tools/UARP directory.\nGenerate the input bin to \u0026ldquo;mfigr2\u0026rdquo; tool # Note: Below steps can be done in Windows or MacOS\nThe .uarp file is an upgrade package for UARP. To generate .uarp file, preprocessing is required on the bin file that is generated from compilation:\nCopy the generated binary file (ble_find_my.bin) to the same directory as script \u0026ldquo;generate_bin.py\u0026rdquo;, and rename it to \u0026ldquo;input.bin\u0026rdquo;, then double click on the \u0026ldquo;generate_bin.py\u0026rdquo;, a file named \u0026ldquo;output_hashed.bin\u0026rdquo; will be generated, and it will be used as input file in following steps. Copy output_hashed.bin to the same directory as MyUARPSuperBinary.plist and rename it as you like. Then fill version number and the input binary file name (renamed output_hashed.bin) in \u0026ldquo;MyUARPSuperBinary.plist\u0026rdquo;.\nUse \u0026ldquo;mfigr2\u0026rdquo; to generate .uarp file # Note: below steps can only be done in MacOS\nRun mfigr2 in shell to generate the UARP file (mfigr2 can only be executed in MacOS):\n./mfigr2 superbinary compose metaDataFilepath=UARPMFIMetaDataTable2.plist plistFilepath=MyUARPSuperBinary.plist payloadsFilepath=. superBinaryFilepath=MyUARPSuperBinary.uarp If the command executes successfully, a file named \u0026ldquo;MyUARPSuperBinary.uarp\u0026rdquo; will be generated, this is the final .uarp file, you can rename it as you like.\nUpgrade the Find My Accessory # Install the FMCA Application # Find My Certification Assistant requires a device running iOS or iPadOS 14.5 or later. Use your iPhone to open link Find My Certification Asst. on the App Store on the App Store. Clicking on the link will open the App Store application, where you can proceed to install the app.\nInstall Find My Network Configuration Profile # Testing accessory firmware updates requires the installation of the Find My Network Configuration Profile. Extract the contents of the file \u0026ldquo;FMCA Configuration Profile Jan 2024.zip\u0026rdquo; to obtain a file named \u0026ldquo;Find_My_Certification_Configuration.mobileconfig\u0026rdquo;. Transfer this file to your iPhone using AirDrop (it is recommended to use AirDrop). Next, navigate to the \u0026ldquo;Settings\u0026rdquo; app on your iPhone, where you will find the \u0026ldquo;Profile Downloaded\u0026rdquo; button.\nClick on the button and continue with the profile installation:\nAfter restarting your iPhone, you can verify its installation by checking in \u0026ldquo;Settings\u0026rdquo; -\u0026gt; \u0026ldquo;General\u0026rdquo; -\u0026gt; \u0026ldquo;VPN \u0026amp; Device Management\u0026rdquo;.\nUpdate the firmware # A UARP firmware file is denoted as \u0026ldquo;xxxx.uarp.\u0026rdquo; Begin by transferring the file to your iPhone. Prior to conducting the update, pair the Find My Accessory with your iPhone. Next, open the \u0026ldquo;FMCA\u0026rdquo; app, sign in using your Apple ID (which should be your company account), and locate your device under \u0026ldquo;My Items\u0026rdquo;. Select your device, then tap the \u0026ldquo;Firmware Settings\u0026rdquo; button. Choose the option to \u0026ldquo;Select a File\u0026hellip;\u0026rdquo; and pick the .uarp file. Ensure you do not leave the page, and proceed to open the \u0026ldquo;Find My\u0026rdquo; app. Select the device you wish to upgrade; if the .uarp file is recognized correctly, the \u0026ldquo;Update Available\u0026rdquo; button will be displayed as shown below. Then tap the button to start upgrading. If you can’t see “Update Available” button, try to restart your iPhone and repeat the above steps.\n"},{"id":2,"href":"/docs/solutions/modbus/wireless-modbus-demo-guide.html","title":"Wireless Modbus Demo Guide","section":"Wireless Modbus Network","content":" Wireless Modbus Demo Guide # Demo Connections # This guide demonstrates connecting the Wireless Modbus Module, featuring a port with four pins: Vin, GND, A, and B.\nLikewise, the Sensor and Relay devices offer one or more similar ports, each with pins designated as A, B, GND, and VCC. The \u0026lsquo;A\u0026rsquo; and \u0026lsquo;B\u0026rsquo; pins facilitate RS485 connections, while VCC and GND pins cater to power connections, requiring a power supply voltage of 5V or greater.\nConnection Guidelines # Ensure the correct pins are connected as advised below:\nA to A B to B V to V (either Vcc or Vin) G to G (represents GND) Configuration # It is crucial that the RS485 baud rate be set correctly. For example, the sensors support only 4800 bps. The relay RS485, however, is compatible with 4800, 9600, and 91200 bps. Hence, we suggest configuring both the Wireless Module and the relay to 4800 bps for peak performance.\nDemo GUI Guide # Modbus RTU Serial Client GUI version: 0.8\nThe Demo GUI\u0026rsquo;s main window features three dock windows—Indicator, Sensor, Command—a toolbar with various control buttons, and a status bar at the bottom displaying serial connection states and settings.\nThe Toolbar has changed in version: 0.9\nOperations # Steps:\nConfirm Serial settings Ascertain Modbus request and response patterns of relay and sensor Connect COM port Scan devices Control devices Serial Configuration # Navigate to Setting/com to open a dialog window and modify serial settings parameters such as baud rate, data bits, stop bits, parity, and timeout. Click \u0026ldquo;confirm\u0026rdquo; to apply these settings.\nRelay Configuration # Access Setting/relay to open a dialog window and adjust the relay settings:\nSearch\nCount: Number of \u0026ldquo;relay\u0026rdquo; devices found. This parameter may be omitted. Maximum: The number of devices required. The search halts when the count meets this figure. Read Pattern: Triggers a search for relay devices upon clicking the toolbar\u0026rsquo;s Relay Search button. For instance, xx, 01, 0000, 0008 represents a Read Coils request in Modbus RTU format without crc16. Control\nWrite Pattern: Functions akin to Read Pattern; employs Function 05 (05hex) Write Single Coil. Response Pattern: Reactions following the requests. Sensor Configuration # Select Setting/sensor to amend sensor configurations:\nMonitor\nStart ID: Commencing address ID of the sensor device when monitoring is active. End ID: Terminal address ID of the sensor device when monitoring is active. Read Pattern: Command request for procuring sensor data, using function code 03. Value Upon receiving the slave\u0026rsquo;s response, the GUI parses the data list and employs formulas to calculate values.\nConnect and Run # Choose the appropriate COM Port and hit the Connect button in the toolbar. The status bar will exhibit the connection state.\nVersion 0.9 as below:\nVersion 0.8 as below:\nPressing the Network Scan Discovery (which is Start All in v0.8) button ignites the Relay Search and Sensor Monitor, proceeding as per the Settings to dispatch requests. The Command dock window relays messages of both requests and responses.\nShould relay or sensor devices be located, the Indicator and Sensor dock windows will relay pertinent information such as \u0026ldquo;lamp buttons,\u0026rdquo; alongside temperature and humidity graphs.\nVersion 0.8 as below: Indicator and Sensor sections incorporate selectors and buttons for demonstrating various actions.\nAnd in version 0.9 update the sensor\u0026rsquo;s dock window:\nSet \u0026ldquo;Temp upper\u0026rdquo; and \u0026ldquo;Temp lower\u0026rdquo; to adjust the temperature display limits on the graph.\nManual Command Input # Located at the Command dock window\u0026rsquo;s base, a manual command input area exists for entry of Modbus RTU requests (sans crc). Click Send Request post-entry to dispatch the command.\nStatus in Command # The Command dock window\u0026rsquo;s Status presents a tally of the requests and responses.\nAn input field is provided to insert metrics for computing the packet loss rate. When left blank or set to zero, all data is considered in the statistic.\nMenu # Additional operations within the menu are outlined here. Clicking File/Restore Setting regenerates a default setting.json file, which is then loaded by the Setting menu option.\nEditing the setting.json file can be accomplished with an external editor, replacing the same-name file in the GUI program\u0026rsquo;s directory.\nThe View menu permits modification of the GUI\u0026rsquo;s visual appeal, such as font selection, and toggles the display status of Dock Windows.\nIn version 0.9, View menu permit toggles the display of \u0026ldquo;other tools\u0026rdquo; in toolbar.\nThe Help menu grants access to assorted explanatory documents, including a GUI usage guide.\n"},{"id":3,"href":"/docs/solutions/modbus/wireless-modbus-module.html","title":"Wireless Modbus Module","section":"Wireless Modbus Network","content":" Introduction to the Wireless Modbus Module # Overview of the Modbus Protocol # Modbus is an application-layer messaging protocol, designed in 1979 by Modicon, which facilitates master/slave interaction between devices. A de facto communication standard in industrial electronics, it has the following features:\nMaster-Slave Architecture: One master device issues commands to one or more slave devices that respond in kind. Data Representation: Modbus categorizes data as either coils (binary) or registers (numeric), offering diverse data manipulation capabilities. Variants: Modbus has adapted to different environments with variants like Modbus RTU, Modbus ASCII, and Modbus TCP/IP. The RS485 Communication Standard # RS485, or EIA-485, prescribes electrical specifications for drivers and receivers in digital multipoint systems. It is characterized by:\nExtended Communication Range: Capable of transmitting data up to 4000 feet (~1200 meters). Noise Resistance: Differential signaling provides robustness against voltage fluctuations and electromagnetic interference. Multi-Drop Configurations: Supports up to 32 devices on a single bus network. RS485\u0026rsquo;s reliability is a cornerstone of industrial controls in leveraging Modbus protocol.\nConnection # RS485 Connection # A standard RS485 wiring diagram depicting a \u0026ldquo;daisy-chain\u0026rdquo; topology is shown:\nConnection of the Wireless Modbus # Replacement of wired RS485 connections with a wireless module:\nFeatures of the Wireless Modbus Module # Firmware version 0.2\nThe module supports baud rates [in bps]: 1200 to 1000000, including automatic master node baud rate detection and synchronization.\nCommunication Between Master and Slave # The interaction comprises the master\u0026rsquo;s request, the slave\u0026rsquo;s response, and the corresponding response times as shown:\nExample timing for a 69-byte request and 8-byte response Modbus RTU query. Response timing across UART and wireless PHY settings:\nUART Settings Net PHY Speed Response Time [ms] 4800-8-1-E 1M 222 9600-8-1-E 1M 127 14400-8-1-E 1M 94 19200-8-1-E 1M 76 115200-8-1-E 2M 28 500000-8-1-E 2M 17 Configurations and User Interface # Configuration channels include ATCMD, UART-based commands, physical interfacing (buttons/switches), and upcoming BLE.\nLED Indicators # Two LEDs (Blue and Red) denote operational states. Patterns of their light signify network status and the network node mode. It varies as follows - fast flash, slow flash, and constant on. For example:\nState LED Activity LED Interval Network Loss Fast flash: 100ms on/off 500ms off Network Sync Continuous: 3sec on 500ms off Network Wait Slow flash(500ms on/off) 500ms off Dip Switch Configuration # Settings like SW1 and SW2 determine network status and node mode, respectively.\nSetting RS485 parity with SW3 and SW4.\nSwitch Function Description SW1 Network start/config On: Activate; Off: Default. See below. SW2 Node mode On: Master; Off: Slave. SW3 RS485 parity enable On: Enable parity; Off: Disable parity SW4 RS485 parity mode On: ODD Parity; Off: EVEN parity SW1 Configuration Details\nON to OFF: Trigger reconfiguration; a fast flash indicates readiness to reconfigure. AT Commands # Each command starts with AT and ends with a terminator. The command and response bodies vary by read parameter or result code.\nNormal AT Commands # Command Response Description AT+MODE=?, +MODE=[m,1,0] Read the device Mode. m: 1, master; 0, slave. AT+STATE=?, +STATE=[x,p,ch] Read net state. x:1, sync; 0, loss. p: phy. ch：channels AT+UART=? +UART=[baud,data,stop,parity,th] Read RS485 UART setting. baud:baudrate; data:data bits(8); stop: stop bits(0: 1bit, 1: 2bits), parity:(0:disable, 1: odd, 2: even); th: internal threshold. AT+PKTL=?, +PKTL=[up,dn] Read data packege size. up: uplink size; dn: downlink size AT+PKTL=[up,dn], Result code Write data packege size. up: uplink size; dn: downlink size AT+LOG=x Result code Write Log enable level x: bit[0:2]. 3 levels AT+ADDR=? +ADDR=[xxyyxxyy] Read net address. xxyyxxyy: address AT+ADDR=[xxyyxxyy] Result code Write net address. xxyyxxyy: address. sendAT+SYSCMD=3save config and sendAT+SYSCMD=1 to apply AT+VER=? +VER=[xxH] Read firmware version AT+NET=? +NET=[p,t,d,u] Read net information. p:phy, t: type, d:downlink length; u:uplink length AT+SYSCMD=x Result code Send system command. x: 1, reset; 2, restore; 3, save config. Responses follow the \u0026lt;CR\u0026gt;\u0026lt;LF\u0026gt; structure.\nResult Codes # Result codes for command outcomes:\n0 for success, 0x1001 for\tCommand execution error 0x100A for\tBad command 0x100B for\tBad format 0x100D for\tBad parameter 0x100E for\tOvertime Others for\tProtocol stack error Advanced Commands # There are also advanced commands for specialized tasks.\nFor detailed information, consult the Engineer\u0026rsquo;s Manual.\n"},{"id":4,"href":"/docs/in6xx/getting-started/testing/debug-guide.html","title":"Debug Guide","section":"Testing and Debuging","content":" Debug Guide # Introduction # Arm Keil MDK (Microcontroller Development Kit) provides robust debugging capabilities that are essential for efficient software development targeting Arm Cortex-M based microcontrollers. This document provides instructions on using the debugging features in Keil.\nDebug Step: # Enter debugging and run to main funtion # Enter debug mode, run program from flash to main function.\nOpen project, double click \u0026ldquo;proj_ble_lp.uvmpw\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click project option button, select \u0026ldquo;J-Link\u0026rdquo; in \u0026ldquo;Debug\u0026rdquo; page. Check the \u0026ldquo;Load Application at Startup\u0026rdquo; and \u0026ldquo;Run to main()\u0026rdquo; option. Click \u0026ldquo;\u0026hellip;\u0026rdquo; button, select script \u0026ldquo;jlink_flash_setup.ini\u0026rdquo; in \u0026ldquo;SDK\\in-dev\\proj\\proj_ble_find_my\\build\\mdk\u0026rdquo;. Click \u0026ldquo;Setting\u0026rdquo; button, select “SW” (single-wire interface) from the drop-down menu of “Port.” Then click “OK” to apply changes. Note:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the “SW Device” column, as illustrated below. If Keil can’t find device, reset DK and click “Scan” to rescan device.\nIf a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nClick \u0026ldquo;start debug\u0026rdquo; button to start debug session. Entering debugging while the program is running # When the program is running, enter debug mode, then halt the CPU at the current instruction.\nClick \u0026ldquo;Setting\u0026rdquo; button, uncheck \u0026ldquo;Reset afger Connect\u0026rdquo;, \u0026ldquo;Verify code Download\u0026rdquo; and \u0026ldquo;Download to Flash\u0026rdquo; option. Click \u0026ldquo;OK\u0026rdquo; button. Uncheck the \u0026ldquo;Load Application at Startup\u0026rdquo; option. Click \u0026ldquo;Edit\u0026rdquo; button, commit out this line \u0026ldquo;Setup_giga();\u0026rdquo; Click \u0026ldquo;OK\u0026rdquo; button. Click \u0026ldquo;start debug\u0026rdquo; button to start debug session. "},{"id":5,"href":"/docs/in6xx/protocol-reference/ble/gatt-programming-guide.html","title":"GATT Programming Guide","section":"BLE","content":" GATT Programming Guide # Overview # The GATT (Generic Attribute) is a standard profile in BLE protocol which defines a framework of services and characteristics using ATT attributes as building blocks. The ATT protocol defineds a flat set of data structure called attributes, while GATT defines a hierarchy so that the attributes are grouped into primary and secondary services and these services can include characteristics. GATT also defines how a device will discover, read, write, notify, and indicate the characteristics based on ATT attribute access method. The position of GATT in BLE protocol stack is shown in Figure 1.\nInplay provides the following GATT programming APIs. In this ducument, some major APIs will be introduced and the rest please refer to prototype description in inc/ble/inb_gatt.h for detail.\nint inb_gatt_exc_mtu(int conidx, uint16_t *p_mtu, comp_cb callback); int inb_gatt_sdp(int conidx, int sdp_type, inb_gatt_sdp_t *p_sdp, comp_cb callback); int inb_gatt_discovery(int conidx, int disc_type, inb_gatt_disc_t *p_disc, comp_cb callback); int inb_gatt_read(int conidx, int read_type, inb_gatt_read_req_t *p_req, comp_cb callback); int inb_gatt_write(int conidx, int wrt_type, inb_gatt_write_t *p_write, comp_cb callback); int inb_gatt_excute_write(int conidx, bool execute, comp_cb callback); int inb_gatt_register_ind_ntf_event(int conidx, bool reg, uint32_t start_hdl, uint32_t end_hdl, comp_cb callback); int inb_gatt_indication_cfm(int conidx, uint16_t handle); int inb_gatt_send_ind(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); int inb_gatt_send_ntf(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); int inb_gatt_send_svc_changed(int conidx, uint32_t svc_shdl, uint32_t svc_ehdl, comp_cb callback); int inb_gatt_add_svc(inb_gatt_svc_desc_t *p_svc, uint16_t *p_hdl, comp_cb callback); int inb_gatt_get_svc_perm(uint16_t start_hdl, uint8_t *p_perm, comp_cb callback); int inb_gatt_set_svc_perm(uint16_t start_hdl, uint8_t perm, comp_cb callback); int inb_gatt_get_att_perm(uint16_t handle, inb_att_perm_t *p_perm, comp_cb callback); int inb_gatt_set_att_perm(uint16_t handle, uint16_t perm, uint16_t ext_perm, comp_cb callback); int inb_gatt_get_att_value(uint16_t handle, inb_att_val_t *p_att_val, comp_cb callback); int inb_gatt_set_att_value(uint16_t handle, uint16_t length, uint8_t *value, comp_cb callback); int inb_gatt_att_info_req_cfm(int conidx, uint16_t handle, uint16_t length, uint8_t status); int inb_gatt_write_req_cfm(uint8_t conidx, uint16_t handle, uint8_t status); int inb_gatt_read_req_cfm(uint8_t conidx, uint16_t handle, uint8_t status, uint16_t length, uint8_t *value); You can see almost all APIs above have one common parameter callback which is of below type. If it is NULL, API call will be blocked until BLE protocol stack finishes processing the request. Otherwise, API will return immediately and the designated callback function will be called asynchronously when BLE protocol stack finishes processing the request. Application can utilize this time to perform their own tasks in parallel.\nOther APIs that do not have callback parameter just provide information to protocol stack and thus return immediately.\ntypedef void (*comp_cb)(int conidx, int status, void *p_para); Similar to ATT, GATT defines below two roles. A device may act as a server, a client, or both.\nClient: The client initiates transactions to the server and can receive responses from the server. This includes commands and requests sent to the server and responses, indications and notifications received from the server.\nServer: The server receives the commands and requests from the client and sends responses, indications and notifications to the Client.\nFrom application\u0026rsquo;s point of view, usually a device that is the data producer such as sensor nodes, implements the server role with services and characteristics needed to fulfill the application requirements. A device that is data consumer such as mobile phone or gateway, acts as a client.\nInplay Transparent Data Transmission (TRx) profile under proj/common/util/in_trx_svc.c and proj/common/util/in_trx_clt.c in SDK is a common profile developed based on GATT. Take it as an example to see the basic usage of these GATT APIs.\nServer # Like said above, GATT server provides one or more services and characteristics included within services to fulfill application requirements. So the first step application needs to do is to create services.\nCreate Service # The function that creates GATT service is inb_gatt_add_svc, whose prototype is as follows:\n/** **************************************************************************************** * @brief Add a new Service * @note This can only issue by the Server. * * @param[in] p_svc\tPointer to service data structure * @param[out] p_hdl\tService handle * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_add_svc(inb_gatt_svc_desc_t *p_svc, uint16_t *p_hdl, comp_cb callback); p_svc is a pointer to ble_gatt_svc_desc_t in which service information is provided as well as all the attributes the service includes. /// Attribute Description typedef struct { /// Attribute UUID (LSB First) uint8_t uuid[INB_UUID_128_LEN]; /// Attribute Properties, @see enum inb_att_char_prop and @see enum inb_att_perm_prop uint16_t prop; /// Maximum length of the attribute /// /// Note: /// For Included Services and Characteristic Declarations, this field contains targeted /// handle. /// /// For Characteristic Extended Properties, this field contains 2 byte value /// /// Not used Client Characteristic Configuration and Server Characteristic Configuration, /// this field is not used. /// uint16_t max_len; /// Attribute extended properties, @see enum inb_att_ext_prop uint16_t ext_prop; } inb_gatt_att_desc_t; typedef struct { /// Attribute Start Handle (0 = dynamically allocated) uint16_t start_hdl; /// Service properties, @see inb_att_svc_prop uint8_t prop; /// Service UUID uint8_t uuid[INB_UUID_128_LEN]; /// Number of attributes uint8_t nb_att; /// List of attribute description present in service. inb_gatt_att_desc_t atts[]; } inb_gatt_svc_desc_t; In TRx profile, there is only one service which contains two majoy characteristics representing data tx ([TRX_CHAR_VAL_TX]) and rx ([TRX_CHAR_VAL_RX]) respectively. Their uuid are application defined. According to the GATT standard, each service must first contain an attribute called Characteristic Declaration with a fixed uuid 0x2803. In addition, the server usually allows the client to control whether the server is able to send data by notification or indicatation method or not. Therefore, for the characteristic of data rx, a Client Characteristic Configuration Descriptor with predefined uuid 0x2902 should be added in the service.\nThe prop defines the access method of the attribute, ATT_CHAR_PROP_READ, ATT_CHAR_PROP_WRITE, ATT_CHAR_PROP_NOTIFY, ATT_CHAR_PROP_INDICATE etc, which is clear in meaning by its name. For example, ATT_CHAR_PROP_NOTIFY should be specified for attribute [TRX_CHAR_VAL_TX] which represents the data tx, because TRX_CHAR_VAL_TX depends on the method of Notify. For attribute [TRX_CHAR_VAL_RX] representing the data rx, ATT_CHAR_PROP_WRITE should be specified, which means that the client sends data to the server through the method of GATT Write.\nThe ext_prop defines some extended attributes. Commonly used bits include ATT_EXT_PROP_UUID_LEN and ATT_EXT_PROP_RI. ATT_EXT_PROP_UUID_LEN defaults to 00, which means that the UUID is 16Bytes instead of 2Bytes (like UUIDs predefined by SIG). It should be noted that if the prop of the attribute [TRX_CHAR_VAL_TX] is readable, the bit ATT_EXT_PROP_RI must be set in this field.\nstatic const inb_gatt_att_desc_t trx_atts[] = { [TRX_DECL_CHAR_RX] = { .uuid = { 0x03, 0x28 }, .prop = ATT_CHAR_PROP_READ, .max_len = 0, .ext_prop = (0 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CHAR_VAL_RX] = { .uuid = {TRX_RX_UUID }, .prop = ATT_CHAR_PROP_WRITE|ATT_CHAR_PROP_WRITE_NO_RSP, .max_len = TRX_MAX_LEN, .ext_prop = (2 \u0026lt;\u0026lt;ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_DECL_CHAR_TX] = { .uuid = { 0x03, 0x28 }, .prop = ATT_CHAR_PROP_READ, .max_len = 0, .ext_prop = (0 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CHAR_VAL_TX] = { .uuid = {TRX_TX_UUID}, .prop = ATT_CHAR_PROP_NOTIFY | ATT_CHAR_PROP_INDICATE, .max_len = TRX_MAX_LEN, .ext_prop = (2 \u0026lt;\u0026lt; ATT_EXT_PROP_UUID_LEN_SHIFT), }, [TRX_CLIENT_CHAR_CFG_TX] = { .uuid = { 0x02, 0x29 }, //INB_ATT_DESC_SERVER_CHAR_CFG, .prop = ATT_CHAR_PROP_READ|ATT_CHAR_PROP_WRITE, .max_len = 0, .ext_prop = 0, }, }; Now create service. start_hdl is set to 0 to allow GATT profile allocate space for service. If it is known for sure the service will not be conflict with other existing services, specific start_hdl can be assigned. uuid is application defined UUID of service. prop is service property. The API\u0026rsquo;s return value will be start attribute handle of service that is allocated by protocol stack if successful.\nint nb_att = sizeof(trx_atts)/sizeof(trx_atts[0]); inb_gatt_svc_desc_t *p_svc_desc = malloc(sizeof(inb_gatt_svc_desc_t) + nb_att * sizeof(inb_gatt_att_desc_t)); p_svc_desc-\u0026gt;start_hdl = 0;\tp_svc_desc-\u0026gt;prop = (2 \u0026lt;\u0026lt; ATT_SVC_PROP_UUID_LEN_SHIFT);\tmemcpy(p_svc_desc-\u0026gt;uuid, svc_uuid, 16); p_svc_desc-\u0026gt;nb_att = nb_att; memcpy(p_svc_desc-\u0026gt;atts, \u0026amp;trx_atts[0], nb_att * sizeof(inb_gatt_att_desc_t)); res = inb_gatt_add_svc(p_svc_desc, \u0026amp;hdl, NULL); In short, the main concern when creating a service is to define the structure of the Characteristic in the service and their accessing method.\nServer Sending Data # Below are APIs that server usually uses to send data, by GATT notify or indicate method.\n/** **************************************************************************************** * @brief Send indication * @note This can only issue by the Server. * * @param[in] conidx\tConnection index * @param[in] handle\tInidcation attribute handle * @param[in] length\tInidcation attribute value length * @param[in] value\tInidcation attribute value * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_send_ind(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); /** **************************************************************************************** * @brief Send notification * @note This can only issue by the Server. * * @param[in] conidx\tConnection index * @param[in] handle\tNotification attribute handle * @param[in] length\tNotification attribute value length * @param[in] value\tNotification attribute value * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_send_ntf(int conidx, uint32_t handle, uint32_t length, uint8_t *value, comp_cb callback); As mentioned above, application defines service structure and the create API returns handler of first attribute within the service. Now handlers of all Characteristic are known. However, what concerns us more is [TRX_CHAR_VAL_RX] and [TRX_CHAR_VAL_TX]. More exactly, for the server, only the handle of [TRX_CHAR_VAL_TX] is needed.\nHandle of TX Characteristic = Start Handle + TRX_CHAR_VAL_TX + 1 The 1 in above formula actually represents the additional attribute \u0026ldquo;Service Declaration\u0026rdquo; in service, which is not described in service description structure when it is created but added automatically by GATT profile.\nIn sample TRx profile, it is call like below:\nres = inb_gatt_send_ntf(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); res = inb_gatt_send_ind(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); In above sample, p_svr-\u0026gt;hdl_svc holds the Start handle of service. The conidx parameter in the API represents a specific connection. After connecting with the other device, the protocol stack will return this value to identify the connection.\nData notification and Indication has differet operations, as refered to GATT protocol:\nServer-initiated updates are the only asynchronous (i.e., not as a response to a client’s request) packets that can flow from the server to the client. These updates send timely alerts of changes in a characteristic value without the client having to regularly poll for them, saving both power and bandwidth. There are two types of server-initiated updates: Characteristic Value Notification\nNotifications are packets that include the handle of a characteristic value attribute along with its current value. The client receives them and can choose to act upon them, but it sends no acknowledgement back to the server to confirm reception. Along with write without response, this is the only other packet that does not comply with the standard request/response flow control mechanism in ATT, as the server can send any number of these notifications at any time. This feature uses the handle value notification (HVN) ATT packet.\nCharacteristic Value Indication\nIndications, on the other hand, follow the same handle/value format but require an explicit acknowledgment from the client in the form of a confirmation. Note that although the server cannot send further indications (even for different character‐ istics) until it receives confirmation from the client (because this flows in the op‐ posite direction than the usual request/response pairs), an outstanding confirma‐ tion does not affect potential requests that the client might send in the meantime. This feature uses the handle value indication (HVI) and handle value confirma‐ tion (HVC) ATT packets.\ninb_gatt_send_ntf implements the above-mentioned function of Characteristic Value Notification. It is called by the server when needed (for example, when the sensor changes) instead of being polled by the client. After being called, it is cached in the ATT protocol stack, and then returns immediately whether the response from the peer ATT layer is received or not.\nAccordingly, inb_gatt_send_ind implements the above-mentioned function of Characteristic Value Indication. The main difference is that each call needs to wait for the response of the peer ATT layer before it can be completed and exit.\nFor example, assume that the parameter of Bluetooth connection is 1s. Call inb_gatt_send_ntf or inb_gatt_send_ind twice during the period. The application osThread that calls inb_gatt_send_ntf can continue to work. At the same time, at the next connection point, the data sent by the two calls can be received by the other side simultaneously. If the connection is suddenly interrupted, the data sent is lost. The thread calling in_ble_gatt_send_ind will get blocked until the next connection point has sent data and received the other party\u0026rsquo;s response successfully. It holds true for the next call. That is, for the same two packets, using inb_gatt_send_ind causes an interval of 2 seconds, but it will ensure that the sent data will not get lost.\nServer Receiving Data # When GATT profile receives data from peer connection device (client), it will post a GATT_EVT_WRT_REQ event to application since client send data via GATT write method. We will talk about it later on session of client send data. All server need to do is to register event callback when system is initialized by inb_api_init.\nIn sample TRx profile, evt_wrt_req is registered to handle this event when client writes to [TRX_CHAR_VAL_RX] and [TRX_CLIENT_CHAR_CFG_TX] characteristic, which both have ATT_CHAR_PROP_WRITE property when creating.\nstatic void evt_wrt_req(inb_evt_write_req_ind_t* ind, uint8_t* status) { *status = INB_ATT_ERR_INVALID_HANDLE; trx_svr_t *p_svr = \u0026amp;trx_svr; uint16_t handle = ind-\u0026gt;handle - p_svr-\u0026gt;hdl_svc - 1; int res = 0; switch (handle) { case TRX_CHAR_VAL_RX: { p_svr-\u0026gt;conid = ind-\u0026gt;conidx; if (p_svr-\u0026gt;rx_callback) { res = p_svr-\u0026gt;rx_callback(ind-\u0026gt;conidx, ind-\u0026gt;value, ind-\u0026gt;length); if (res == 0) { *status = INB_ERR_NO_ERROR; } else { *status = INB_GATT_ERR_WRITE; } } else { *status = INB_ERR_NO_ERROR; } } break; case TRX_CLIENT_CHAR_CFG_TX: { ... } break; } } Note it\u0026rsquo;s important to set *status to the right value so that ATT protocol will send right response to client.\nServer notification enable and disable # In TRx sample above, there is a configuration attribute [TRX_CLIENT_CHAR_CFG_TX] for data sending, with which the client can enable or disable the server to send data. For example, the sensor is not required to report data at some specific time. Obviously, this attribute is also writing for the client, so it is similar to the server\u0026rsquo;s processing method of receiving data.\nEnable or disable request is stored in variable g_trx_svr.cfg. When sending data, if it is disabled by client, data is not sent.\nint in_trx_notify(int conidx, uint8_t *buf, uint32_t len, bool ack) { if (len \u0026gt; TRX_MAX_LEN) { return INB_PLT_ERR_INVALID_PARAM; } int res = INB_ATT_ERR_APP_ERROR; trx_svr_t *p_svr = \u0026amp;trx_svr; if (p_svr-\u0026gt;cfg[conidx] \u0026amp; 0x1) { if (ack) res = inb_gatt_send_ind(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); else res = inb_gatt_send_ntf(conidx, p_svr-\u0026gt;hdl_svc + TRX_CHAR_VAL_TX + 1, len, (uint8_t *)buf, NULL); if (res != INB_ERR_NO_ERROR) { PRINTD(DBG_ERR, \u0026#34;in_trx_notify: 0x%x\\n\u0026#34;, res); } } return res; } Read request from client # Client can also directly poll data from server by ATT read method to characteristic that allow read access permission. In sample TRx service, we don’t grant [TRX_CHAR_VAL_TX] characteristic read access, which can only be notified and indicated. But [TRX_CLIENT_CHAR_CFG_TX] characteristic is readable so that client can know if server is allowed notification or not.\nThe sequence is when client send characteristic read request to server, ATT protocol stack sends GATT_EVT_RD_REQ event to inform application. Once the attribute handle is right, application provides actual data to ATT protocol stack so that it transmit back to client.\nIf ble_app.c is used, application is only required to register event callback for GATT_EVT_RD_REQ to provide data and inb_gatt_read_req_cfm is called by ble_app to send back to ATT protocol.\nHere is what has been done in ble_app.c for the event.\nstatic void handle_default_gatt_evt(uint16_t eid, void* pv) { switch (eid) { case GATT_EVT_RD_REQ:/// GATT read request indication { ... if (status != INB_ERR_NO_ERROR) { if (p_app-\u0026gt;cbf-\u0026gt;gatt.evt_rd_req) { p_app-\u0026gt;cbf-\u0026gt;gatt.evt_rd_req(ind, \u0026amp;status, \u0026amp;data_len, \u0026amp;data); } else { status = INB_ATT_ERR_REQUEST_NOT_SUPPORTED; } } inb_gatt_read_req_cfm(ind-\u0026gt;conidx, ind-\u0026gt;handle, status, data_len, data); } break; } } Here is what TRx server has done in registered cabllback function. First handle is checked whether it is beyond the scope in service and IN_BLE_ATT_ERR_INVALID_HANDLE is returned otherwise. For [TRX_CLIENT_CHAR_CFG_TX] characteristic, the data to be read is enable/disable configurations which is 2 bytes length.\nstatic void evt_rd_req(ble_evt_read_req_ind_t* ind, uint8_t* status, uint16_t* rd_data_len, uint8_t** rd_data) { *status = INB_ATT_ERR_INVALID_HANDLE; uint16_t handle = ind-\u0026gt;handle - g_trx_svr.hdl_svc - 1; switch (handle) { case TRX_CLIENT_CHAR_CFG_TX: { g_trx_svr.conidx = ind-\u0026gt;conidx; *rd_data_len = 2; *rd_data = (uint8_t*)\u0026amp;g_trx_svr.cfg; *status = INB_ERR_NO_ERROR; } break; } } Client # On the other hand, the client has simpler work to do than server when initializing but more complicated after connection is established with server. Since all the APIs relies on attribute handle, unless service\u0026rsquo;s start handle and its structure is well known in advance, such as both client and server use the sample TRx profile and the start handle of service is fixed, they are going to be obtained in the following procedure called Service Discovery Protocol (SDP).\nThe client must know the corresponding handle of the attribute in service before any client operations. If both parties in the connection are devices developed by yourself, it means that you are already familiar with the structure of the service, UUID of the service and the starting handle, so this condition is naturally satisfied, and you only need to constantize it in the code. Otherwise, you will need to obtain it through the discover process.\nDiscovering Service by inb_gatt_sdp # This function starts SDP in BLE stack and returns result through event. API prototype is as follows\n/** **************************************************************************************** * @brief Service Discovery Procedure * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] sdp_type\tService Discovery Type, @see enum inb_gatt_sdp_type * @param[in] p_sdp\tPointer to service discovery paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_sdp(int conidx, int sdp_type, inb_gatt_sdp_t *p_sdp, comp_cb callback); There are three value for sdp_type: GATT_SDP_DISC_SVC, GATT_SDP_DISC_SVC_ALL, GATT_SDP_DISC_SVC_ALL. Here in sample TRx profile, GATT_SDP_DISC_SVC is used, just as the name suggests, discover one certain service.\nstatic int discover_svc(trx_clt_t *p_trx_clt) { int res=0; uint8_t sdp_buf[sizeof(inb_gatt_sdp_t)+INB_UUID_128_LEN]; //Discover now inb_gatt_sdp_t *p_sdp = (inb_gatt_sdp_t *)sdp_buf; p_sdp-\u0026gt;start_hdl = 1; p_sdp-\u0026gt;end_hdl = 0xFFFF; p_sdp-\u0026gt;uuid_len = INB_UUID_128_LEN; memcpy(p_sdp-\u0026gt;uuid, g_trx_clt.svc_uuid, INB_UUID_128_LEN); res = inb_gatt_sdp(p_trx_clt-\u0026gt;peer_conidx, GATT_SDP_DISC_SVC, p_sdp, NULL); return res; } Not only UUID of the service but also handle range is necessary. The range can be specified as 1~0xFFFF, which means searching all attributes. If the service is not within this handle range, discover fails either.\nAfter service is discovered, GATT_EVT_SDP_SVC event is sent to application. Here in sample TRx profile, the event is retrieved by registered event handler evt_sdp_svc with ble_app.c component.\nstatic void evt_sdp_svc(ble_evt_sdp_svc_ind_t *p_ind) { int res; trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt){ PRINTD(DBG_TRACE, \u0026#34;Discover Service (%d, %d)\\r\\n\u0026#34;, p_ind-\u0026gt;start_hdl, p_ind-\u0026gt;end_hdl); p_trx_clt-\u0026gt;start_hdl = p_ind-\u0026gt;start_hdl; p_trx_clt-\u0026gt;end_hdl = p_ind-\u0026gt;end_hdl; p_trx_clt-\u0026gt;cfg = 0; //Means SDP procedure is over if (g_trx_clt.trx_clt_ready_cb) g_trx_clt.trx_clt_ready_cb(p_trx_clt-\u0026gt;peer_conidx, 0); } //We\u0026#39;v done so let others handle it if (g_trx_clt.cbf.gatt.evt_sdp_svc) g_trx_clt.cbf.gatt.evt_sdp_svc(p_ind); } int in_trx_clt_init(in_trx_clt_t *p_in_trx_clt) { ... //GATT event p_cbf-\u0026gt;gatt.evt_sdp_svc = evt_sdp_svc; return 0; } The start and end attribute handle of service are retrieved, which are the key to client. Now the client is functionable.\nDiscovering Service by inb_gatt_discovery # inb_gatt_sdp is not the only API but maybe the simplest one. There is another option as following prototype which can do more.\n/** **************************************************************************************** * @brief Attributes Discovery * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] disc_type\tAttribute discovery type, @see enum inb_gatt_disc_type * @param[in] p_disc\tPointer to attribute discovery paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_discovery(int conidx, int disc_type, inb_gatt_disc_t *p_disc, comp_cb callback); This function is to discovery not only service but single characteristic. In the sample, if we use this function to do service discovery, disc_type should be set to GATT_DISC_BY_UUID_SVC. Other parameters are similar to inb_gatt_sdp.\nAfter service is discovered, a different GATT_EVT_DISC_SVC event is sent to application. Register this event handler is a MUST when using this option. The event handler looks like quite similar to event handler of GATT_EVT_SDP_SVC, and the key information are .\nvoid (*evt_disc_svc)(inb_evt_disc_svc_ind_t *); /// Discover Service indication Structure typedef struct { /// Connection index uint8_t conidx; /// start handle uint16_t start_hdl; /// end handle uint16_t end_hdl; /// UUID length uint8_t uuid_len; /// service UUID uint8_t uuid[]; } inb_evt_disc_svc_ind_t; Client Sending Data # Usually the way that client sends data to server is via GATT write method. API prototype is as follows:\n/** **************************************************************************************** * @brief Write Attribute * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] wrt_type\tAttribute write type, @see enum inb_gatt_write_type * @param[in] p_write\tPointer to attribute write paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_write(int conidx, int wrt_type, inb_gatt_write_t *p_write, comp_cb callback); The most importand parameter is wrt_type, which corresponds to various write methods in the GATT protocol: GATT_WRITE, GATT_WRITE_NO_RESPONSE, GATT_WRITE_SIGNED, GATT_EXEC_WRITE. Here in the sample the GATT_WRITE or GATT_WRITE_NO_RESPONSE type is used depending on if ack is needed.\nFirst, the Characteristic in service must have write permissions. Reviewing the previous sample TRX service definition, characteristics [TRX_CHAR_VAL_RX] and [TRX_CLIENT_CHAR_CFG_TX] have ATT_CHAR_PROP_WRITE permission. The previous attribute corresponds to the direction of the data flow, which is from the client to the server, while the latter is used for the client to control the enabling of data transmission from the server.\nWith the start handle of the service that discovered, the client can use the inb_gatt_write method to send data to the server.\nThe p_write structure contains the parameters of the Write methods, as well as common parameters such as handle, offset and length. Note that for the GATT_WRITE type, the value of the \u0026lsquo;auto_execute\u0026rsquo; parameter is true.\nHere is what sample TRX client has done:\nint in_trx_clt_send(int conidx, uint8_t *p_data, uint16_t data_len, bool ack) { int res = 0; inb_gatt_write_t *p_write=NULL; trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(conidx); if ( !p_trx_clt || p_trx_clt-\u0026gt;peer_conidx == -1 || trx_clt_is_undisced(p_trx_clt)) { res = INB_PLT_ERR_NOT_READY; goto out; } p_write = (inb_gatt_write_t*)malloc(sizeof(inb_gatt_write_t)+data_len); if (p_write) { p_write-\u0026gt;handle = p_trx_clt-\u0026gt;start_hdl+TRX_CHAR_VAL_RX+1; p_write-\u0026gt;auto_execute = true; p_write-\u0026gt;offset = 0; p_write-\u0026gt;length = data_len; memcpy(p_write-\u0026gt;value, p_data, data_len); res = inb_gatt_write( p_trx_clt-\u0026gt;peer_conidx, ack ? GATT_WRITE : GATT_WRITE_NO_RESPONSE , p_write, NULL); free(p_write); } out: return 0-res; } static int enable_ntf(trx_clt_t *p_trx_clt, uint16_t enable) { uint8_t buf[sizeof(inb_gatt_write_t)+2]; int res = -1; inb_gatt_write_t *p_write=(inb_gatt_write_t *)buf; p_write-\u0026gt;handle = p_trx_clt-\u0026gt;start_hdl+TRX_CLIENT_CHAR_CFG_TX+1; p_write-\u0026gt;auto_execute = true; p_write-\u0026gt;offset = 0; p_write-\u0026gt;length = 2; memcpy(p_write-\u0026gt;value, \u0026amp;enable, p_write-\u0026gt;length); res = inb_gatt_write( p_trx_clt-\u0026gt;peer_conidx, GATT_WRITE, p_write, NULL); return res; } Client Receiving Data # Similar to server receiving data, when GATT profile receives data notification from peer connection device (server), it will post GATT_EVT_NTF or GATT_EVT_IND event to application. Client resiter event callback when system initialization.\nstatic void evt_peer_evt_ntf(ble_evt_ntf_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false \u0026amp;\u0026amp; p_ind-\u0026gt;handle == p_trx_clt-\u0026gt;start_hdl + TRX_CHAR_VAL_TX + 1) { if (g_trx_clt.trx_clt_rx_cb) g_trx_clt.trx_clt_rx_cb(p_ind-\u0026gt;conidx, p_ind-\u0026gt;value, p_ind-\u0026gt;length); } //We\u0026#39;v done so let others handle it if (g_trx_clt.cbf.gatt.evt_peer_evt_ntf) g_trx_clt.cbf.gatt.evt_peer_evt_ntf(p_ind); } static void evt_peer_evt_ind(ble_evt_ind_ind_t *p_ind) { trx_clt_t *p_trx_clt; p_trx_clt = trx_clt_get_by_conidx(p_ind-\u0026gt;conidx); if (p_trx_clt \u0026amp;\u0026amp; trx_clt_is_undisced(p_trx_clt)==false \u0026amp;\u0026amp; p_ind-\u0026gt;handle == p_trx_clt-\u0026gt;start_hdl + TRX_CHAR_VAL_TX + 1) { inb_gatt_indication_cfm(p_ind-\u0026gt;conidx, p_ind-\u0026gt;handle); if (g_trx_clt.trx_clt_rx_cb) g_trx_clt.trx_clt_rx_cb(p_ind-\u0026gt;conidx, p_ind-\u0026gt;value, p_ind-\u0026gt;length); } //We\u0026#39;v done so let others handle it if (g_trx_clt.cbf.gatt.evt_peer_evt_ind) g_trx_clt.cbf.gatt.evt_peer_evt_ind(p_ind); } The difference between GATT_EVT_NTF and GATT_EVT_IND is an additional inb_gatt_indication_cfm function must be called so that ATT protocol will send response to peer ATT protocol layer. That\u0026rsquo;s why indication is more reliable data transmission of GATT.\nRead data # Client can also directly poll data from server by ATT read method to characteristic that allows read access permission. In sample TRx service, [TRX_CLIENT_CHAR_CFG_TX] characteristic is readable so that client can know if server is already allowed notification or not.\n/** **************************************************************************************** * @brief Read Attribute * @note This can only issue by the Client. * * @param[in] conidx\tConnection index * @param[in] read_type\tAttribute read type, @see enum inb_gatt_read_type * @param[in] p_req\tPointer to attribute read paramters * * @return INB_ERR_NO_ERROR if successful, otherwise failed. @see enum inb_err_t **************************************************************************************** */ int inb_gatt_read(int conidx, int read_type, inb_gatt_read_req_t *p_req, comp_cb callback); The actual read result and value are retrieved by GATT_EVT_RD_RSP_IND. If ble_app.c is used, client must register event handler for the event. The register method is same as other callback function. Here is sample of callback function and actual read data is within inb_evt_read_rsp_ind_t parameter.\nvoid evt_read_rsp_ind(inb_evt_read_rsp_ind_t *p_ind) { ... } "},{"id":6,"href":"/docs/in6xx/getting-started/testing/hci_command.html","title":"HCI Command","section":"Testing and Debuging","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Note: HCI command is in hexadecimal, not ASCII characters. If you are using a serial tool to send the HCI command, make sure to set it to HEX mode for both sending and receiving. For example, in this document, \u0026ldquo;0x12\u0026rdquo; represents one byte with the value 0x12. Please do not enter \u0026lsquo;0\u0026rsquo;, \u0026lsquo;x\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo; as four separate bytes.\nCommand Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # Table 1\npacket type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 2\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding HCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,0x04, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 0x06, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 2\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x04, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: Don\u0026rsquo;t change TX power setting. 0x1 ~ 0x7F: PA gain. Note:\nSuggest set TX gain to 0x0, and use \u0026quot;Set TX Power\u0026quot; command to set TX power. Complete Event：0x04, 0x0E, 0x04, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x05, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x08, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;, \u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\npacket number: TX packet number, 0 is TX forever. Note: If packet number is not 0, current is a little higher.\nComplete Event:0x04, 0x0E, 0x04, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nVendor TX end # Stop TX and send back TX packets, Command: 0x01, 0x53, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x53, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;packet number byte 0\u0026gt;, \u0026lt;packet number byte 1\u0026gt;\npacket number: TX packet number Set Cap # Set XO cap Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF. And 0xFF means use default value. Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap # Save XO cap value to flash Command: 0x01, 0x08, 0xFC, 0x00 Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3. Commands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 01, 0x04, 0x07, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x08, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number Set TRX Enable Pin # Command: 0x01, 0x44, 0xFC, 0x06, \u0026lt;bias port\u0026gt; \u0026lt;bias pin\u0026gt;, \u0026lt;tx en port\u0026gt;, \u0026lt;tx en pin\u0026gt;,\u0026lt;rx en port\u0026gt;, \u0026lt;rx en pin\u0026gt;\nbias port: PA bias port, set to 0xFF if it is invaild bias pin: PA bias pin, set to 0xFF if it is invaild tx en port: TX enable port tx en pin: TX enable pin rx en port: RX enable port rx en pin: RX enable pin Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x44, 0xFC, \u0026lt;status\u0026gt; Save Configuration # Save PA and tx power configuration to flash.\nCommand: 0x01, 0x57, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x57, 0xFC, \u0026lt;status\u0026gt; Use Default Configuration # Use default PA and tx power configuration, clear the setting on flash.\nCommand: 0x01, 0x58, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x58, 0xFC, \u0026lt;status\u0026gt; GPIO Output # Command: 0x01, 0x0B, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;output\u0026gt;\nport: GPIO port pin: GPIO pin output: GPIO output, 1 is high and 0 is low Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0B, 0xFC, \u0026lt;status\u0026gt; GPIO input # Command: 0x01, 0x0C, 0xFC, 0x03, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;, \u0026lt;pull\u0026gt;\nport: GPIO port pin: GPIO pin pull: 0 is no pull up/down, 1 is pull up and 2 is pull down Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x0C, 0xFC, \u0026lt;status\u0026gt; \u0026lt;GPIO input\u0026gt;\nGPIO input: 1 is high and 0 is low Get ADC sample # Command: 0x01, 0x43, 0xFC, 0x02, \u0026lt;ADC channel\u0026gt;, \u0026lt;parameter\u0026gt;\nADC channel: ADC channel\nparameter: If ADC channel is not 13, set this to 0x0. If ADC channel is 13, this value is register pmu_test_mux_ctrl[0:7]. Complete Event: 0x04, 0x0E, 0x08, 0x01, 0x43, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;Sample raw data byte 0\u0026gt;, \u0026lt;Sample raw data byte 1\u0026gt; \u0026lt;Sample converted data byte 0\u0026gt;, \u0026lt;Sample converted data byte 1\u0026gt;\nSample raw data: 16 bits ADC sample raw data.\nSample converted data: 16 bits converted data in millivolt.\nStart PWM # Start PWM Command: 0x01, 0x09, 0xFC, 0x09, \u0026lt;pwm id\u0026gt;, \u0026lt;period byte 0\u0026gt;, \u0026lt;period byte 1\u0026gt;, \u0026lt;period byte 2\u0026gt;, \u0026lt;period byte 3\u0026gt;, \u0026lt;high byte 0\u0026gt;, \u0026lt;high byte 1\u0026gt;, \u0026lt;high byte 2\u0026gt;, \u0026lt;high byte 3\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nperiod: PWM period, count in microsecond\nhigh: PWM high time, count in microsecond\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Stop PWM Command: `0x01, 0x0A, 0xFC, 0x00` Complete Event: `0x04, 0x0E, 0x04, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;` Set RTC32K Output # Output RTC32K signal on specail GPIO. Available pins are GPIO_0_2, GPIO_0_6, GPIO_1_0, GPIO_1_4, GPIO_1_8, GPIO_3_3 and GPIO_4_3. Command: `0x01, 0x46, 0xFC, 0x03, \u0026lt;enable\u0026gt;, \u0026lt;port\u0026gt;, \u0026lt;pin\u0026gt;` enable: 1 is enable, and 0 is disable\nport: GPIO port\npin: GPIO pin\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x46, 0xFC, \u0026lt;status\u0026gt;\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nI2C Read Register # I2C read register as master Command: `0x01, 0x59, 0xFC, 0x03, \u0026lt;i2c_id\u0026gt;, \u0026lt;slv_addr\u0026gt;, \u0026lt;reg_addr\u0026gt;` i2c_id: I2C id, 0 or 1. I2C 0 use GPIO0_0 and GPIO0_1, I2C 1 use GPIO4_0 and GPIO4_1.\nslv_addr: I2C slave address\nreg_addr: register address\nComplete Event: 0x04, 0x0E, 0x04, 0x02, 0x59, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;reg_val\u0026gt;\nreg_val: register value\nGet RTC clock # Get RTC clock Command: `0x01, 0x5A, 0xFC, 0x00` Complete Event: `0x04, 0x0E, 0x04, 0x01, 0x5A, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;rtc_clk byte 0\u0026gt;, \u0026lt;rtc_clk byte 1\u0026gt;, \u0026lt;rtc_clk byte 2\u0026gt;, \u0026lt;rtc_clk byte 3\u0026gt;` rtc_clk: RTC clock in HZ. Note: RTC need 1 second for calibration. Must wait for 1 second after power on, then run this command. Deep Sleep # Go to deep sleep mode Command: `0x01, 0x55, 0xFC, 0x04, \u0026lt;sleep_time byte 0\u0026gt;, \u0026lt;sleep_time byte 1\u0026gt;, \u0026lt;sleep_time byte 2\u0026gt;, \u0026lt;sleep_time byte 3\u0026gt;` sleep_time: sleep time in millisecond, must larger then 10. Chip will wake up after sleep_time.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x55, 0xFC, \u0026lt;status\u0026gt;\nUser Ddefined Command # Run user defined command. Command: `0x01, 0x47, 0xFC, 0x04, \u0026lt;para0\u0026gt;, \u0026lt;para1\u0026gt;, \u0026lt;para2\u0026gt;, \u0026lt;para3\u0026gt;` para0: parameter 0.\npara1: parameter 1.\npara2: parameter 2.\npara3: parameter 3.\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x47, 0xFC, \u0026lt;status\u0026gt; \u0026lt;res byte0\u0026gt; \u0026lt;res byte1\u0026gt; \u0026lt;res byte2\u0026gt; \u0026lt;res byte3\u0026gt;\nres: return value of user defined function\nThe following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x06, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x05, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x06, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x04, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq offset code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code Complete Event: 0x04, 0x0E, 0x04, 0x01, 0x42, 0xFC, \u0026lt;status\u0026gt;\nExample: # channel 0, continus TX on 1M phy 01 0D FC 08 00 25 00 01 00 01 00 00\nchannel 19, continus TX on 1M phy 01 0D FC 08 13 25 00 01 00 01 00 00\nchannel 39, continus TX on 1M phy 01 0D FC 08 27 25 00 01 00 01 00 00\nchannel 0, continus TX on 2M phy 01 0D FC 08 00 25 00 02 00 01 00 00\nchannel 19, continus TX on 2M phy 01 0D FC 08 13 25 00 02 00 01 00 00\nchannel 39, continus TX on 2M phy 01 0D FC 08 27 25 00 02 00 01 00 00\n"},{"id":7,"href":"/docs/in6xx/getting-started/download/in_prog-guide.html","title":"InPlay Programmer Guide","section":"Download Image","content":" InPlay Programmer Guide # Introduction # The InPlay Programmer is a graphical chip configuration and programming tool for the PC that enables developers to configure and download programs to target boards using InPlay chips via UART. Developers should refer to the chip datasheet to thoroughly understand the configuration options based on their specific application requirements.\nThe main window of the GUI tool, as shown in Figure 1, is organized into five area:\nData communication interface selection and configuration area Application download area HCI FW configuration area Device configuration area Register/eFuse read-write area Efuse configuration area Authentication and encryption configuration area Note: All numbers entered in input fields are in hexadecimal format, and you do not need to include the \u0026ldquo;0x\u0026rdquo; prefix. For example, to set the address to \u0026ldquo;0x300000\u0026rdquo;, simply enter \u0026ldquo;300000\u0026rdquo;.\nUART Download # Prerequisites # Connect the DK board’s UART port to the PC. Set the chip to boot mode. Boot Mode # The chip has two modes: boot mode and normal mode. In boot mode, it can be configured and programmed via UART/JLink, while in normal mode, the chip runs the program already downloaded to it. A GPIO pin can be configured as the boot pin in software, and the chip will check the GPIO level at power-on to determine whether to enter boot mode. In the SDK\u0026rsquo;s demo project, GPIO2_6 is set as the default boot pin. If the chip has no loaded program (i.e., a blank chip), it will automatically enter boot mode on power-up. If a program is already loaded, ground the boot pin and then power cycle or reset the chip to enter boot mode. Connecting to the UART (Area 1) # Click on \u0026ldquo;Uart\u0026rdquo; in area 1 to automatically scan for UART ports on the PC. Select the DK board’s port from the dropdown list under \u0026ldquo;Port.\u0026rdquo; The program sets the baud rate to 115200 by default. Click Connect. If the connection is successful, a dialog will appear. The program will continue attempting to connect for up to five minutes. To cancel, close and reopen the program. Program Download (Area 2) # Ensure that BootRAM is checked in area 2. Click Browse to select the application binary file. Verify the Address is set to 0x300000. The program will automatically calculate the size; no adjustments are needed. Click Download. A dialog will appear upon successful download. Data File Download (Area 2) # Some programs may require downloading data files, such as calibration data or tokens/UUIDs, to specific locations. This step can be done after downloading the application binary file. Note: If no program has been downloaded previously, data files cannot be downloaded directly.\nUncheck Bootram. Click Browse to select the binary file containing the data. Set the Addr as required; for example, to load data at 0x37E000, set the address to 37E000. Size will be set automatically, but it can be adjusted as needed. Click Download. HCI Firmware Configuration (Area 3) # This section configures the HCI Firmware, including HCI Firmware\u0026rsquo;s UART, PA, and TX Power settings.\nHCI UART # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, UART 1 uses GPIO2_1 and GPIO2_7. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the UART ID, which can be either 0 or 1. Configure the TX Port and TX Pin. UART 0 allows GPIO0_2 or GPIO2_3, while UART 1 allows GPIO2_1 or GPIO1_7. Configure the RX Port and RX Pin. UART 0 allows GPIO1_0 or GPIO2_5, while UART 1 allows GPIO2_7 or GPIO1_8. PA Pin # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, no PA Pin is set. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the TX_EN Port, TX_EN Pin, RX_EN Port, RX_EN Pin, Bias Port, and Bias Pin. If a pin is not to be configured, set both Port and Pin to \u0026ldquo;FF\u0026rdquo;. TX Power # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, the TX Power is set to 0x18 (0dBm). To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the TX Power, which ranges from 0x0 to 0x7F. Boot Pin # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. By default, the boot pin is GPIO2_6. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set port. Set pin. Generate Bin File # Must click the browse button (Area 2) to select the original bin file first.\nThen if you click \u0026ldquo;Download\u0026rdquo; bnutton, the configuration will be written into the flash but will not modify the original bin file. If you need to download it again, you must configure it again.\nClicking the \u0026ldquo;Generate Bin\u0026rdquo; button will create a bin file with the configured information. And it will not modify the original bin file. If download the generated bin file, don\u0026rsquo;t need to configure the HCI Firmware Configuration (Area 3). Just select all \u0026ldquo;Default Config\u0026rdquo; options.\nDevice Configuration (Area 4) # This section is used to configure device-related information, which will be stored separately at address 0x37F000. Therefore, if the configuration has already been set and downloaded, there is no need to configure it again for subsequent downloads.\nNote: Make sure to check \u0026ldquo;Device Config\u0026rdquo; in the SwiftConfigTool for this configuration to take effect.\nXO Cap # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. The default values are set in SwiftConfigTool. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the cap value, which ranges from 0x0 to 0xF. BD Address # Check \u0026ldquo;Use Default Setting\u0026rdquo; to use the default configuration. The default values are set in SwiftConfigTool. To use a custom configuration, uncheck \u0026ldquo;Use Default Setting.\u0026rdquo; Set the BD address. Troubleshooting # DK board’s UART port not listed:\nUncheck UART, then re-check it to rescan for UART ports. Connection fails upon clicking Connect:\nEnsure the port is not occupied by another program. No success dialog after clicking Connect:\nVerify the selected port is correct. Confirm that the chip is in boot mode. Disconnect all connections to the chip, such as UART and JLink connections. Then pull down boot pin and reset the chip. After that, reconnect the serial port to the chip and click \u0026ldquo;Connect.\u0026rdquo; Download fails upon clicking Download:\nEnsure the correct binary file is selected. Verify Bootram is checked. Confirm Addr and Size settings are correct. Data file download fails upon clicking Download:\nVerify the correct binary file is selected. Ensure Bootram is unchecked. Confirm Addr and Size settings are correct. "},{"id":8,"href":"/docs/in6xx/protocol-reference/ble/inplay_trx_profile.html","title":"Inplay Transparent Data Transmission (TRx) profile User Guide","section":"BLE","content":" Overview # The component documented here is a software component that utilizes BLE GATT protocol to fulfill transparent data transmission over BLE devices. It is based on Inplay BLE application framework and provides set of simple APIs for the convenience of application development. Please refer to GATT Programming Guide for details.\nThe component consists of the Server and the Client part. The server is composed of GATT based services. It includes two characteristic values with one representing receiving (Rx) and the other representing sending (TX) and a client characteristic configuration descriptor. Once a client is connected, the server will notify the client of the maximum size of data transmission it supports through MTU exchange. The client obtains the handles of the characteristics including Rx, TX and Configure through the method of GATT Discover Service so that it can send data through the method of GATT Write. The server sends data to the other party through the method of GATT Notify.\nAll the functions of component must be called after BLE is initialized by ble_app_run().\nServer # Generally speeking, the peer who will generate data and provide it to the other peer without active request, will act as GATT server. The method in which server transmits data is called notify or indicate. These are included among in_trx_svc.c under proj/common/util directory.\nTo use the server of component, first step application should do is to call in_trx_svc_add to add GATT service to the server. Here is prototype of API.\n/** **************************************************************************************** * @brief Add trx service * * @param[in] uuid\tCustomized service and characteristic UUID. If NULL, default UUIDs are used. *\t@see TRX_SVC_UUID, TRX_TX_UUID, TRX_RX_UUID * @param[in] start_hdl\tService\u0026#39;s start attribute handle. If 0, start handle is allocated by protocol *\tstack and returned. Otherwise, start handle is designated and function may *\treturn failed if it is already allocated. * @param[in] max_data_len\tmax data size to transmit/receive * @param[in] rx_callback\tThis callback will be called in gatt write request funtion * @param[in] p_cbf\tEvent callback which is previously passed into ble_app_config(). * * @return \u0026gt;0: Success. The value is service\u0026#39;s start handle * \u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_svc_add(uint8_t uuid[3][INB_UUID_128_LEN], uint16_t start_hdl, int max_data_len, ble_app_cbf_t *p_cbf, int (*rx_callback)(int, uint8_t*, int)); If the service has security requirment, call following function to set security\n/** **************************************************************************************** * @brief set service\u0026#39;s SMP right * * @param[in] perm\tpermission @see enum inb_att_perm * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_svc_set_perm(enum inb_att_perm perm); Now Transparent Data Transmission service is created and application is able to transmit and receive data once it is connected with peer client.\nThe server transmits data to the client by:\n/** **************************************************************************************** * @brief Trx notify function * * @param[in] conidx\tID allocated by BLE stack after the connection is established with peer device * @param[in] buf\tnotify data buffer * @param[in] len notify data length * @param[in] ack gatt indicate method is used when true * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error @see enum inb_error. **************************************************************************************** */ int in_trx_notify(int conidx, uint8_t *buf, uint32_t len, bool ack); Application is informed by rx_callback function when the data is received from the client.\nint (*rx_callback)(int conidx, uint8_t *p_data, int data_len) The first parameter of the callback function represents the ID allocated by BLE stack after the connection is established with peer device; the second refers to the data, while the third represents the data length. Note that this callback function is running at the internal task, it is not recommended to call other BLE APIs in the callback function.\nClient # Accordingly, the data consummer on the peer side will act as TRx client. The method with which client transmits data is called GATT write. The TRx client source code is included among in_trx_clt.c under proj/common/util directory in SDK.\nSimilarly, TRx client should be initialized first by:\ntypedef struct { /// Service UUID uint8_t svc_uuid[INB_UUID_128_LEN]; /// Service\u0026#39;s start attribute handle. /// If not 0, it is known beforehand and Service Discovery Procedure (SDP) is not performed. uint16_t start_hdl; /// Client\u0026#39;s MTU int max_data_len; /// This callback will be called in gatt notification event trx_rx_cb_t\trx_callback; /// This callback will be called when client is ready to send/receive data trx_state_cb_t\tready_callback; } in_trx_clt_t; /** **************************************************************************************** * @brief Init trx client. This must be called after BLE stack and system is initialized * * @param[in] p_trx_clt\tContains parameter for client @see in_trx_clt_t * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0 : Fail. The absolute value represents possible error *\t@see enum inb_error. **************************************************************************************** */ int in_trx_clt_init(in_trx_clt_t *p_trx_clt); The parameters are very similar to server service creatation function in_trx_svc_add. The only small difference is that if start_hdl is 0, the client will initiate the SDP procedure to obtain information about the service. Once it is done, ready_callback function is called so that application is informed whether or not TRx client is ready to work. The duration of SDP depends on the connection interval. The client will automatically adjust the connection interval to the minimum to fasten the SDP procedure, and then adjust them back to the original application-defined connection parameters when finished.\nHere is the sample on how TRx client is initialized:\nres = ble_app_run(cbf, comp_cbf); if (res != INB_ERR_NO_ERROR) { PRINTD(DBG_ERR, \u0026#34;failed initialize ble apis, %d...\\n\u0026#34;, res); goto out; } /** **************************************************************************************** * @brief Initialize Client trx * @note get more information in in_trx_clt.h * **************************************************************************************** */ in_trx_clt_t in_trx_clt = {.svc_uuid={TRX_SVC_UUID}, .start_hdl=0, .max_data_len=TRX_MAX_LEN, .rx_callback=trx_rx_cb, .ready_callback=trx_ready_cb}; in_trx_clt_init(\u0026amp;in_trx_clt); The SDP procedure is started by calling in_trx_clt_start when client device is connected with peer server device and connection is acceptable by application.\n/** **************************************************************************************** * @brief Start trx client once connection is confirmed. This must be called after * in_trx_clt_init is called successfully. * * @param[in] conidx\tID allocated by BLE stack after the connection is established *\twith peer device * @param[in] bd_addr\tpeer device\u0026#39;s BLE mac address * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error *\t@see enum inb_error. **************************************************************************************** */ int in_trx_clt_start(int conidx, uint8_t bd_addr[BLE_BDADDR_LEN]); void main_task(void *h_bstk) { int res; while (1) { osEvent evt; evt = osMessageGet(g_app_msg_q_id, osWaitForever); if (evt.status == osEventMessage) { msg_t *p_msg = (msg_t*)evt.value.p; PRINTD(DBG_TRACE, \u0026#34;==\u0026gt;%s\\n\u0026#34;, MSG_ID_STR[p_msg-\u0026gt;msg_id]); switch (p_msg-\u0026gt;msg_id) { case MSG_CON: g_conidx = *((int*)p_msg-\u0026gt;msg); res = in_trx_clt_start(g_conidx, p_msg-\u0026gt;msg+sizeof(int)); break; ... default: break; } free(p_msg); } } } The MSG_CON message is posed to main task when application receives BLE event GAP_EVT_CONN_REQ via registered callback function. Here is sample about how callback function is registered.\nint main(void) { ... /** **************************************************************************************** * @brief Set ble related callback * @note more information of this function can be found in ble_app_cbf_t * **************************************************************************************** */ ble_app_cbf_t* cbf = ble_app_get_default_cb(); cbf-\u0026gt;gap.evt_disconnect = ble_disconnect; cbf-\u0026gt;gap.evt_conn_ind = ble_connect; ... } /** **************************************************************************************** * @brief callback for ble connection * @param[out] req\trequest of ble connection. * @param[out] cfm Connection request confirm structure. * @note we can get information in ble_evt_conn_req_t and ble_conn_cfm_t * **************************************************************************************** */ static void ble_connect(inb_evt_conn_req_t* req, inb_conn_cfm_t* cfm) { uint8_t *addr = req-\u0026gt;peer_addr.addr; PRINTD(DBG_TRACE, \u0026#34;ble_connect Connect 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x conid:%d intv:0x%x lantency:0x%x timeout:0x%x clock:0x%x***\\r\\n\u0026#34;, addr[0], addr[1],addr[2],addr[3],addr[4],addr[5], req-\u0026gt;conidx, req-\u0026gt;con_interval, req-\u0026gt;con_latency, req-\u0026gt;sup_to, req-\u0026gt;clk_accuracy); msg_t *p_msg = (msg_t*)malloc(sizeof(msg_t)+sizeof(int)+6); if (p_msg) { p_msg-\u0026gt;msg_id = MSG_CON; p_msg-\u0026gt;msg_len = 0; *((int*)p_msg-\u0026gt;msg) = req-\u0026gt;conidx; memcpy(p_msg-\u0026gt;msg+sizeof(int), req-\u0026gt;peer_addr.addr, 6); int res = osMessagePut(g_app_msg_q_id, (uint32_t)p_msg, 0) ; if (res) { PRINTD(DBG_TRACE, \u0026#34;put msg err %X \\r\\n\u0026#34;, res); free(p_msg); } } } After SDP procudure is end, ready_callback function that is passed when initialization is called to inform application whether success or not. Here is sample of ready callback function.\nstatic int trx_ready_cb(int conidx, int res) { PRINTD(DBG_TRACE, \u0026#34;trx ready: 0x%x\\r\\n\u0026#34;, res); g_trx_svc_ready = res; if ( g_conidx != -1 \u0026amp;\u0026amp; g_trx_svc_ready == 0 \u0026amp;\u0026amp; g_trx_ntf_en == false) { g_trx_ntf_en = true; res = in_trx_clt_enable_ntf(g_conidx, g_trx_ntf_en); PRINTD(DBG_TRACE, \u0026#34;trx notify %s\\n\u0026#34;, g_trx_ntf_en ? \u0026#34;enabled\u0026#34; : \u0026#34;disabled\u0026#34;); } } It calls in_trx_clt_enable_ntf function to enable server to transmit data for both GATT notify and indicate. Till now, client is ready to exchange data with peer server. To transmit data call in_trx_clt_send, whose parameters are the same as those of the server function.\n/** **************************************************************************************** * @brief Trx Client sends data. If Service Discovery Procedure (SDP) is on-going, it is *\tnot allowed to send data. * * @param[in] conidx\tconnection index of peer * @param[in] p_data\tnotify data buffer * @param[in] data_len notify data length * @param[in] ack\tuse GATT_WRITE_NO_RESPONSE write method if false * * @return\t\u0026gt;=0: Success. *\t\u0026lt;0: Fail. The absolute value represents possible error *\t@see enum inb_error. **************************************************************************************** */ int in_trx_clt_send(int conidx, uint8_t *p_data, uint16_t data_len, bool ack); Similar to server, when data is received, rx_callback function is called. Sample is same as that in server.\nHere is Sequence Diagram to summarize the use of TRx profile.\n"},{"id":9,"href":"/docs/solutions/multiconnnet/introduction.html","title":"Introduction","section":"MultiConnNet","content":" Introduction to MultiConnNet System # The MultiConnNet is Inplay\u0026rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.\nThe system is comprised of two primary components: the gateway module and the node module.\nKey Features # Star Topology: The system employs a star connection model, with the gateway serving as the central node for bidirectional communication with multiple node modules, facilitating management and data transmission.\nMulti-Node Connectable: The MultiConnNet supports up to 128 nodes in network, making it suitable for large-scale deployments and meeting diverse application needs. Besides, all the nodes is connectable, which offers high reliability and data integrity on specific application.\nBidirectional Data Transmission: The system enables bidirectional data transmission, ensuring real-time communication between nodes and the gateway, which is ideal for applications requiring quick responses.\nPrivate SDR Protocol: Based on a private SDR protocol, the system offers greater flexibility and customization, allowing optimization according to specific requirements to enhance communication efficiency.\nSpectrum Utilization: Operating in the 2.4GHz frequency band, it effectively utilizes existing wireless spectrum resources, making it suitable for various indoor and outdoor environments.\nLow Power Node module can be in low power mode that allows them to run on battery power for several years. This makes them particularly suitable for remote or hard-to-reach environments in IoT application.\nGlossary of Acronyms and Important Terms # Access Address: All low level packets include the 4 octets Access Address, which is used to identify communications on a physical channel, and to exclude or ignore packets on different physical channels that are using the same PHY channels in physical proximity. This ensures that the transmission is indeed meant for the device that is receiving it.\nDevice Address: Each device in the MultiConnNet has its own 2 octets Device Address, which is used as source/target addresses for communication between the gateway and each node.\nGateway: The Gateway is the center device of the network, connecting and managing the surrounding node devices. It can connect up to 128 nodes simultaneously, operating at full capacity without entering a low-power sleep mode.\nNode: Node is peripheral device that connect to the network where the gateway is located after logging in. The nodes operate in a low-power state.\nPeriodic Advertising: Gateway sends periodic advertisement packets at regular intervals for synchronization of various nodes within the network. The interval at which the advertising packets are sent can be configured, allowing for flexibility based on application requirements.\nNetwork Pairing: Before the Node connects to Gateway, it sends its own information to the Gateway under a public Access Address and physical channel while also receiving network parameters from the gateway to establish the connection. This procedure is called Network Pairing.\nConnection Interval: After the nodes connect to the gateway, they will communicate periodically to determine the connection status; a timeout will indicate a disconnection. This period is called the connection interval. It must be a power of 2 multiple of the periodic advertising interval.\nNetwork Capacity # In MultiConnNet, the relationship between the Connection Interval and the Periodic Advertising Interval directly affects the connection capacity of nodes. Specifically, the Connection Interval must be a power of 2 multiple of the Periodic Advertising Interval.\nMaximum Nodes per Interval:\nEach periodic advertising interval corresponds to a specific maximum connection interval, which is determined by the formula\nMaximum Connection Interval = Periodic Advertising Interval×16 Minimum Connection Interval = Periodic Advertising Interval Each connection interval has a maximum number of nodes it can support. This capacity is fixed and should be considered when designing the network.\nAssuming the Periodic Advertising Interval is 50 milliseconds (ms), the following table lists available connection interval and corresponding maximum node count:\nConnection Interval (ms) Maximum connectable nodes 800 128 400 64 200 32 100 16 50 8 Mixed Connection Interval Trade-offs:\nWhen you introduce nodes with shorter connection intervals, the total number of nodes must be adjusted accordingly. For instance:\nIf you have 1 node with a 400 ms interval, you can only have 126 nodes with an 800 ms interval. Similarly, if you have 1 node with a 200 ms interval, you can have 124 nodes with an 800 ms interval (128 - 2). Generally, to determine the maximum number of nodes in a mixed connection interval scenario, you can follow this approach:\nThe formula states that the total time required by all nodes in the network (calculated as the sum of the time each type of node takes based on its connection interval and count) should not exceed the maximum allowable time frame represented by 16 × 8.\nConclusion:\nUsing this formula allows you to effectively manage and calculate the maximum allowable nodes in a MultiConnNet network with mixed connection intervals. Always ensure that the total time required by all nodes does not exceed the calculated limit, allowing for optimal network performance.\nData Throughput # Data throughput is dependent on connection interval. Lower connection interval, higher data throughput. Here is fomular that is used to estimate approximate data rate.\nThe maximum data rate will be (1000/50)*251 ≈ 5KBps when connection interval is 50 ms.\nPower Consumption # The Gateway is in full operation mode while node is cable of entering low power mode. It is also dependent on connection interval. Lower connection interval, higher power consumption. For maximum 800ms connection interval, node\u0026rsquo;s average current can be lower than 48uA.\n"},{"id":10,"href":"/docs/in6xx/getting-started/download/jflash-download-guide.html","title":"JFlash Programming","section":"Download Image","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XX chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). JLinkDevices Configuration # Windows # Install InPlayTools(recommended):\nInPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XX series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;, or download InPlayTools from website.\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nDownlaod Step: # Open JFlash, and select “create a new project.” Select the target device Select InPlay \u0026ldquo;IN6XX_C0_GIGA\u0026rdquo; device Note: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), select \u0026ldquo;IN6XX_C0_GIGA_8M\u0026rdquo; device.\nOpen the Bin file Click the file menu, select \u0026ldquo;Open data file\u0026rdquo;, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":11,"href":"/docs/solutions/multiconnnet/command-set.html","title":"Module Instruction Set","section":"MultiConnNet","content":" MultiConnNet Module Instruction Set # The MultiConnNet is Inplay\u0026rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.\nThe system is comprised of two primary components: the Gateway module and the Node module. The module is connected to the HOST via UART interface, and this instruction set defines the data packet format between the module and the HOST.\nThe data packet originally issued by HOST is called Command and the module will return Response to HOST accordingly. The data packet originally issued by the module is called Event.\nCommand and Response # Command and corresponding Response are data packets consist of a sequence of bytes. The format of the data packet is as follows.\nSync Word ID Owner Body Len Body (1 byte) (1 byte) (2 bytes) (2 bytes) (variable) Figure 1: Command and response data packet format\nSync Word: Fixed 0x4A for command and corresponding response.\nID: unique command id.\nOwner: Represents who will actually excute the command or who send it for response. 0 represents local module, otherwise remote module\u0026rsquo;s device address.\nBody Len: is the length of variable body that follows.\nCommand can be executed by local module or remote module. If command is executed locally (Owner in command data packet is 0), the receiver module will send back a response data packet to the HOST immediately, indicating the result of execution. This response is referred to as Local Response (Owner is 0 in response data packet). If command is executed remotely (Owner in command data packet is non-zero), the receiver module will send back local response immediately, indicating whether the command is accepted or not. If accepted, a subsequent Transmission Done Event is then received by HOST indicates the command is actually passed-through to the remote module. If the result of transmission is success, additional response data packet from the remote module will then be forwarded back to the HOST. Since Owner field is actual device address (non-zero) in this response, it is referred to as Remote Response.\nCommands that execute remotely are only issued to gateway module. For node module, all commands are local command so that Owner field is ignored.\nConfiguration commands are those that must be sent at least once by HOST prior to other commands. Parameters by configuration command can be stored in flash so that system can automatically start running each time power on reset, without configuration command being issue again. Configuration command are local command only.\nData Transmission command is the only remote command that Remote Response is not generated since data is totally passed-through to HOST and completely user dependent.\nHere are details of MultiConnNet commands and corresponding responses:\nSerial Port Configuration (ID=1) # This command changes parameters of the serial port that interacts with HOST. It is for local only. It is optional, meaning that if not configured, the module will use following default UART configurations:\nGPIO_2_1 as UART TX and GPIO_2_7 as UART RX 921,600 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The command is as follows:\nOFFSET NAME LENGTH VALUE 4 TX GPIO 1 Specify which GPIO is multiplexed for UART TX function. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_2, TX GPIO=0x02. 5 RX GPIO 1 Same as TX GPIO 6 RTS GPIO 1 Same as TX GPIO. If 0xFF, RTS signal is not used. 7 CTS GPIO 1 Same as TX GPIO. If 0xFF, CTS signal is not used 8 baud rate 4 Support 921600, 460800, 230400, 115200, 57600, 38400, 19200 12 data bit 1 Data bit length. 5 - 8 13 polarity 1 0: None\n1: Odd\n2: Even 14 stop bit 1 Stop bit number 15 receive buffer size 4 Receive buffer size, Maximum 2048 19 reserved 1 0x00 Example:\n→ 4A 01 00 00 10 00 21 27 FF FF 00 C2 01 00 08 00 01 2C 01 00 00 00 ;GPIO_2_1, GPIO_2_7, 115200bps ← 4A 01 00 00 02 00 00 00 ;Local response Network Parameter Configuration (ID=2) # This command configure module\u0026rsquo;s network parameters. It is for local only. If network parameters are stored afterwords by Reset command, module can be run automatically without sending it again.\nFor gateway module, the command is as follows:\nOFFSET NAME LENGTH VALUE 6 gateway module device address 2 A 16-bit value that can only be taken from 0x1000 to 0xF000, where the lower 12 bits are all zeros. 8 access address on connection 4 Access Address when data communication after connection 12 access address on pairing 4 Access Address when pairing procedure 16 channel on pairing 1 Channel on which pairing procedure is. Example:\n;Device address (Gateway) is 0x1000, Access Addresses are 0x67453201 and 0xABABABAB, Channel on pairing is 37 → 4A 02 00 00 0B 00 00 10 01 23 45 67 AB AB AB AB 25 ← 4A 02 00 00 02 00 00 00 For node module, the command is as follows:\nOFFSET NAME LENGTH VALUE 6 node module device address 2 A 16-bit value that can only be taken from 0x0000 to 0x0FFF, where the upper 4 bits are all zeros. 8 gateway device address 2 A 16-bit value that can only be taken from 0x1000 to 0xF000, where the lower 12 bits are all zeros. 10 access address on pairing 4 Access Address when pairing procedure 14 channel on pairing 1 Channel on which pairing procedure is. 15 connection interval 2 Node's connection interval. 17 supervision timeout 4 Time in millisecond, that allowed for a device to receive data or signals from another device. If no data is received within this timeframe, the connection may be considered lost or disconnected. 21 pair interval 2 Time interval in millisecond for sending pairing interaction information. The smaller the interval, the faster the pairing will be successful, but power consumption will increase. 23 pairing duration 4 Duration of pairing procedure in millisecond. 0 if non stop. Example:\n;Node\u0026#39;s device address is 0x0100, access address on pairing is 0x67453201, connection interval is 800ms, supervision timeout is 20000ms, pair interval is 50ms and pairing is not stopped. → 4A 02 00 00 15 00 00 01 00 10 AB AB AB AB 25 20 03 20 4E 00 00 32 00 00 00 00 00 ← 4A 02 00 00 02 00 00 00 External Power Amplifier Control Configuration (ID=3) # This command sets up module\u0026rsquo;s external Power Amplifier (PA) Control function. It is for local only. This command is optional, meaning that if not configured, the module will use following default GPIOs:\nTX enable: GPIO_3_3 RX enable: GPIO_2_5 BIAS: unused The TX enable GPIO will automatically output high to open electronic circuits of power amplifier when RF is opened for transmission. RX enable GPIO and BIAS GPIO share similar working principles.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 TX GPIO 1 GPIO which is used to control Tx_En of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_3_3, it is 0x33. 7 RX GPIO 1 GPIO which is used to control Rx_En of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_2_5, it is 0x25. 8 BIAS GPIO 1 GPIO which is used to control bias of expernal PA. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. If no bias control, set it to 0xFF. Example:\n→ 4A 03 00 00 03 00 33 25 FF ;TX GPIO is GPIO_3_3, RX GPIO is GPIO_2_5, no BIAS ← 4A 03 00 00 02 00 00 00 ;Local response Get State (ID=10) # This command retrieves the module status. It is for local only.\nThe length of this command is 0. The response is as follows:\nOFFSET NAME LENGTH VALUE 6 state 1 Current module state.\n0: Not running, module may not be fully configured yet\n1: Running Example:\n→ 4A 0A 00 00 00 00 ;Try retrieving module status ← 4A 0A 00 00 01 00 01 ;Module is running normally Get Connection (ID=11) # This command retrieves the number of connected modules and corresponding device addresses. For nodes, a return value of 0 of number indicates not connected. It is for local only.\nThe length of this command is 0. The response is as follows:\nOFFSET NAME LENGTH VALUE 6 count 1 Number of connected devices 7 device address count*2 Device addresses of connected modules. Example:\n→ 4A 0B 00 00 00 00 ;Try retrieving the connection status of gateway ← 4A 0B 00 00 07 00 03 00 01 01 01 02 01 ;Gateway has connected with 3 nodes 0x0100, 0x0101 and 0x0102 → 4A 0B 00 00 00 00 ;Try retrieving the connection status of node ← 4A 0B 00 00 03 00 01 00 10 ;Node returns connection with gateway with device address 0x1000 Module Reset (ID=0x20) # This command resets the module. For node module, this command is local only (*Owner field is ignored. For gateway module it can be locally or remotely executed. The command is as follows:\nOFFSET NAME LENGTH VALUE 6 option 1 0: Reset\n1: Reset module with previous configuration cleared\n2: Reset module with previous configuration stored Example:\n→ 4A 20 00 00 01 00 02 ;Save configuration before reset for local module ← 4A 20 00 00 02 00 00 00 ;Local response → 4A 20 00 01 01 00 00 ;Reset remote module 0x0100 from gateway ← 4A 20 00 00 02 00 00 00 ;Local module accepts command ← A4 A2 04 00 00 01 00 00 ;Transmission done event ← 4A 20 00 01 02 00 00 00 ;Remote response from node 0x0100 Modue Run (ID=0x21) # This command start or stop running of module. For node module, this command is local only. For gateway module it can be locally or remotely execution. If Network Parameter Configuration is not stored, it is necessary to send this command to start the module, otherwise module will automatically start running after power on reset.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 running 1 0: Stop1: Start Example:\n→ 4A 21 00 00 01 00 01 ;Start running of local module (either gateway or node) ← 4A 21 00 00 02 00 00 00 ;Local response → 4A 21 00 01 01 00 00 ;Stop running of remote node 0x0100 (from gateway) ← 4A 21 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 01 00 00 ;Transmission done event ← 4A 21 00 01 02 00 00 00 ;Remote response from node with device address 0x0100 Module GPIO Output (ID=0x22) # The command allows the module\u0026rsquo;s specified GPIO pin outputs to a designated level. For node, this command is local only. For gateway it can be called locally or remotely.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 GPIO 1 GPIO which is configured as output functionality. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 level 1 Output level.\n0 : Low level\nother : High level Example:\n→ 4A 22 00 00 04 00 01 01 ;Node module\u0026#39;s GPIO_0_1 outputs high ← 4A 22 00 00 02 00 00 00 ;Local response → 4A 22 01 01 04 00 01 01 ;Remote control node 0x0101 module\u0026#39;s GPIO_0_1 to output high from gateway ← 4A 22 00 00 02 00 00 00 ;Local response ← A4 66 04 00 01 01 00 00 ;Transmission to node 0x0101 done ← 4A 22 01 01 02 00 00 00 ;Remote response received from node 0x0101 Module GPIO Input Trigger (ID=0x23) # This command allows module to trigger a GPIO input event when GPIO is in a specified state. For node module, this command is local only, but the event can be either sent to its HOST via UART or remote connected device over the air depending on target field in command. For gateway module, if the command is local and then the event can only be sent to HOST via UART regarding of target field in command. If the command is remote execution, the event can be either sent to remote HOST via its UART or remotely to connected device over the air. To short, target field defines whether the event will be sent to the remote connected device corresponding to the executor of this command, with the condition that this remote device MUST only be a gateway module.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 GPIO 1 GPIO which is configured as input functionality. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 internal pull up/down 1 0: no pull up/down\n1: internal pull up\n2: internal pull down 8 edge-triggered condition 1 0x00: falling edge\n0x01: rising edge\n0x02: both edge\n0xFF: none 9 target 1 0: local HOST\n1: remote connected device Example:\n→ 4A 23 00 00 04 00 04 01 00 01 ;node module GPIO_0_4 falling edge trigger with internal pull up enabled, event will be remotely sent to gateway. ← 4A 23 00 00 02 00 00 00 ;Local response → 4A 23 01 01 04 00 04 01 00 01 ;gateway remotely set node module (0x0101) GPIO_0_4 falling edge trigger with internal pull up enabled, event will be remotely sent to gateway. ← 4A 23 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 10 00 00 ;Transmission done event ← 4A 23 01 01 02 00 00 00 ;Remote response ... ← A4 A4 04 00 01 01 04 00 ;GPIO Input trigger event Data Transmission (ID=0x30) # This command initiates user data transmission either from Gateway to Node or Node to Gateway. Module will return local response first like any other commands and then Transmission Done Event indicating actual wireless transmission is finished or not.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 data variable length Banary byte data array Example:\n→ 4A 30 01 01 03 00 0A 0B 0C ;Send 3 bytes (0A 0B 0C) from gateway to node 0x0101 ← 4A 30 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 01 01 00 00 ;Transmission done event → 4A 30 00 10 03 00 0A 0B 0C ;Send 3 bytes from node to gateway 0x1000 ← 4A 30 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 00 10 00 00 ;Transmission done event Firmware Update command (ID=0x40) # This command initiates Firmware Update to module. For node, this command is local only, while for gateway it can be called locally or remotely. If remotely, node\u0026rsquo;s firmware is updated over the air. Firmware Update consists of 3 processes, Prepare, Write, Cancel. Each process is composed of different data packet.\nPrepare # The first process is to tell Node the firmware update over the air is going to begin, along with information including new firmware size, CRC verification, AES encryption etc.\nThe command is as follows:\nOFFSET NAME LENGTH VALUE 6 process 1 0 7 firmware size 4 firmware size 11 flag 1 Each bit set to 1 indicates that the corresponding function is enabled.\nbit 0: AES encryption\nbit 4: CRC check\nother: N/A 12 CRC 4 CRC value of part of firmware binary excluding the first 16K bytes. If CRC check in flag is not set, it's ignored. Example:\n→ 4A 40 01 01 0A 00 00 20 1B 01 00 00 00 00 00 00 ;OTA prepare to node 0x0101, firmware size is 72,480 bytes, no CRC check and AES encryption ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 00 00 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response received from node 0x0101 Write # This process is called several times to do actual firmware data transmission until finished.\nThe data packet is as follows:\nOFFSET NAME LENGTH VALUE 6 process 1 1 7 offset 4 firmware offset 11 data Len-7 data length that follows Example:\n→ 4A 40 01 01 \u0026lt;len\u0026gt; 01 00 00 00 00 ... ;OTA write firmware data to node 0x0101, offset is 0, size is \u0026lt;len\u0026gt; bytes ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 00 00 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response (4A 0B 02 00 00 00) received from node 0x0101 Cancel # This command cancel any on-going OTA firmware update process.\nOFFSET NAME LENGTH VALUE 6 process 1 0xFF Example:\n→ 4A 40 01 01 01 00 FF ;OTA cancel firmware update to node 0x0101 ← 4A 40 00 00 02 00 00 00 ;Local response ← A4 A2 04 00 01 01 00 00 ;Transmission done event ← 4A 40 01 01 02 00 00 00 ;Remote response (4A 0B 02 00 00 00) received from node 0x0101 Response # A Response is the data packet returned by the module, indicates whether the command has been accepted or not. The body of Response is a fixed length of two bytes called Result, following the same header as the corresponding command. The Response can be local response sent by local module, or remote response sent by remote module, which is included in the data of the Data Reception Event. Both local response and remote response share the same data structure.\nThe available Result values are as follows:\nNAME VALUE MEANING WL_ERR_NO_ERROR 0 Success WL_ERR_CMD 0x10010 Sync Word in data head error WL_ERR_CMD_ID 0x1002 ID in data head error WL_ERR_CMD_PARAM 0x1003 Parameter error WL_ERR_TIMEOUT 0x1004 Command executing timeout WL_ERR_BUSY 0x1005 Command is not acceptable due to system busy WL_ERR_NOT_READY 0x1006 System is not ready of well configured Event Description # An Event is the data packet actively sent by the module to the HOST. Events have Sync Word 0xA4 in their data packet and unique event identifier follows. The format of the data packet is as follows.\nSync Word ID Body Len Body (1 byte) (1 byte) (2 bytes) (variable) Figure 1: Event data packet format\nSync Word: Fixed 0xA4.\nID: unique event id.\nBody Len: is the length of variable body that follows.\nHere are details of MultiConnNet events:\nModule Ready Event (ID=0xA0) # This event indicates system is ready to accept command from HOST. It has no body so the body len field is 0.\nExample:\n← A4 A0 00 00 Connection Event (ID=0xA1) # This event indicates Gateway/Node has successfully connected or disconnected to each other.\nOFFSET NAME LENGTH VALUE 4 connection 1 0: disconnect\n1: connect 5 device address 2 Remote device address Example:\n← A4 A1 03 00 01 00 01 ;Gateway has connected with node 0x0100 Transmission Done Event (ID=0xA2) # This event indicates data has been actually transmitted over the air.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remove device address 5 result 2 Transmission result.\n0 : success\nother : protocol-level errors Example:\n← A4 A2 04 00 00 01 00 00 ;Gateway has transmitted data to node with device address 0x0100 Data Reception Event (ID=0xA3) # This event indicates data has been received from remote connected devices.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remote device address 6 data Len-2 Banary byte data array Example:\n← A4 A3 05 00 00 01 00 01 02 ;Gateway has received 3 bytes data from node 0x0100 GPIO Input Trigger Event (ID=0xA4) # This event indicates GPIO\u0026rsquo;s input status is triggered, which is configured by GPIO Input Configuration command. This event can be sent to local HOST or remote devices, depending on device address parameter in event data body.\nOFFSET NAME LENGTH VALUE 4 device address 2 Remote device address, or local if 0. 6 GPIO 1 GPIO which input status is triggered. The upper 4 bits represent the Port, and the lower 4 bits represent the Pin. For example, for GPIO_0_4, it is 0x04. 7 level 1 Current GPIO level Example:\n← A4 A4 04 00 01 01 04 00 ;Node 0x0101 GPIO_0_4 falling edge trigger "},{"id":12,"href":"/docs/in6xx/getting-started/download/mp-tool-guide.html","title":"MP Tool Guide","section":"Download Image","content":" MP Tool Guide # Introduction # The MP Tool is a tool for mass production downloading and testing, capable of downloading the main program and token, as well as testing RF performance. Please refer to this document for details.\n"},{"id":13,"href":"/docs/in6xx/getting-started/installation/quick-start.html","title":"Quick Start","section":"Installation","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_find_my\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall InPlayInc.DeviceFamilyPack. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;, or download InPlayInc.DeviceFamilyPack from website.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun InPlay SwiftConfig Tool. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_find_my/build/mdk/proj_ble_lp.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN612L\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Note: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), select \u0026ldquo;IN610_G8C0I\u0026rdquo; device.\nClick \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes. Note:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIf Keil displays the following warning dialog, please click the OK button and then select Cortex-M4 on the next page. In the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN602C0 GD25WD40C SPI FLASH \u0026ldquo;flm file by click \u0026ldquo;Add\u0026rdquo; button. Then set start addres to 0x210000 and set size to 0x1000.\nNote: If chip is \u0026ldquo;IN610-Q32-R-G8C0I\u0026rdquo;(1MB Flash), flm file is \u0026ldquo;IN602C0 GD25WD80C SPI FLASH\u0026rdquo;.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":14,"href":"/docs/solutions/multiconnnet/user-guild.html","title":"User Guilde","section":"MultiConnNet","content":" MultiConnNet User Guilde # Proper module configuration is essential before the MultiConnNet network can operate normally. However, it is necessary to understand the essential information beforehand.\nBoot Mode: The module can enter Boot mode when GPIO_0_4 is connected to GND during power-up or reset, allowing for firmware flashing, storage resetting, and other operations.\nInteractive Interface: By default, UART1 is used as interface between HOST and module, with GPIO_2_1 and GPIO_2_7 as TX and RX function, 921600 baud rate, 8N1. This can be reconfigured.\nLog Interface: By default, UART0 is used as log interface, with GPIO_0_2 as TX function, 921600 baud rate, 8N1. If interactive interface is changed, log interface changed automatically. For example, if interactive interface change to UART0，log interface will change to UART1 with GPIO_2_1 as TX function.\nPA Control IO: By default, GPIO_3_3 is used as TX enable function and GPIO_2_5 as RX enable function, no BIAS control. It can be reconfigured.\nConfiguration # The module is in a non-operational state until the network parameters are configured. There are two methods to configure the module\u0026rsquo;s network parameters: real-time configuration through the interactive interface, and static configuration via BLE connection. Regardless of the method used, the configuration commands are the same as what are documented in MultiConnNet Instruction Set.\nReal-Time Configuration # During real-time configuration, once the system is powered on and the module is ready (ready event sent), the HOST can send commands to the module through the interactive interface to configure and start the module, allowing it to operate as required. By sending different configuration parameters each time the module is powered on, different operations can be executed, hence the term \u0026ldquo;real-time configuration.\u0026rdquo;\nBLE Connection Static Configuration # When the module is in a non-operational state, it will start a connectable BLE advertisement. When a Master device, such as a smartphone, connects to the module, it can send commands to the module via the corresponding GATT Service to configure and start the module, enabling it to work as required.\nGenerally, configuration commands are sent first, followed by Run command to start the operation to test if the module operates correctly. Then restart the module and repeat the previous configuration, and store them. After that, when the module is powered on, it will automatically run, hence the term \u0026ldquo;static configuration.\u0026rdquo; Once the module can run automatically, it can only receive the corresponding commands through real-time configuration.\nHere is an example of the configuration steps for the gateway and node using the nRF Connect app on a smartphone.\nGateway Configuration # Step 1: Scan for the broadcast named \u0026ldquo;gateway\u0026rdquo; and click \u0026ldquo;connect\u0026rdquo; to establish a connection.\nStep 2: Once connected, a GATT service for configuration commands will appear.\nStep 3: Send the Network Parameter Configuration command 4A 05 1 01 23 45 67 AB AB AB AB 01 00 00 10 32 00 40 00 by GATT Write method, to configure gateway’s network parameters. The response to this command is sent back by GATT Notify method.\nStep 4: If everything goes well, restart the gateway and repeat Steps 1 to 3. Finally, send Reset command 4A 01 01 02 by GATT Write method, to save configuration before reboot. Then it will automatically run, even after power lost.\nFor detailed parameters in above command, please refer to the instruction set documentation.\nNode Configuration # Step 1: Scan for the broadcast named \u0026ldquo;node\u0026rdquo; and click \u0026ldquo;connect\u0026rdquo; to establish a connection.\nStep 2: Once connected, a GATT service for configuration commands will appear.\nStep 3: Send the Network Parameter Configuration command 4A 05 15 00 01 00 10 AB AB AB AB 25 20 03 20 4E 00 00 32 00 00 00 00 00 by GATT Write method, to configure the node’s network parameters. The response to this command is sent back by GATT Notify method. In this example, node’s device address is 0x0100. For configuring other nodes, this address must be different.\nStep 4 (option): Send the GPIO Input Configuration command 4A 07 04 04 01 00 01 by GATT Write method, to configure node’s GPIO_0_4 as input function and send its GPIO Input Trigger event to remote Gateway.\nStep 5: Send the Run command 4A 08 01 01 by GATT Write method, to start operation to test if previous configurations work correctly. Optionally, pull GPIO_0_4 to ground to trigger GPIO input event and remote gateway should receive corresponding event.\nStep 6: If everything goes well, restart the node and repeat Steps 1 to 4. Finally, send Reset command 4A 01 01 02 by GATT Write method, to save configuration before reboot. Then it will automatically run, log into the gateway, and maintain the connection, even after power lost.\nReset Configuration # There are two methods to reset the module:\n1. Real-time via Interactive Interface: Send the Reset command 4A 01 01 01 to the module through the interactive interface, with the option parameter set to 1. For detailed instructions, please refer to the MultiConnNet Module Instruction Set.\n2. Reset via JLINK: Use the Segger J-Flash tool to erase the Flash memory. For specific instructions on using the tool, refer to the JFlash Programming Guide. Execute the following command to erase the Flash at the specified address:\nGPIO Control # If optionally GPIO Input Configuration command is sent to node model (Step 4 in Node\u0026rsquo;s Configuration), the corresponding GPIO Input Trigger Event is sent to either local HOST or the remote gateway after being triggered locally, depending on the target field in the command.\nHere is gateway log snapshot:\nAccordingly, Gateway can also use GPIO Output command to control either local or remote node\u0026rsquo;s GPIO output level, depending on the \u0026ldquo;target device address\u0026rdquo; field in command. For example, send 4A 0A 04 04 01 00 01 to gateway to output GPIO_0_4 high on the node device of 0x0100. If there is a LED driven by GPIO_0_4 on node, LED can be turned on or off remotely.\nLow Power Mode # The Node\u0026rsquo;s UART Rx signal of the interactive interface needs to be grounded manually, for example GPIO_2_7, to let driver stop working and then module is able to enter sleep mode. Setting the UART Rx signal of the interactive interface to high can wake the module up from sleep mode, and communication recovers.\nData transmission # Data transmission can be categorized into two types: one is the remote control functionality like discussed earlier using GPIO control; the other is real-time data transmission via the interactive interface (UART) through sending data commands. For detailed commands, please refer to the instruction set documentation.\nDue to the remote control functionality in GPIO control, please ensure that the data sent by real-time data transmission does not start with 0x4A or 0xA4, to avoid the module mistakenly interpreting it as its own command.\nDemo Host Implementation on Windows # TBD\n"}]