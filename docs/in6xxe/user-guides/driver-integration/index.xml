<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Driver Integration on InPlay Doc</title><link>/docs/in6xxe/user-guides/driver-integration.html</link><description>Recent content in Driver Integration on InPlay Doc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>InPlay Inc</copyright><atom:link href="/docs/in6xxe/user-guides/driver-integration/index.xml" rel="self" type="application/rss+xml"/><item><title>ADC Guide</title><link>/docs/in6xxe/user-guides/driver-integration/adc-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/adc-guide.html</guid><description>ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.
Key Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.</description></item><item><title>Antenna Diversity</title><link>/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html</guid><description>Antenna Diversity # Overview # The antenna diversity engine supports signal RSSI evaluation and antenna switching, and it supports both dual and 4 antennas. Signal evaluation and antenna switching are performed in the background by the chip&amp;rsquo;s hardware modules.
API # initialization. # int hal_ana_diversity_init(uint8_t num_ants, uint8_t frz_time, uint32_t agc_stable_time);
void hal_ann_2diversity_gpio25_invgpio00_sw_init(void);
void hal_ann_4diversity_gpio25_gpio26_sw_init(void); Example of Dual Antenna # int main(void)
{
int res;
uint8_t tx_buf[16];
sdr_mstr_scan_t scan_cfg;
hal_global_post_init();
PRINTD(DBG_TRACE, &amp;#34;%s %s\r\n&amp;#34;, __DATE__, __TIME__);
PRINTD(DBG_TRACE, &amp;#34;CHIP ID = %08X\r\n&amp;#34;, chip_get_id());
hal_ana_diversity_init(2, 40, 40); hal_ann_2diversity_gpio25_invgpio00_sw_init();
res = in_sdr_init();
if (SDR_ERR_OK !</description></item><item><title>AOA Antenna Guide</title><link>/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html</guid><description>AOA Antenna # Overview # AOA Antenna engine supports antenna switching and IQ capture,as shown in the following Figure.AOA Antenna engine supports IQ capture for constant tone inside the payload and attached to the packet after CRC.
Below are some key features of the AoA antenna switching IQ capture engine:
Programmable SYNC address (preamble is not programmable) Programmable channel index and frequency relationship The enable/disable of whitening is programmable (the whitening sequence is not programmable, it is decided by the channel index) Support up to 256 antenna patterns.</description></item><item><title>Counter Guide</title><link>/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html</guid><description>Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.
The 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.</description></item><item><title>CRC Guide</title><link>/docs/in6xxe/user-guides/driver-integration/crc-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/crc-guide.html</guid><description>CRC Guide # Overview # CRC (Cyclic Redundancy Check) is a widely used error-detecting code in digital communication networks and storage devices. It is a mathematical algorithm that calculates a checksum based on the data being transmitted or stored, which can then be used to detect errors during transmission or storage.
Features # Support calculate fix length data or variable length data Support DMA(need occupy one I2C DMA channel) Support configuare parameters such as polynomial selection, initial value, XOR output and so on.</description></item><item><title>GPIO Guide</title><link>/docs/in6xxe/user-guides/driver-integration/gpio-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/gpio-guide.html</guid><description>GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:
Digital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to &amp;ldquo;proj_drv_gpio&amp;rdquo;.
Configure GPIO to output and output high/low:</description></item><item><title>I2C Communication</title><link>/docs/in6xxe/user-guides/driver-integration/i2c-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/i2c-guide.html</guid><description>I2C Guide # Overview # I2C (Inter-Integrated Circuit) is a simple serial communication protocol commonly used to connect microcontrollers with various electronic devices such as sensors and memories. It utilizes only two wires: a clock line (SCL) for synchronizing data transfer and a data line (SDA) for sending and receiving data. Key Features # Multi-Master Capability: Multiple masters can be connected to the same bus and communicate with different slave devices.</description></item><item><title>SPI Communication</title><link>/docs/in6xxe/user-guides/driver-integration/spi-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/spi-guide.html</guid><description>SPI Guide # Overview # SPI, which stands for Serial Peripheral Interface, is a high-speed, full-duplex, synchronous communication bus that allows data transmission between a microcontroller and peripheral devices. It utilizes a master-slave model, with the master device controlling a set of slave devices. SPI requires four signal lines:
SCLK for synchronization
MOSI for data transmission from master to slave
MISO for data transmission from slave to master
SSN for selecting the slave device to communicate with.</description></item><item><title>UART Communication</title><link>/docs/in6xxe/user-guides/driver-integration/uart-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/uart-guide.html</guid><description>UART Guide # Overview # The Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol that enables serial data transmission between devices. It is widely used for communication between microcontrollers and various peripherals, such as computers, sensors, and other embedded systems.
Initialization # Before using the UART interface, it needs to be properly initialized. Configure the UART settings according to the uart_init_t struct:
uart_init_t init = {0}; init.baud_rate = 115200; /**&amp;lt; Baud rate (e.</description></item></channel></rss>