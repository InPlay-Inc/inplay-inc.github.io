<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Driver on InPlay Doc</title><link>/docs/in6xxe/samples/driver.html</link><description>Recent content in Driver on InPlay Doc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>InPlay Inc</copyright><atom:link href="/docs/in6xxe/samples/driver/index.xml" rel="self" type="application/rss+xml"/><item><title>ADC Sample</title><link>/docs/in6xxe/samples/driver/adc-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/adc-sample.html</guid><description>ADC Sample # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.</description></item><item><title>AES Sample</title><link>/docs/in6xxe/samples/driver/aes-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/aes-sample.html</guid><description>AES Sample # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.
AES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted.</description></item><item><title>ECC Sample</title><link>/docs/in6xxe/samples/driver/ecc-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/ecc-sample.html</guid><description>ECC Sample # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.
Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.</description></item><item><title>GPIO Interrupt Sample</title><link>/docs/in6xxe/samples/driver/gpio-interrupt-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/gpio-interrupt-sample.html</guid><description>GPIO Interrupt Sample # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.</description></item><item><title>GPIO Reset Sample</title><link>/docs/in6xxe/samples/driver/gpio-reset-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/gpio-reset-sample.html</guid><description>GPIO Reset Sample # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.</description></item><item><title>GPIO Sample</title><link>/docs/in6xxe/samples/driver/gpio-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/gpio-sample.html</guid><description>GPIO Sample # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.
In this example, we can achieve basic input and output functionality using GPIO.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.</description></item><item><title>GPIO Wake Interrupt Sample</title><link>/docs/in6xxe/samples/driver/gpio-wake-interrupt-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/gpio-wake-interrupt-sample.html</guid><description>GPIO Wake Interrupt Sample # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.</description></item><item><title>GPIO Wake Sample</title><link>/docs/in6xxe/samples/driver/gpio-wake-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/gpio-wake-sample.html</guid><description>GPIO Wake Sample # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.</description></item><item><title>I2C Sample</title><link>/docs/in6xxe/samples/driver/i2c-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/i2c-sample.html</guid><description>I2C Sample # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.
This routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication.</description></item><item><title>Keyboard Sample</title><link>/docs/in6xxe/samples/driver/keyboard-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/keyboard-sample.html</guid><description>Keyboard Sample # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.</description></item><item><title>PWM Sample</title><link>/docs/in6xxe/samples/driver/pwm-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/pwm-sample.html</guid><description>PWM Sample # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.
This routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.</description></item><item><title>QDEC Sample</title><link>/docs/in6xxe/samples/driver/qdec-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/qdec-sample.html</guid><description>QDEC Sample # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.
This routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).</description></item><item><title>SPI Sample</title><link>/docs/in6xxe/samples/driver/spi-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/spi-sample.html</guid><description>SPI Sample # Overview # SPI (Serial Peripheral Interface) communication is a synchronous serial transmission specification typically used for communication between microprocessing control units (MCUs) and peripheral devices. This communication method is characterized by its high speed, full-duplex, and synchronous nature, achieving data transmission through four wires (MISO, MOSI, SCLK, CS/SS) on chip pins.
SPI communication consists of a master device and one or more slave devices. The master device initiates synchronized communication with the slave devices to complete data exchange.</description></item><item><title>Timer Sample</title><link>/docs/in6xxe/samples/driver/timer-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/timer-sample.html</guid><description>Timer Sample # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.
This routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.</description></item><item><title>Trigger Sample</title><link>/docs/in6xxe/samples/driver/trigger-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/trigger-example-guide.html</guid><description>Trigger Sample # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger.</description></item><item><title>UART Sample</title><link>/docs/in6xxe/samples/driver/uart-routine-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/driver/uart-routine-guide.html</guid><description>UART Sample # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.
In this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.</description></item></channel></rss>