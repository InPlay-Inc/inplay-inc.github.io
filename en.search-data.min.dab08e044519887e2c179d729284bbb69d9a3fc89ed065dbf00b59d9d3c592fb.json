[{"id":0,"href":"/docs/in6xxe/getting-started/inplay-ble5.0-at-command-set.html","title":"BLE5.0 AT Command Set","section":"Getting Started","content":" Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.\nIN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.\nCONTROL INTERFACE # The AT commands are transmitted over standard UART interface. A terminal emulator, such as TeraTerm (Windows) or CoolTerm (Mac OS-X®), can be used to control the module from a computer, with the following default port settings:\n115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The serial port parameter configure command can modify the UART settings permanently.\nSYNTAX # The AT commands can be divided into 3 main categories: Command, Response and Event. The module receives Command and, after execution, sends back Response to the command initiator. When something happens in the module, such as an unexpected disconnection, receiving data from a remote device, etc., a corresponding Event is sent.\nCOMMAND SYNTAX # An AT command is composed of the Prefix, CommandID, CommandBody and Terminator as shown below.\nAT+\u0026lt;CommandID\u0026gt;=\u0026lt;CommandBody\u0026gt;\u0026lt;Terminator\u0026gt; The Prefix of each command is fixed ASCII string \u0026ldquo;AT\u0026rdquo; or \u0026ldquo;at\u0026rdquo;.\nCommandID is an ASCII string representing different command. It\u0026rsquo;s case sensitive.\nCommandBody can be either ASCII \u0026lsquo;?\u0026rsquo; if the command gets a parameter or parameters set if the command sets parameter. A parameter set is a collection of parameters surrounded by \u0026lsquo;[]\u0026rsquo;, each separated by \u0026lsquo;,\u0026rsquo;.\nTerminator of each command is carriage return (CR, \u0026lsquo;\\r\u0026rsquo;, \\x0d) and line feed (LF, \u0026lsquo;\\n\u0026rsquo;, \\x0a). Command is accepted and executed only when the Terminator is received.\nRESPONSE SYNTAX # After an AT command is executed, a response will be sent back. Response consists of corresponding CommandID, ResponseBody and Terminator as shown below.\n+\u0026lt;CommandID\u0026gt;=\u0026lt;ResponseBody\u0026gt;\u0026lt;Terminator\u0026gt; If command is to set parameter, the ResponseBody is either parameter set read or just a numerical error result code. The format of the read parameter set is same as the format of the set parameters of the corresponding command. Only result code is returned for set parameter commands.\nEVENT SYNTAX # An event is a message reported by the module initiatively, rather than a response obtained through the AT command. An event consists of EventID, EventBody and Terminator as shown in below.\n+\u0026lt;EventID\u0026gt;=\u0026lt;EventBody\u0026gt;\u0026lt;Terminator\u0026gt; EventID is an ASCII string representing different event. It\u0026rsquo;s case sensitive. EventBody is a parameter set and its format is same as CommandBody in AT command. Terminator is same as that in AT command response.\nPARAMETER VALUE # Parameter in parameter set supports numeric values, strings. There are three format of string: ASCII format string, Byte Array format string and Base64 encoding format string.\nEXAMPLES # The below table lists some examples of AT commands and their responses and events.\nCommand/Event Function Response AT+DEVCFG=[10,\"112222222211\",0,\"Slave\",1] Set device general configuration +DEVCFG=0000H AT+DEVCFG=? Get device general configuration +DEVCFG=[10,\"112222222211\",0,\"Slave\",1] AT+CFGADVACTV=[1,0,1,500,0,\"BwlJbnBsYXk=\"] Create legacy connectable advertising in 500ms interval. The payload is local name \"Inplay\" +CFGADVACTV=0000H: successful\n+CFGADVACTV=0043H: error advertising can't be create -EVTCONN=[1,\"EFBBCCCCDDEF\",1,1] Connected with device \"EF:DD:CC:CC:BB:EF\" on 1M PHY COMMAND REFERENCE # This section describes AT commands in detail and provides examples. Those parameter surrounded by \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; brackets are optional in some cases. If an optional parameter needs to be set, all optional parameters prior to that optional parameter must also be provided.\nSince the responseBody of the response returned by the get command is the same as the CommandBody of the corresponding set command, for simplicity, only the format of the get command is listed.\nGet Module State # This command gets the current status of the module.\nCommand: AT+STATE=?\nResponse: +STATE=[sys_state,pair_state,conn_state,scan_state,adv_state]\nParameter Type Value sys_state Number 0: Not ready;\n1: Ready pair_state Number 0: Not paired;\n1: Paired conn_state Number 0: Unconnected\n1: Connecting 2: Connected scan_state Number 0: Scanning Stopped;\n1: Scanning Started adv_state Number 0: Advertising Stopped;\n1: Advertising Started Example:\n→AT+STATE=?\n←+STATE=[1,0,0,0,0]\nGet Version # This command gets the version of the module including chip version, sdk version and firmware version\nCommand: AT+VER=?\nResponse: +VER=[chip_ver,sdk_ver,fw_ver]\nParameter Type Value chip_ver String Chip version sdk_ver String SDK version fw_ver String Firmware version Example:\n→AT+VER=?\n←+VER=[\u0026ldquo;602F0100\u0026rdquo;,\u0026ldquo;3.0.0\u0026rdquo;,\u0026ldquo;xxxx\u0026rdquo;]\nUART Configuration # This command sets UART parameters. Once UART parameter is changed, module will automatically reset and all parameters configured before will be lost.\nCommand: AT+CFGUART=[baud_rate,\u0026lt;data_bit\u0026gt;,,\u0026lt;stop_bit\u0026gt;]\nResponse: +CFGUART=err_code\nParameter Type Value baud_rate Number Standard UART baud rate value data_bit Number 5 - 8 bits polarity Number 0：No polarity\n1：Odd polarity\n2：Even polarity\nOther: invalid value stop_bit Number 0: 1 stop bits\n1: 2 stop bits Example:\n→AT+CFGUART=[921600,8,0,1]\n←+CFGUART=0000H\nDevice General Configuration # This command gets or sets the general parameters of the module.\nCommand: AT+CFGDEV=[role,dev_addr,addr_type,dev_name,phy]\nResponse: +CFGDEV=err_code\nParameter Type Value role Number 1 Observer 2 Broadcaster 5 Central 10 Peripheral 15 All Role dev_addr String Byte Array format string representing MAC address of device in little-endian mode addr_type Number 0: Public address;\n1: Static random address dev_name String ASCII phy Number 0 Random 1 1M Phy 2 2M Phy 4 Coded Phy Example:\n//Set device as BLE Peripheral, device public MAC address is 11-22-22-22-22-11, device name is \u0026ldquo;Slave\u0026rdquo; and prefered PHY is 1M PHY\n→AT+CFGDEV=[10,\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,1]\n←+CFGDEV=0000H\n//Set device as All role and prefered PHY is Coded Phy\n→AT+CFGDEV=[15,\u0026ldquo;AABB0101BBAA\u0026rdquo;,0,\u0026ldquo;Slave\u0026rdquo;,4]\n←+CFGDEV=0000H\nData Transparent Transmission Service Configuration # This command gets or sets parameters of Inplay private data transparent tranmission service as GATT server, including service UUID, maximum data transmission size etc. After the execution of the command, the service with specified parameters will be created. It MUST be sent after +CFGDEV\nIt is only allowed by device with \u0026lsquo;Peripheral role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXSVC=[start_hdl,svc_uuid,max_data_sz]\nResponse: +CFGTRXSVC=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically created\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied max_data_sz Number Maximum data transmission size\n0: Default 20 bytes\n1 - 1024: Maximum data size Example:\n//Set service UUID as 1122b4f8-cdf3-11e9-a32f-2a2ae2dbcce4 and the maximum transmission data as 512 bytes.\n→AT+CFGTRXSVC=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;,512]\n←+CFGTRXSVC=0000H\n//Set service UUID by default. Fixed service start handle to 20\n→AT+CFGTRXSVC=[20,\u0026quot;\u0026quot;,0]\n←+CFGTRXSVC=0000H\nData Transparent Transmission Client Configuration # This command gets or sets parameter of Inplay private data transparent tranmission service as GATT client. If parameters are not set or parameter \u0026lsquo;start_hdl\u0026rsquo; is set to 0, device will initiate a Service Discovery Process (SDP) to find remote service after connection.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGTRXCLT=[start_hdl,svc_uuid]\nResponse: +CFGTRXCLT=err_code\nParameter Type Value start_hdl Number The start GATT handle of service\n0: automatically get by SDP\nother: user specific handle number svc_uuid String Byte Array format string representing 16-byte service UUID in little-endian mode. If it is empty, default \"ccddb4f8-cdf3-11e9-a32f-2a2ae2dbcce4\" is applied Example:\n//Set to discover service by SDP.\n→AT+CFGTRXCLT=[0,\u0026ldquo;e4ccdbe22a2a2fa3e911f3cdf8b42211\u0026rdquo;]\n←+CFGTRXCLT=0000H\n//Set specific start handle and leave other in default, so that SDP is not necessary.\n→AT+CFGTRXCLT=[20,\u0026quot;\u0026quot;]\n←+CFGTRXCLT=0000H\nRF Configuration # This command gets or sets RF related parameter.\nCommand: AT+CFGRF=[tx_power]\nResponse: +CFGRF=err_code\nParameter Type Value tx_power Number TX power: 0Max TX power (~8dBm) 1-157dBm to 0dBm with step 0.5dBm 16-22-1dBm to -7dBm with step -1dBm Example:\n//Set TX power +3dBm\n→AT+CFGRF=[9]\n←+CFGRF=0000H\nSMP Configuration # This command gets or sets security parameters of the module.\nCommand: AT+CFGSMP=[smp,dev_io_cap,pairing_code]\nResponse: +CFGSMP=err_code\nParameter Type Value smp Number (1 byte) - - - - LE Secure Connection MITM - Encryption - - - - Bit3 Bit2 - Bit0 0: false; 1: true dev_io_cap Number 0 Display Only 1 Display Yes No 2 Keyboard Only 3 Keyboard Display 4 No Input No Output pairing_code String ASCII Paring code Example:\n//Set SMP to MITM security and encryption, with ability of keyboard input. The corresponding MITM pairing code is 012345\n→AT+CFGSMP=[5,2,\u0026ldquo;012345\u0026rdquo;]\n←+CFGSMP=0000H\nTarget Device Configuration # This command gets or sets the target devices that are allowed to connect or scan. If initiating activity is configured as direct connection type, only first device in the device list is the target. Maximum 25 target devices can be set.\nIt is only allowed by device with ‘Central role’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGTARGET=[dev1_addr,dev1_addr_type,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_addr_type\u0026gt;,\u0026hellip;]\nResponse: +CFGTARGET=err_code\nParameter Type Value dev_addr String Byte Array format string representing MAC address of target device in little-endian mode dev_addr_type Number 0: Public address;\n1: Static random address Example:\n→AT+CFGTARGET=[\u0026ldquo;112222222211\u0026rdquo;,0,\u0026ldquo;AABBCCCCDDEE\u0026rdquo;,0]\n←+CFGTARGET=0000H\nAdvertising Activity Configuration # This command sets parameter to create BLE advertising activity. Maximum 2 advertising activities can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Peripheral’ or ‘All role’, otherwise 1001H error code is returned.\nCommand: AT+CFGADVACTV=[actv_id,adv_type,connectable,intv,chn,payload]\nResponse: +CFGADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity adv_type Number 0: Legacy Advertise 1: Extended Advertise connectable Number 0: Unconnectable 1: Connectable intv Number 20-10240ms chn Number 0: all BLE advertising channel\n37-39: Fixed channel payload String BLE standard advertising data format in base64 encoding\nLength (1 byte) + Type (1 byte) + Content (length -1 byte) Example:\n//Set legacy connectable advertising in 500ms interval. The payload is local name \u0026ldquo;Inplay\u0026rdquo;\n→AT+CFGADVACTV=[1,0,1,500,0,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n//Successfully set\n←+CFGADVACTV=0000H\nScan Activity Configuration # This command sets parameter to create BLE scan activity. Only one scan activity can be created.\nIt is only allowed by device with \u0026lsquo;Central role\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGSCANACTV=[actv_id,type]\nResponse: +CFGSCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity type Number 2: Observer\n3: Selective observer. Only devices configured by +CFGTARGET will be reported Example:\n//Set scan activity\n→AT+CFGSCANACTV=[20,3]\n//Successfully set\n←+CFGSCANACTV=0000H\nInitiating Activity Configuration # This command sets parameter to create BLE initiating activity to establish connections with the target device. Only one initiating activity can be created.\nIt is only allowed for device which role is configured as \u0026lsquo;Central\u0026rsquo; or \u0026lsquo;All role\u0026rsquo;, otherwise 1001H error code is returned.\nCommand: AT+CFGINITACTV=[actv_id,type]\nResponse: +CFGINITACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activity type Number 0: Direct connect\n1: Auto connect. Only devices configured by +CFGTARGET can be connected Example:\n//Create initiating activity to auto connect with target devices.\n→AT+CFGINITACTV=[10,1]\n//Successfully set\n←+CFGINITACTV=0000H\n//Create initiating activity to direct connect with remote device.\n→AT+CFGINITACTV=[10,0]\n//Successfully set\n←+CFGINITACTV=0000H\nStart Advertising Activity # This command start advertising activity that is created by previous +CFGADVACTV command.\nCommand: AT+ADVACTV=[actv_id,op,\u0026lt;duration\u0026gt;]\nResponse: +ADVACTV=err_code\nParameter Type Value actv_id Number Unique ID for advertising activities op Number 0: Stop Activity\n1: Start Activity duration Number 0: Forever\n10-65535: Actual duration (in unit of 10ms)\nDefault 0 Example:\n//Start advertising activty permanently\n→AT+ADVACTV=[1,1,0]\n//Successfully set\n←+ADVACTV=0000H\n//Stop advertising activity\n→AT+ADVACTV=[1,0]\n←+ADVACTV=0000H\nStart Scan Activity # This command start scan activity that is created by previous +CFGSCANACTV command. If target devices are not configured by +CFGTARGET command, advertisement from any devices scaned will be reported.\nCommand: AT+SCANACTV=[actv_id,op,\u0026lt;intv\u0026gt;,\u0026lt;wnd\u0026gt;,\u0026lt;chn\u0026gt;,\u0026lt;duration\u0026gt;,\u0026lt;dup_filter\u0026gt;]\nResponse: +SCANACTV=err_code\nParameter Type Value actv_id Number Unique ID for scan activity op Number 0: Stop Activity\n1: Start Activity intv Number Scan activity interval 3-40959 ms\nDefault 200ms wnd Number Scan running time, must be less than intv\nDefault 100ms chn Number 0: Scan on three channel alternately\n37-39: Scan on fixed channel\nDefault 0 duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 dup_filter Number 0: No filtering\n1: Filter duplicates within the duration\nDefault 0 Example:\n//Start scan activty permanently\n→AT+SCANACTV=[20,1,200,100,0,0,1]\n//Successfully set\n←+SCANACTV=0000H\n//Stop scan activity\n→AT+SCANACTV=[20,0]\n←+SCANACTV=0000H\nStart Initiating Activity # This command start initiating activity that is created by previous +CFGINITACTV command. If target devices are not configured by +CFGTARGET command, activity cann\u0026rsquo;t be started and retures error response. When it is started permanently, it will end until all target devices configured are connected.\nCommand: AT+INITACTV=[actv_id,op,\u0026lt;conn_intv\u0026gt;,\u0026lt;latency\u0026gt;,\u0026lt;sup_tmo\u0026gt;,\u0026lt;duration\u0026gt;]\nResponse: +INITACTV=err_code\nParameter Type Value actv_id Number Unique ID for initiating activity op Number 0: Stop Activity\n1: Start Activity conn_intv Number Connection interval: 8 - 4800 ms\nDefault 100 ms latency Number 0 - 499\nDefault 0 sup_tmo Number 100 - 32000 ms\nDefault 20000 ms duration Number 0: Forever\n10-655350: Actual duration in ms\nDefault 0 Example:\n//Start initiating activty\n→AT+INITACTV=[10,1,200,0,20000,0]\n//Successfully set\n←+INITACTV=0000H\n//Stop initiating activity\n→AT+INITACTV=[10,0]\n←+INITACTV=0000H\nGet current connection list # This command gets a list of currently connected devices.\nCommand: AT+CONNLST=?\nResponse: +CONNLST=[\u0026lt;dev1_addr\u0026gt;,\u0026lt;dev1_role\u0026gt;,\u0026lt;dev2_addr\u0026gt;,\u0026lt;dev2_role\u0026gt;,\u0026hellip;]\nParameter Type Value dev_addr String The Byte Array format string representing MAC address of peer device in little-endian mode dev_role Number 0: Peer device as Master role;\n1: Peer device as Slave role Example:\n→AT+CONNLST=?\n//Connect to master device \u0026ldquo;66-55-44-33-22-11\u0026rdquo; and a peripheral device \u0026ldquo;FF-EE-DD-CC-BB-AA\u0026rdquo;\n←+CONNLST=[\u0026ldquo;112233445566\u0026rdquo;,0,\u0026ldquo;AABBCCDDEEFF\u0026rdquo;,1]\nStart Pairing # This command start operation of BLE pairing with connected device.\nCommand: AT+BOND=[op,dest_addr,\u0026lt;pairing_code\u0026gt;]\nResponse: +BOND=err_code\nParameter Type Value op Number 0: Cancel pairing\n1: Start pairing dest_addr String The Byte Array format string representing MAC address of connected device in little-endian mode pairing_code String 6 bytes ASCII pairing code Example:\n→AT+BOND=[1,\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;012345\u0026rdquo;]\n←+BOND=0000H\n//Stop pairing\n→AT+BOND=[0,\u0026ldquo;112233445566\u0026rdquo;]\n←+BOND=0000H\nData Transmit # This command transmit data via Inplay private transparent transmission service.\nCommand: AT+DATATX=[dest_addr,data]\nResponse: +DATATX=err_code\nParameter Type Value dest_addr String The Byte Array format string representing MAC address of destination connected device in little-endian mode data String Base64 encoding string representing binary data to transmit Example:\n//Send data \u0026ldquo;0x0001020304050607080910\u0026rdquo; to remove device \u0026ldquo;66-55-44-33-22-11\u0026rdquo;\n→AT+DATATX=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n←+DATATX=0000H\nReset # This command causes the system to reset. While execution, application can choose whether to save or clear current configured parameters permanently. This command don\u0026rsquo;t have any response. The application determines whether reset is complete or not by receiving the +EVTREADY event.\nCommand: AT+SYSRST=[op]\nResponse: N/A\nParameter Type Value op Number 0: Reset module\n1: Reset after saving current parameters to Flash\n2: Reset after clearing current parameter from Flash Example:\n→AT+SYSRST=[1]\nWatchdog # This command set up watch dog.\nCommand: AT+SYSWDT=[wdt_enable,wdt_int_pol,wdt_tmo]\nResponse: +SYSWDT=err_code\nParameter Type Value wdt_enable Number 0: Disable\n1: Enable wdt_int_pol Number 0: Low level trigger interrupt\n1: High level trigger interrupt wdt_tmo Number 1 - 65536 seconds Example:\n→AT+SYSWDT=[1,0,60]\n←+SYSWDT=0000H\nEVENT REFERENCE # -EVTREADY # This event indicates module is ready to accept AT commands. It is usually received after power on reset or +SYSRST command is executed.\nEvent: -EVTREADY=[prev_state]\nParameter Type Value prev_state Number 0 Power on reset or reset command with op 0 1 Reset command with op 1 2 Reset command with op 2 3 Watch dog reset Example:\n-EVTREADY=[1]\n-EVTCONN # This event indicates device has been connected or disconnected.\nEvent: -EVTCONN=[state,peer_addr,role,phy]\nParameter Type Value state Number 0: Disconnect\n1: Connect peer_addr String Byte Array format string representing MAC address of peer device in little role Number 5: Device is connected as Master role;\n10: Device is connected as Slave role phy Number Phy that connection on. Please refer to PHY parameter in command +DEVCFG Example:\n//Successfully connected with remote Master device \u0026ldquo;EF:DD:CC:CC:BB:EF\u0026rdquo; on 1M PHY.\n-EVTCONN=[1,\u0026lsquo;EFBBCCCCDDEF\u0026rsquo;,1,1]\n-EVTDATA # This event indicates the data reception from peer device.\nEvent: -EVTDATA=[peer_addr,data]\nParameter Type Value peer_addr String Byte Array format string representing MAC address of peer device in little-endian mode data String Base64 encoding format string representing binary data received Example:\n//Data \u0026ldquo;0x0001020304050607080910\u0026rdquo; received from remove device \u0026ldquo;66-55-44-33-22-11”\n-EVTDATA=[\u0026ldquo;112233445566\u0026rdquo;,\u0026ldquo;AAECAwQFBgcICRA=\u0026rdquo;]\n-EVTADV # This event indicates that an advertising signal has been scanned.\nEvent: -EVTADV=[dev_addr,addr_type,connectable,rssi,payload]\nParameter Type Value dev_addr String Byte Array format string representing MAC address of advertising device in little-endian mode addr_type Number 0: Public\n1: Static random connectable Number 0: Unconnectable\n1: Connectable rssi Number Signed integer in dBm payload String Base64 encoding format string representing advertising payload binary data Example:\n//A connectable ad with local name \u0026lsquo;Inplay\u0026rsquo; as payload from device \u0026lsquo;66-55-44-33-22-11\u0026rsquo; is scanned. RSSI is -80dBm.\n-EVTADV=[\u0026ldquo;112233445566\u0026rdquo;,0,1,-80,\u0026ldquo;BwlJbnBsYXk=\u0026rdquo;]\n-EVTACTVEND # This event indicates the termination of the command +SCANACTV, +ADVACTV, +INITACTV and +BOND, whether the commands are terminated automatically or manually.\nEvent: -EVTACTVEND=[actv_type,actv_id]\nParameter Type Value actv_type Number 0 Advertising activity 1 Scan activity 2 Initiating activity 3 Bond actv_id Number Unique ID for activity Example:\n//Advertising activity 1 has ended\n-EVTACTVEND=[0,1]\n//Scan activity has ended\n-EVTACTVEND=[1,20]\nERROR CODE # The ERROR CODE is returned as a hexadecimal value. Please refer to following table for details.\n0000H Command executed successfully 1001H Wrong command execution 100AH Wrong CommandID 100BH Wrong format 100DH Wrong parameter 100EH Execution overtime Others BLE error. Refer to in_ble_error.h in SDK "},{"id":1,"href":"/docs/in6xxe/getting-started/hci_command.html","title":"HCI Command","section":"Getting Started","content":" HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.\nHCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters. Understanding this structure is essential for developers and engineers working on BLE devices, as it allows them to communicate effectively with the Bluetooth controller.\nHCI Command Format # The general format of a BLE HCI command packet is as follows:\n| HCI Type (1 byte) | Opcode (2 bytes) | Param Length | Params | |-------------------|------------------|--------------|--------| HCI Type: A one-byte identifier specifying the type of HCI command. It is 0x1 for HCI command packet. Opcode (Operation Code): A unique identifier (2 bytes) specifying the type of command. Parameter Length: A byte indicating the length of the parameters that follow. Parameters: Additional data or information associated with the command. HCI Event Format # Similarly, the format for an HCI event packet is structured as follows:\n| HCI Type (1 byte) | Event Code (1 byte) | Parameter Length | Data | |-------------------|---------------------|------------------|------| HCI Type: A one-byte identifier specifying the type of HCI event. It is 0x4 for HCI event packet. Event Code: A unique identifier (1 byte) specifying the type of event or response. It is 0xE for command complete event. Parameter Length: A byte indicating the length of the parameters or data that follow. Data: Additional information or payload associated with the event or response. Command Example: # Reset Command\nCommand: 0x01, 0x03, 0x0C, 0x00\n0x01 – HCI Type 0x03 0x0C – operation code 0x00 – the number of bytes of parameters. For reset, the number is zero because no parameter. Command Complete Event: 0x04, 0x0E, \u0026lt;Packet len \u0026gt;\u0026lt;Commands Available\u0026gt;, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\n0x04 – single byte before all events. 0x0E – event code after command completion \u0026lt;Packet Len\u0026gt; - Length of all of the parameters contained in this packet. It is 0x4 in this example. \u0026lt;Commands Available\u0026gt; – the number of commands that the controller can receive. It is 0x1 by default. 0x01 0x03 0x0C – operation code \u0026lt;status\u0026gt; – 0x00 means the command was successful. If not 0x00, it means an error. The error list reference is to Volume 2 Part D of the Core Spec for a list of error codes. Command Parameters # packet type: Packet type Payload 0x00 PRBS9 sequence ‘11111111100000111101…’ (in transmission order) 0x01 Repeated ‘11110000’ (in transmission order) 0x02 Repeated ‘10101010’ (in transmission order) 0x03 PRBS15 0x04 Repeated ‘11111111’ 0x05 Repeated ‘00000000’ 0x06 Repeated ‘00001111’ 0x07 Repeated ‘01010101’ Table 1\nphy: Phy Description 0x01 Transmitter set to use the LE 1M PHY 0x02 Transmitter set to use the LE 2M PHY 0x03 Transmitter set to use the LE Coded PHY with S=8 data coding 0x04 Transmitter set to use the LE Coded PHY with S=2 data coding Table 2\ntx power: Value TX Power 0x00 Max Power 0x01 7dBm 0x02 6.5dBm 0x03 6dBm 0x04 5.5dBm 0x05 5dBm 0x06 4.5dBm 0x07 4dBm 0x08 3.5dBm 0x09 3dBm 0x0A 2.5dBm 0x0B 2dBm 0x0C 1.5dBm 0x0D 1dBm 0x0E 0.5dBm 0x0F 0dBm 0x10 -1dBm 0x11 -2dBm 0x12 -3dBm 0x13 -4dBm 0x14 -5dBm 0x15 -6dBm 0x16 -8dBm 0x17 -12dBm 0x18 -16dBm 0x19 -20dBm 0x1A -43dBm Table 3\nHCI Test Command Description # Reset # The Reset command needs to be sent only once after power-up.\nCommand: 0x01, 0x03, 0x0C, 0x00\nComplete Event: 0x04, 0x0E,01, 0x01, 0x03, 0x0C, \u0026lt;status\u0026gt;\nEnd Test # After each modulation signal test command (TX or RX command) is completed, you need to send an \u0026ldquo;end test command.\u0026rdquo; The end test command is as simple as the reset command, but the return command is more complex. The commands returned by the serial port include 2 bytes, indicating the number of packets received by DUT at the end of the command. Reference to Volume 2 Part E Section 7.8.30.\nCommand: 0x01, 0x1F, 0x20, 0x00\nComplete Event：0x04, 0x0E, 01, 0x01, 0x1F, 0x20, \u0026lt;status\u0026gt;, \u0026lt;packets number byte 0\u0026gt;, \u0026lt;packets number byte 1\u0026gt;\nStart TX Test (Modulation signal) # The LE TX test command has 3 parameters, channel ,data length ,packet type. Reference to Volume 2 Part E Section 7.8.29.\nTransmitter Test command：0x01, 0x1E, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402G data length: please use 0x25 in 1M mode packet type: please refer to Table 1. Complete Event：0x04, 0x0E, 01, 0x01, 0x1E, 0x20, \u0026lt;status\u0026gt;\nStart RX Test (Receive mode) # The LE RX test command has 1 parameter, channel. Reference to Volume 2 Part E Section 7.8.28.\nReceive Test command：0x01, 0x1D, 0x20, 0x01, \u0026lt;channel\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x1D, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced TX Test # The LE Enhanced TX Test command has 3 parameters - the transmit channel. See Volume 2 Part E Section 7.8.501\nCommand: 0x01, 0x34, 0x20, 0x04, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;\nchannel: the range is 0x00 to 0x27 (39), the formula is: N = (F - 2402)/ 2; 0x00 represents 2.402G\ndata length: please use 0x25 in 1M mode\npacket type: please refer to Table 1\nphy: Please refer to Table 2\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x34, 0x20, \u0026lt;status\u0026gt;\nStart Enhanced RX Test # The LE Enhanced Receive Mode Test command has one parameter - Receive Channel, see Volume 2 Part E Section 7.8.50.\nCommand: 0x01, 0x33, 0x20, 0x03, \u0026lt;channel\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;modulation index\u0026gt;\nchannel: range 0x00 to 0x27 (39), formula: N = (F - 2402)/ 2; 0x00 represents 2.402G\nphy: please refer to Table 1\nmodulation index: Normally set to 0\n0x00 Assume transmitter will have a standard modulation index\n0x01 Assume transmitter will have a stable modulation index\nComplete Event: 0x04, 0x0E, 01, 0x01, 0x33, 0x20, \u0026lt;status\u0026gt;\nStop Carrier TX ( Carrier signal) # Command：0x01, 0x04, 0xFC, 0x00\nComplete Event:0x04, 0x0E,0x01, 0x01, 0x04, 0xFC, \u0026lt;status\u0026gt;\nThe following commands are vendor specified.\nStart Carrier TX (carrier signal) # Command：0x01, 0x01, 0xFC, 0x02, \u0026lt;channel\u0026gt; \u0026lt;TX gain\u0026gt;\nchannel: the range is 0x00 to 0x27（39），Formula：N =（F – 2402）/ 2； 0x00 means 2.402GHz TX gain: 0: use default value. 0x1 ~ 0x7F: PA gain, 0x19 is 0dBm. Complete Event：0x04, 0x0E, 0x01, 0x01, 0x01, 0xFC, \u0026lt;status\u0026gt;\nGet RSSI # Command：0x01, 0x03, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 01, 0x01, 0x03, 0xFC, \u0026lt;status\u0026gt; ，\u0026lt;RSSI\u0026gt;\nRSSI: value of RSSI, it is a int8_t value. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm Vendor TX command # Command：0x01, 0x0D, 0xFC, 0x06, \u0026lt;channel\u0026gt;, \u0026lt;data length\u0026gt;, \u0026lt;packet type\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;midx\u0026gt;, \u0026lt;continue tx\u0026gt;\nchannel: See “Start Enhanced TX Test”\ndata length: See “Start Enhanced TX Test”\npacket type: Refer to Table 1\nphy: Refer to Table 2\nmidx: Reserved, must set to 0.\ncont tx:\n1: Continuous TX\n0: Normal TX\nComplete Event:0x04, 0x0E, 0x01, 0x01, 0x0D, 0xFC, \u0026lt;status\u0026gt;\nSet Cap # Command: 0x01, 0x05, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x05, 0xFC, \u0026lt;status\u0026gt;\nSave Cap to Efuse # Command: 0x01, 0x06, 0xFC, 0x01 \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x06, 0xFC, \u0026lt;status\u0026gt;\nNotice:\nThis command burn cap data to Efuse memory. Must supply 3.3V power on VDDQ pin.\nEfuse is OTP(One Time Programmable) memory. Make sure bure correct value in Efuse.\nSave Cap to Flash # Command: 0x01, 0x08, 0xFC, 0x01, \u0026lt;Cap\u0026gt;\ncap: capacitance range is 0x0~0xF\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x08, 0xFC, \u0026lt;status\u0026gt;\nSet TX Power # Set the transmit power according to Table 3.\nCommands: 0x01, 0x07, 0xFC, 0x01, \u0026lt;TX Power\u0026gt;\nTX Power: transmit power, range is 0x00 to 0x1A. Please refer to Table 3. Complete Event: 0x04, 0x0E, 01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nSet TX Gain # Command: 0x01, 0x51, 0xFC, 0x00, \u0026lt;TX Gain\u0026gt;\nTX Gain: TX gain, range is 0x00 ~ 0x7F. Default is 0x18. Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x51, 0xFC, \u0026lt;status\u0026gt;\nRead Register # Read register. Command: 0x01, 0x0E, 0xFC, 0x04, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt; ,\u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nReg Value Byte 0: Register value byte 0. Reg Value Byte 1: Register value byte 1. Reg Value Byte 2: Register value byte 2. Reg Value Byte 3: Register value byte 3. Write Register # Write register.\nCommand: 0x01, 0x0F, 0xFC, 0x08, \u0026lt;Address Byte0\u0026gt;,\u0026lt;Address Byte1\u0026gt;,\u0026lt;Address Byte2\u0026gt;，\u0026lt;Address Byte3\u0026gt;, \u0026lt;Reg Value Byte 0\u0026gt;, \u0026lt;Reg Value Byte 1\u0026gt;,\u0026lt;Reg Value Byte 2\u0026gt;，\u0026lt;Reg Value Byte 3\u0026gt;\nAddress Byte0: Register address byte 0.\nAddress Byte1: Register address byte 1.\nAddress Byte2: Register address byte 2.\nAddress Byte3: Register address byte 3.\nReg Value Byte 0: Register value byte 0.\nReg Value Byte 1: Register value byte 1.\nReg Value Byte 2: Register value byte 2.\nReg Value Byte 3: Register value byte 3.\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x07, 0xFC, \u0026lt;status\u0026gt;\nStart PWM # Command: 0x01, 0x09, 0xFC, 0x01, \u0026lt;pwm id\u0026gt;\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x09, 0xFC, \u0026lt;status\u0026gt;\nStop PWM # Command: 0x01, 0x0A, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x0A, 0xFC, \u0026lt;status\u0026gt;\nGet Version Number # Command: 0x01, 0x50, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x50, 0xFC, \u0026lt;status\u0026gt; , \u0026lt;version byte 0\u0026gt;, \u0026lt;version byte 1\u0026gt;, \u0026lt;version byte 2\u0026gt;, \u0026lt;version byte 3\u0026gt;\nVersion: 32bit HCI command SW version number The following command in only available for Golden tester board.\nDUT Calibrate XO # Command: 0x01, 0x31, 0xFC, 0x03, \u0026lt;pwm id\u0026gt;, \u0026lt;save\u0026gt;, \u0026lt;limit\u0026gt;\nCalibrate XO with PWM signal.\npwm id:\nPWM0 0\nPWM1 1\nPWM2 2\nPWM3 3\nPWM4 4\nsave:\n0: don’t save cap value.\n1: save cap value on flash.\nlimit: Max offset between DUT and tester. Unit is 1/8 us at 100ms(1.25PPM).\nFor example, limit is 16, means that offset is ±2us at every 100ms(20 PPM).\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x31, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;cap\u0026gt;,\u0026lt;offset\u0026gt;\ncap: cap value\noffset: Offset between DUT and tester , Unit is 1/8 us at 100ms(1.25PPM).\nDUT Set TX Power # Command: 0x01, 0x32, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;tx gain code\u0026gt;\nch: 0 ~ 39 phy: Please refer to Table 2 tx gain: DUT tx gain code(0x0 ~ 0x7F), only available for carrier. Complete Event: 0x04, 0x0E, 0x01, 0x01, 0x32, 0xFC, \u0026lt;status\u0026gt;,\u0026lt;rssi\u0026gt;\nrssi: RSSI value DUT RX Sensitivity # Command: 0x01, 0x33, 0xFC, 0x03, \u0026lt;ch\u0026gt;, \u0026lt;phy\u0026gt;, \u0026lt;loss rate\u0026gt;\nch: 0 ~ 39\nphy: Please refer to Table 2\nloss rate: 0~255, unit is 0.1%. For example ,20 means 2%\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x33, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;tx power\u0026gt;, \u0026lt;loss rate\u0026gt;\ntx power: Tester TX power\nloss rate: loss rate, unit is 0.1%. 20 means 2%.\nDUT Download Image # Command: 0x01, 0x34, 0xFC, 0x08, \u0026lt;bootram size byte 0\u0026gt;, \u0026lt;bootram size byte 1\u0026gt;, \u0026lt;bootram size byte 2\u0026gt;, \u0026lt;bootram size byte 3\u0026gt;, \u0026lt;image size byte 0\u0026gt;, \u0026lt;image size byte 1\u0026gt;, \u0026lt;image size byte 2\u0026gt;, \u0026lt;image size byte 3\u0026gt;\nbootram size: bootram size. Default is 0x2000. image size: application image size. Example: bootram size is 0x2000 bytes, image size is 0xAC00 bytes:\n01 34 fc 08 00 20 00 00 00 ac 00 00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x34, 0xFC, \u0026lt;status\u0026gt;\nStart BLE Scan # Command: 0x01, 0x40, 0xFC, 0x07, \u0026lt;channel\u0026gt;, \u0026lt;BD addr byte 0\u0026gt;, \u0026lt; BD addr byte 1\u0026gt;, \u0026lt; BD addr byte 2\u0026gt;, \u0026lt; BD addr byte 3 \u0026gt;, \u0026lt; BD addr byte 4\u0026gt;, \u0026lt; BD addr byte 5 \u0026gt;\nchannel: Scan channel. 37, 38 or 39\nBD addr: BLE device address, 6 bytes\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x40, 0xFC, \u0026lt;status\u0026gt;\nStart SDR Scan # Command: 0x01, 0x41, 0xFC, 0x05, \u0026lt;channel\u0026gt;, \u0026lt;access addr byte 0\u0026gt;, \u0026lt;access addr byte 1\u0026gt;, \u0026lt;access addr byte 2\u0026gt;, \u0026lt;access addr byte 3 \u0026gt;\nchannel:Scan channel. Range is 0 ~ 39.\naddcess addr: SDR access address, 4 bytes\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;\nStop Scan # Command: 0x01, 0x42, 0xFC, 0x00\nComplete Event: 0x04, 0x0E, 0x01, 0x01, 0x41, 0xFC, \u0026lt;status\u0026gt;, \u0026lt;RSSI\u0026gt;,\u0026lt;freq_offset_code byte 0 \u0026gt;, \u0026lt; freq_offset_code byte 1 \u0026gt;, \u0026lt;receive packet number byte 0\u0026gt;, \u0026lt;receive packet number byte 1\u0026gt;\nRSSI: value of RSSI, int8_t. Example: return value is 0xCD, RSSI=0xCD-0x100=-51dBm\nfreq_offset_code: frequency offset code. It is int16_t value. Use this to covert to KHz:\nOffset(KHz) = 500.0/1024* freq_offset_code\n"},{"id":2,"href":"/docs/in6xxe/getting-started/introduction-to-in6xxe-dk.html","title":"Introduction to IN6XXE DK","section":"Getting Started","content":" Overview # IN6XXE DK is a development board for IN6XXE series chips. The schematics can be downloaded here.\nHardware description # Component Description 1 RF Switch 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.8V Power 5V to 1.8V 10 ADC port 11 Cortex_debug Debug port 12 Power ON Power switch of the 5V supply from USB 13 Jlink+UART0 JLINK and UART0, UART0 Tx is GPIO_0_2, Rx is GPIO_1_0 14 1.2V Test point 15 LEDs LEDs connected to GPIO,on when GPIO drives HIGH. LED1:GPIO_2_8, LED2:GPIO_3_2, LED3:GPIO_3_3 16 GPIO Test Pin GPIO pins 17 GPIO Test Hole GPIO pins 18 GPIO Button+Reset One reset button, other buttons are LOW active(when pressed, GPIO input LOW) 19 Power Level Shift Convert UART interface voltage level between IN6XXE and USB to UART chip 20 UART1 flow control Control power supply of USB to UART chip; Control voltage level converter; Control which GPIOs are connected to the USB to UART chip, default is UART1: GPIO_2_1:TX GPIO_2_7:RX GPIO_1_5:RTS GPIO_1_6:CTS see UART Configuration 21 UART to USB 22 3.3V Power 5V to 3.3V 23 Type-C Power supply and connect to PC for UART port 24 External VBAT External supply to VBAT 25 External VDDIO External supply to VDDIO These components will be refered as \u0026ldquo;Component_xx\u0026rdquo;(xx is the component number) in this page.\nPower Supply # When the board is connected with USB and the switch is turned on, 5V, 3.3V and 1.8V power source will be valid, and 3 LEDs will indication the status:\nLED4: 5V LED5: 3.3V LED6: 1.8V However, how these power sources will supply IN6XXE chip is configured with Power Jumper(Component_7):\nCHIP_EN can always be connected to VBAT to reset the chip when powered on. VDDIO and VBAT are connected directly to the chip. VDDIO is power supply of IN6XXE\u0026rsquo;s IO, and the voltage level can be different with VBAT. These are confguration examples:\nConnections Description CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;3.3V,VBAT\u0026lt;-\u0026gt;3.3V Both VDDIO and VBAT are 3.3V, supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;1.8V,VBAT\u0026lt;-\u0026gt;3.3V VDDIO is 1.8V, VBAT is 3.3V, both supplied with USB CHIP_EN\u0026lt;-\u0026gt;VBAT,VDDIO\u0026lt;-\u0026gt;VBAT VBAT and VDDIO are powered by external power source, can be used when measuring power consumption of the chip Debug Port # There are three connectors(component 8, 11, 13) can be used as debug port, usually connected to J-Link.\nUART configuration # IN6XXE has two UART ports, UART0 and UART1. You can connect external USB to UART module to Component_13 if you use UART0.\nYou can also use the on board USB to UART chip, configured with Component_20:\nIf you want to use on board USB to UART chip, 1\u0026lt;-\u0026gt;2, 3\u0026lt;-\u0026gt;4 should be connected.\nIf you want to use UART1(GPIO_2_1 as Tx, and GPIO_2_7 as Rx):\n9\u0026lt;-\u0026gt;10, 11\u0026lt;-\u0026gt;12 should be connected for UART Rx and Tx.\n5\u0026lt;-\u0026gt;6, 7\u0026lt;-\u0026gt;8 should be connected for flow control.\nYou can connect 5,7,9,11 to other GPIOs if you use other GPIOs as UART port pins.\nCurrent measurement # If you want to measure current of IN6XXE, all pins of Component_13 should be disconnected.\nFor the Power Jumper, CHIP_EN\u0026lt;-\u0026gt;VBAT and VDDIO\u0026lt;-\u0026gt;VBAT should be connected.\nThen you can connect external power source to VBAT(Component_24) and GND(Component_6) to supply power to IN6XXE and measure the current.\n"},{"id":3,"href":"/docs/in6xxe/getting-started/jflash-download-guide.html","title":"JFlash Programming","section":"Getting Started","content":" JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.\nJ-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.\nPrerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended). Install InPlayTools: # InPlayTools is an extension designed to enhance J-Flash functionality by adding support for the IN6XXE series of chips.\nThe installation file for Inplaytools is in \u0026ldquo;SDK\\in-dev\\tools\\InPlayToolsSetup.exe\u0026rdquo;\nUser should select the Jlink version. Recommended install Jlink Version 7.62 or later first.\nStep: # Open JFlash, and select “create a new project.” Select the target device Select InPlay IN6XXE device Open the Bin file\nClick the file menu, select “Open data file”, and select the Bin file to be downloaded. Set start address Set start address to 0x300000. Connect to device Download bin file Note:\nMake sure that the chip is in boot mode before downloading.\nFor entering boot mode, please press boot pin then reset chip.\n"},{"id":4,"href":"/docs/in6xxe/quick-start.html","title":"Quick Start","section":"IN6XXE","content":" Quick Start Guide # Introduction # This document provides a guide as following:\nInstall development tools Use the configuration tool Build \u0026ldquo;proj_ble_adv_conn\u0026rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).\nDownload and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).\nInstall \u0026ldquo;InPlayInc.DeviceFamilyPack\u0026rdquo;. Double click the InPlayInc.DeviceFamilyPack installation package under the directory of \u0026ldquo;in-dev\\tools\u0026rdquo;.\nGenerate configuration File (optional) # Demo projects are in \u0026ldquo;SDK/in-dev/proj\u0026rdquo;. Each project has a configuration file named \u0026ldquo;in_config.h\u0026rdquo;. This file is located in the \u0026ldquo;inc\u0026rdquo; directory of the project. This file is genareted by \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. If you want to modify the default configuration file, use this tool that is located in \u0026ldquo;in-dev/tools/in_config\u0026rdquo;.\nRun \u0026ldquo;InPlay SwiftConfig Tool\u0026rdquo;. Click \u0026ldquo;Open\u0026rdquo; button, open the configuration file in \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo;. Modify project configuration. Click \u0026ldquo;Save\u0026rdquo; button, save the configuration file to \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/inc/in_config.h\u0026rdquo; Build the Project # Open the Keil project, double click file \u0026ldquo;in-dev/proj/ble/proj_ble_adv_conn/build/mdk/proj_ble_test.uvmpw\u0026rdquo;. \u0026ldquo;*.uvprojx\u0026rdquo; is Keil single project file, and \u0026ldquo;*.uvmpw\u0026rdquo; is Keil multi project file. Here we use multi project file. Noted: If you encounter errors indicating that project files such as \u0026ldquo;hw_ana\u0026rdquo; and \u0026ldquo;ble_flash\u0026rdquo; cannot be found, please ignore them. These projects are library project. And SDK inlcudes prebuild library files.\nClick \u0026ldquo;Batch Build\u0026rdquo; button. Select all projects and click \u0026ldquo;Rebuild.\u0026rdquo; Download to DK board # Connect JLink debugger to DK board. And power up DK board.\nClick \u0026ldquo;Project\u0026rdquo; menu in Keil, and select \u0026ldquo;Options for target\u0026rdquo;(or use shortcut key Alt+F7).\nClick \u0026ldquo;Device\u0026rdquo; tab, and select \u0026ldquo;IN6XXE\u0026rdquo; device under \u0026ldquo;InPlay Inc\u0026rdquo;. Click \u0026ldquo;Debug\u0026rdquo; tab, and select \u0026ldquo;J-Link\u0026rdquo; from the drop-down menu, as shown below: If a devices selection window pops up, select the \u0026ldquo;unspecified Cortex M4\u0026rdquo;.\nThen click \u0026ldquo;Settings\u0026rdquo; tab, select \u0026ldquo;SW\u0026rdquo; (single-wire interface) from the drop-down menu of \u0026ldquo;Port.\u0026rdquo; The click \u0026ldquo;OK\u0026rdquo; to apply changes.\nNote:\nIf the J-Link is connected to the DK board and DK board is powered up, KEIL should detect DK board and display its information in the \u0026ldquo;SW Device\u0026rdquo; column, as illustrated below. If Keil can\u0026rsquo;t find device, reset DK and click \u0026ldquo;Scan\u0026rdquo; to rescan device.\nIn the \u0026ldquo;Utilities\u0026rdquo; tab, click \u0026ldquo;Settings\u0026rdquo;. If the Keil Pack is installed, configuration will be done automatically as follows. If Keil is not configured properly, please manually add the \u0026ldquo;IN6XX SPI FLASH \u0026ldquo;flm file, set start addres and size.\nClick \u0026ldquo;OK\u0026rdquo; to apply changes.\nClick \u0026ldquo;download\u0026rdquo; button to download image file to DK board. "},{"id":5,"href":"/docs/in6xxe/development-guide/run-zephyr-on-in6xxe.html","title":"Run Zephyr on IN6XXE","section":"Development Guide","content":" Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.\nInplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.\nSetup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows. You can follow Zephyr Getting Started Guide to setup a Zephyr development environment under Windows, it can be divided into following steps:\n1.Install host dependencies, including cmake, Python, devicetree compiler, etc.\nThese are necessary host tools needed to build Zephyr.\n2.Install west and Python dependencies\nBecause IN6XXE support is not merged into the official Zephyr project repository now, you should init west using below command:\nwest init -m https://github.com/InPlay-Inc/zephyr zephyrproject To support IN6XXE, an external module named \u0026ldquo;hal_inplay\u0026rdquo; is added, when you run west update, it will be cloned to your zephyr working directory automatically.\n3.Install Zephyr SDK\nYou only need to install arm-zephyr-eabi cross tool to support IN6XXE.\nBuild the application # Board name of IN6XXE is \u0026lsquo;inplaydk_in612le\u0026rsquo;, you can start with a simple \u0026ldquo;blinky\u0026rdquo; sample:\ncd zephyrproject/zephyr\rwest build -p always -b inplaydk_in612le samples/basic/blinky Flash binary output # You should first refer to JFlash Download Guide to install InplayTools. After that, you can use Jlink to burn the binary output to the on-chip flash with command west flash.\nRun the sample # For the DK board, UART1 is configured as console in the source code, and the baud rate is 115200. There is an USB to UART chip(CH340) integrated on the board which is connected to UART1(GPIO21 as Tx, and GPIO27 as Rx), so you only need to connect the board to PC with USB Type-C cable to see logs or use shell. CH340 drivers should be installed first, you can download it from here. If the sample runs normally, you can see logs output to a serial terminal software like \u0026ldquo;putty\u0026rdquo;.\nSupported drivers # Only these drivers are supported now:\nGPIO pinctrl(partially implemented) UART(support tx and rx with interrupt, so you can use Zephyr shell) BLE hci driver "},{"id":6,"href":"/docs/in6xxe/getting-started/inplay-smull-development-guide.html","title":"SMULL Command Set","section":"Getting Started","content":" Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps. The PHY can also be configured to 1Mbps mode to transmits and receives 1Mbps modulated packets.\nThe baseband controller combines both hardware and software implementation that supports variety of communication modes between master and slave devices: Unicast, multi-cast and broadcast modes. In a typical start topology network, as shown in Figure 1, the central node will operate as the master and the peripheral nodes will operate as the slave nodes. The communication between the master and the slaves can be unidirectional or bi-directional.\nThe baseband controller can be configured as either master or slave operation mode. The communication between the master and the slaves is framed based communication as shown in Figure 2. On each frame, the master sends a broadcast packet, or a public packet, or a downlink private packet (DPP) to each of the slaves. As illustrated in Figure 2, assume there are N slaves,and each slave has a unique ID number from {0, 1, 2, …, N-1}. Each salve can send an uplink private (UP) packet at the assigned time (t0, t1, …,) in the frame to the master. The packets sent from the master share the same preamble and sync address. Each packet from the slave has its own preamble and sync address. And all the timing critical functions in the baseband controller are implemented in hardware such as CRC, data whitening and access address detection. The data exchange can be configured to operate in three different modes between a master and multiple salves.\nPrivate data exchange mode The master can be configured to send each slave a private packet at each frame. Each slave can be configured to send the master a private packet at each frame. Private packet: There is acknowledgement between the sender and the recipient.\nPublic data exchange mode The master can be configured to send a public packet to all the slaves at each frame.\nPublic packet: Slaves do the acknowledgement. The master does not proceed to next public packet unless the current public packet is acknowledged by all the slaves.\nBroadcasting mode The master can be configured to send a broadcast packet to all the slaves at each frame.\nBroadcast packet: Slaves do not acknowledge the reception of a broadcast packet.\nOverview of transparent data transmission # Many modern applications rely on wireless data transmission; however, end-users often lack knowledge or interest in the underlying wireless technologies. Consequently, we have designed a mechanism that allows users to conveniently utilize the powerful data transfer capabilities provided by SMULL without the need to understand the details of this protocol. However, before starting the data transmission, it is necessary to configure the relevant parameters of SMULL to establish a network between the master and slave. By using the commands we provide, you can quickly establish the SMULL network. Please refer to the example provided below for more details. The schematic of the entire system, showing the connection between the host and IN618 module, is illustrated in Figure 3.\nTypically, the host refers to various devices such as personal computers (PCs), laptops, microcontroller units (MCUs), and others. In the current architecture, the host and IN618 communicate through UART. The default settings for the UART in our system are illustrated below.\nUART default settings # 115,200 bps 8 bits No Parity 1 Stop bit Hardware flow control disabled The uart configuration command can be used to modify the UART settings.\nCommand Set # In order to facilitate software development with SMULL, we have designed a set of commands for programming. Users can effortlessly start the system by utilizing these commands.The command format is shown as following. Command Code Data Length Data 2 bytes 2 bytes variable bytes Get Slave Number: 0xA011 # This command gets the number of slaves in current network.\nSend: 0xA0 0x11 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x11 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x11 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Set Slave Number: 0xA012 # This command is used to configure the number of slaves.The slave number should be less than (or equal to) the maximum slave number (CFG_IPMAC_MAX_SLV_NUM).\nSend: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Number of slaves Response: 0xA0 0x12 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x12 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: the command sent is too short\nB0=0x02: number of slave is larger than the maximum value Notice:\nAfter successfully setting the slave number on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the slave number on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Slave ID: 0xA013 # This command gets the slave ID.\nSend: 0xA0 0x13 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x13 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x13 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Set Slave ID: 0xA014 # This command sets the slave ID on the slave side. Sending this command to the master will not receive any response. Each slave in a network must have a unique ID.\nSend: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 Slave ID Response: 0xA0 0x14 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x14 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Slave ID is larger than or equal to the slave number which you set. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the slave ID will not be updated.\nGet SYNC Address (Network Address): 0xA015 # This command gets the SYNC address. Each established network should have a unique SYNC address (also known as network address).\nSend: 0xA0 0x15 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x15 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) SYNC Address = (B0 \u0026laquo; 24) | (B1 \u0026laquo; 16) | (B2 \u0026laquo; 8) | B3\nSet SYNC Address (Network Address): 0xA016 # This command can be used to set the SYNC address. The value 0x00000000 will be ignored and the address will not be updated. The value 0xFFFFFFFF also cannot be accepted.\nSend: 0xA0 0x16 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 SYNC Address (MSB) B1 SYNC Address B2 SYNC Address B3 SYNC Address (LSB) Response: 0xA0 0x16 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x16 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: SYNC address is invalid. Notice:\nFor optimal performance, it is advisable to ensure that the SYNC address bit sequence does not contain four consecutive ones or zeros. Generally speaking, it is better to use a random value. For example,\n0x2954935B is a good value. There are no 4 consecutive ones or zeros in its bit sequence.\n0x10F10724 is not a good value. There are 4 consecutive ones or zeros in its bit sequence.\nAfter successfully setting the SYNC address on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the SYNC address on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet PHY Rate: 0xA017 # This command gets the PHY rate. The supported PHY rates are 1Mbps and 2Mbps.\nSend: 0xA0 0x17 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x15 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x17 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Set PHY Rate: 0xA018 # This command can be used to set the PHY rate.\nSend: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x01: 1Mbps\nB0=0x02: 2Mbps Response: 0xA0 0x18 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x18 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: PHY Rate is invalid. Notice:\nAfter successfully setting the PHY rate on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①\tIf the network has been established, you may want to broadcast the new settings to all slaves. Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②\tIf the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the PHY rate on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Mode: 0xA019 # This command gets the current mode.\nSend: 0xA0 0x19 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x19 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x19 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x17 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: slave\nB0=0x01: master Set Mode: 0xA01A # This command is used to set the mode (master or slave) on the device. Each device will be configured as a master or a slave. In a network, only one device can be configured as a master.\nSend: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) B0 B0 should be 0 (slave) or 1 (master), other values are considered as invalid. Response: 0xA0 0x1A 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1A Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Mode is invalid. Notice:\nAfter successful configuration, you must reset the chip by issuing the command 0xA0E1, otherwise, the mode will not be updated.\nGet Maximum Length of Downlink Private Packet: 0xA01B # This command gets the maximum length of downlink private packet. Here, the downlink means the data are transmitted from master to slave.\nSend: 0xA0 0x1B 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1B 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1B Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Length = (B0 \u0026laquo; 8) | B1\nSet Maximum Length of Downlink Private Packet: 0xA01C # The default length of downlink private packet is 6 bytes. Ensure that the value you set is equal to or greater than 6.\nSend: 0xA0 0x1C 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of downlink private packet (MSB) B1 maximum length of downlink private packet (LSB) Response: 0xA0 0x1C 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1C Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00, success; B0=0x01, The command sent is too short; B0=0x02, Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of downlink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of downlink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Maximum Length of Uplink Private Packet: 0xA01D # the maximum length of uplink private packet. Here, the uplink means the data are transmitted from slave to master.\nSend: 0xA0 0x1D 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x1D 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1D Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of uplink private packet (MSB) B1 maximum length of uplink private packet (LSB) Set Maximum Length of Uplink Private Packet: 0xA01E # Send: 0xA0 0x1E 0x00 0x02 B0 B1\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x02 Data Length (LSB) B0 maximum length of uplink private packet (MSB) B1 maximum length of uplink private packet (LSB) Response: 0xA0 0x1E 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x1E Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: success\nB0=0x01: The command sent is too short\nB0=0x02: Length is larger than the limitation (200 bytes). Notice:\nAfter successfully setting the maximum length of uplink private packet on the master side, the corresponding next steps should be taken based on whether the network has already been established.\n①If the network has been established, you may want to broadcast the new settings to all slaves.Thus, you should issue the command 0xA040 to request the master broadcast new settings. After the completion of the broadcast, you will receive a response. Once you have successfully received the response, it is necessary to reset the chip by issuing the command 0xA0E1.\n②If the network has not yet been established, broadcasting the new settings is unnecessary. So, you can reset the chip by issuing the command 0xA0E1.\nAfter successfully setting the maximum length of uplink private packet on the slave side, the chip needs to be reset immediately by issuing the command 0xA0E1.\nGet Period of Heartbeat Packet: 0xA033 # In order to track the connection status of the network, heartbeat packet is periodically sent between the master and slave(s). Users can get the period of the heartbeat packet by issuing this command. The default value is 1000ms.\nSend: 0xA0 0x33 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x33 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x33 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) Set Period of Heartbeat Packet: 0xA034 # Users can change the period of the heartbeat packet by issuing this command.\nSend: 0xA0 0x34 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Period (MSB) B1 Period B2 Period B3 Period (LSB) If the period is zero, the default value (1000ms) will be used.\nResponse: 0xA0 0x34 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x34 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00:success\nB0=0x01:command sent is too short Notice:\nThe minimum heartbeat period is 500ms. Thus, the period you set should be larger than or equal to 500ms. If the period is less than 500ms, it will be automatically set to 500ms.\nBroadcast SMULL Settings: 0xA040 # With this command, the master can broadcast the SMULL settings. Once the network has been established, the master can use this command to broadcast the new SMULL-related parameters to all the slaves. The slave will update its settings and reset automatically upon receiving new settings broadcasted by the master.\nSend: 0xA0 0x40 0x00 0x04 B0 B1 B2 B3\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Broadcast Duration (MSB) B1 Broadcast Duration B2 Broadcast Duration B3 Broadcast Duration (LSB) The broadcast duration indicates the intended time period for the master to transmit new settings, measured in milliseconds. If this value is set to zero, the default value of 3000ms is utilized. To ensure successful reception by each slave, it is recommended to set this value to a minimum of 3000ms.\nResponse: 0xA0 0x40 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x40 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: The command sent is short\nB0=0x02: In slave mode, this command will be ignored Get SMULL status: 0xA041 # This command gets the current status of SMULL.\nSend: 0xA0 0x41 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x41 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x41 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: it means the SMULL is successfully initialized\nB0=0xFF: it means the SMULL is not initialized. Notice:\nIf the initialization of SMULL fails, any SMULL related command that is issued will result in receiving the following response containing an error code 0xFF.\nCommand Code 0x00 0x01 0xFF\nRead SMULL settings: 0xA042 # The SMULL settings consist of 7 parameters: mode, slave number, slave ID, PHY rate, SYNC address, maximum length of downlink private packet and maximum length of uplink private packet. You can get all settings by issuing this command.\nSend: 0xA0 0x42 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) The length of data in successful response differs from that in failure response.\nSuccessful response: 0xA0 0x42 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that is used in your application. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Failure response: 0xA0 0x42 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Write SMULL settings: 0xA043 # As aforementioned, the SMULL settings include 7 parameters. You can set these parameters all at once by issuing this command.\nSend: 0xA0 0x43 0x00 0x0C B0~B11\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x0C Data Length (LSB) B0 Mode\n0x00: slave\n0x01: master B1 Slave Number. The maximum number of slaves that may be used in your application. This number must be less than or equal to the value of CFG_IPMAC_MAX_SLV_NUM. As of the current firmware, CFG_IPMAC_MAX_SLV_NUM is set at 64. B2 Slave ID. 0~ (slave number – 1). Master will ignore this value. B3 PHY Rate. 1: 1Mbps, 2: 2Mbps. Other values will be considered as invalid. B4 SYNC Address (MSB) B5 SYNC Address B6 SYNC Address B7 SYNC Address (LSB) B8 Maximum Length of Downlink Private Packet (MSB) B9 Maximum Length of Downlink Private Packet (LSB) B10 Maximum Length of Uplink Private Packet (MSB) B11 Maximum Length of Uplink Private Packet (LSB) Response: 0xA0 0x43 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x43 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: A general error\nB0=0x02: Command length is short\nB0=0x03: Invalid SMULL mode\nB0=0x04: Invalid slave number\nB0=0x05: Invalid slave Id\nB0=0x06: Invalid PHY Rate\nB0=0x07: Invalid SYNC address\nB0=0x08: Invalid downlink packet size\nB0=0x09: Invalid uplink packet size Query Connection Status of Each Slave: 0xA044 # The user can get the connection status of each slave by issuing this command on the master side.\nSend: 0xA0 0x44 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x42 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x44 0x00 0x10 B0~B15\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x10 Data Length (LSB) B0 The connection status of slave0 ~ slave7 \u0026hellip; \u0026hellip; B15 The connection status of slave120 ~ slave127 The byte sequence of data B0~B15 is a bit-map, each bit is associated with a slave. B0 is associated with slave0 to slave7, while B1 is associated with slave8 to slave15, and so on. A value of one for the bit indicates that the corresponding slave is connected to the master. Below, we provide two examples to show what a response might look like.\nExample1: Assuming that the maximum number of slaves is set to four and that all four slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0x0F 0x00\u0026hellip;0x00. However, in the case where only slaves 0 and 3 are connected, the response would be 0xA0 0x44 0x00 0x10 0x09 0x00\u0026hellip;0x00.\nExample2: Assuming that the maximum number of slaves is set to nine and that all nine slaves are connected to the master, the response would be 0xA0 0x44 0x00 0x10 0xFF 0x01 0x00…0x00. However, in the case where only slaves 0, 1, 6, 7 and 9 are connected, the response would be 0xA0 0x44 0x00 0x10 0xB3 0x01 0x00..0x00.\nIf this command is executed on the slave side, the response would be 0xA0 0x44 0x00 0x01 0x01.\nTransmit Data: 0xA048 # This command is used for data transmission between the master and slave once the network is successfully established. The master can transmit three types of packet. However, the slave can only trasmit private packets. Below, we will provide a detailed explanation on how to use this command for both the master and the slave.\n①Slave transmits data. The slave can only transmit private packets, so the command sequence is relatively simple.\nSend: 0xA0 0x48 D0 D1 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x44 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long ②Master transmits data. The master can transmit three types of packets to the slave: private, public and broadcast. In current firmware, we only support private packet.\nSend: 0xA0 0x48 D0 D1 T0 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) T0 Packet type\n0x00: broadcast\n0x01: public\n0x02: private S0 Slave ID. If sending a private packet, it is necessary to specify which slave it is sent to. B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Response: 0xA0 0x48 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x48 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail\nB0=0x02: The length of transmitted data is too long\nB0=0x03: Invalid slave ID Receive Data: 0xA049 # When the master receives data from the slave(s) or vice versa, the received data will be transmitted to the user in the following format.\n0xA0 0x49 D0 D1 S0 B0~Bn\nByte Comment 0xA0 Command Code (MSB) 0x49 Command Code (LSB) D0 Data Length (MSB) D1 Data Length (LSB) S0 If data is received by the master, S0 denotes the slave ID.\nIf data is received by the slave, S0 denotes the packet type (0 = broadcast, 1 = public, 2 = private). B0 first byte of data \u0026hellip; \u0026hellip; Bn last byte of data Read UART Configuration: 0xA063 # This command read the UART configuration.\nSend: 0xA0 0x63 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Successful Response: 0xA0 0x63 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control Response with errors: 0xA0 0x63 0x00 0x01 0x01\nByte Comment 0xA0 Command Code (MSB) 0x63 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) 0x01 Fail Configure UART: 0xA064 # This command writes the UART configuration.\nSend: 0xA0 0x64 0x00 0x08 B0~B7\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x08 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) B4 Data Bits B5 Stop Bits B6 Parity, 0-no parity, 1-odd parity, 2-even parity B7 Flow Control The maximum supported baud rate is 2000000.\nResponse: 0xA0 0x64 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x64 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Get UART Baudrate: 0xA065 # Send: 0xA0 0x65 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0x65 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x65 Command Code (LSB) 0x00 Data Length (MSB) 0x04 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Set UART Baudrate: 0xA066 # Send: 0xA0 0x66 0x00 0x04 B0~B3\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) B0 Baud rate (MSB) B1 Baud rate B2 Baud rate B3 Baud rate (LSB) Response: 0xA0 0x66 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0x66 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Chip Reset: 0xA0E1 # Typically, when the SMULL parameters are updated, it is recommended to reset the chip by issuing this command.\nSend: 0xA0 0xE1 0x00 0x00\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x00 Data Length (LSB) Response: 0xA0 0xE1 0x00 0x01 B0\nByte Comment 0xA0 Command Code (MSB) 0xE1 Command Code (LSB) 0x00 Data Length (MSB) 0x01 Data Length (LSB) B0 B0=0x00: Success\nB0=0x01: Fail Example # Before the data transmission begins, it is essential to establish a network connection (also known as paring). In order to ensure successful network communication, the SMULL settings for both the master and each slave must be identical, with the exception of the mode and slave ID. Configuring the SMULL settings using UART can facilitate this consistency between the master and all slaves. To illustrate the process of setting up a network, we will provide an example. Each parameter for the network is presented below.\nMode: (master: 0x01, slave: 0x00) Slave number: 4 Slave Id: (0x00 ~ 0x03), master will ignore this value Phyrate: 2M Address: 0x2954935B Maximum length of downlink packet: 10bytes Maximum length of uplink packet: 100bytes Two methods can be used to achieve the configuration. Method 1 requires the use of command 0xA043,whereas method 2 entails a combination of commands 0xA01A, 0xA012, 0xA014, 0xA018, 0xA016, 0xA01C, 0xA01E. Once the configuration is completed successfully, it is necessary to execute the reset command.\nMethod1:\nThe command sequence issued by the master would be\n①0xA0 0x43 0x00 0x0C 0x01 0x04 0x00 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave (slave0~slave3) would be\n①0xA0 0x43 0x00 0x0C 0x00 0x04 ID 0x02 0x29 0x54 0x93 0x5B 0x00 0x0A 0x00 0x64\n②0xA0 0xE1 0x00 0x00\nMethod2:\nThe command sequence issued by the master would be\n①0xA0 0x1A 0x00 0x01 0x01\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 0x00\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nThe command sequence issued by each slave would be\n①0xA0 0x1A 0x00 0x01 0x00\n②0xA0 0x12 0x00 0x01 0x04\n③0xA0 0x14 0x00 0x01 ID (different slave ID)\n④0xA0 0x18 0x00 0x01 0x02\n⑤0xA0 0x16 0x00 0x04 0x29 0x54 0x93 0x5B\n⑥0xA0 0x1C 0x00 0x02 0x00 0x0A\n⑦0xA0 0x1E 0x00 0x02 0x00 0x64\n⑧0xA0 0xE1 0x00 0x00\nIn method2, the order of the command sequence is not mandatory. However, the command 0xA014 should be issued after 0xA012 and the reset command must be the final one.\n"}]