<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>InPlay Doc</title><link>/</link><description>Recent content on InPlay Doc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>InPlay Inc</copyright><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>NanoSync Timer Guide</title><link>/docs/in6xxe/user-guides/nanosync-technology/advanced-timer-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/nanosync-technology/advanced-timer-guide.html</guid><description>NanoSync Timer Guide # Introduction # The NanoSync timers(Advanced Timer) are capable of capturing the times of multiple real-time triggers or events simultaneously. The NanoSync timers can be also used as trigger sources for the NanoSync engine(Trigger Handler). If the current time of a NanoSync timer equals to the programmed target time (called emit time), a trigger (We also call the trigger from SyncTimer as an emit) happens. Each SyncTimer supports up to 10 emit time target.</description></item><item><title>Debug Reference</title><link>/docs/in6xxe/examples-and-use-case/debug-reference.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/debug-reference.html</guid><description>Debug Reference # Configuration and Connection during Debug # To connect with the IN628E, we should use a terminal emulator with following setting,
Port: according to your device.
Baud Rate: 115200.
Data bits: 8.
Stop bits: 1.
Parity: None.
Flow control: None.
UART Tx Pin: default is GPIO_2_1.
UART Rx Pin: default is GPIO_2_7.</description></item><item><title/><link>/docs/in6xx/getting-started/testing/rtt-viewer-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/testing/rtt-viewer-guide.html</guid><description>RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection.
Configuration # Install J-Link # Should install in-dev\tools\ InPlayToolsSetup.exe first, get more information in JFlash Programming Guide</description></item><item><title/><link>/docs/in6xxe/getting-started/testing/rtt-viewer-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/testing/rtt-viewer-guide.html</guid><description>RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:
Terminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\tools\ InPlayToolsSetup.</description></item><item><title/><link>/docs/solutions/find-my/find-my-sdk-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/find-my/find-my-sdk-guide.html</guid><description>InPlay Find My SDK Guide # Overview # The IN610 Find My SDK is compliant with the most recent versions of both Apple’s Find My Network Accessory Specification and Google’s Find My Device Network Accessory Specification. This guide provides detailed instructions for configuring, compiling, and installing the IN610 Find My SDK to implement an IN610-based Find My Network Accessory. A typical hardware block diagram for a Find My accessory is as below:</description></item><item><title/><link>/docs/solutions/modbus/wireless-modbus-demo-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/modbus/wireless-modbus-demo-guide.html</guid><description>Wireless Modbus Demo Guide # Demo Connections # This guide demonstrates connecting the Wireless Modbus Module, featuring a port with four pins: Vin, GND, A, and B.
Likewise, the Sensor and Relay devices offer one or more similar ports, each with pins designated as A, B, GND, and VCC. The &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo; pins facilitate RS485 connections, while VCC and GND pins cater to power connections, requiring a power supply voltage of 5V or greater.</description></item><item><title/><link>/docs/solutions/modbus/wireless-modbus-module.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/modbus/wireless-modbus-module.html</guid><description>Introduction to the Wireless Modbus Module # Overview of the Modbus Protocol # Modbus is an application-layer messaging protocol, designed in 1979 by Modicon, which facilitates master/slave interaction between devices. A de facto communication standard in industrial electronics, it has the following features:
Master-Slave Architecture: One master device issues commands to one or more slave devices that respond in kind. Data Representation: Modbus categorizes data as either coils (binary) or registers (numeric), offering diverse data manipulation capabilities.</description></item><item><title>ADC Guide</title><link>/docs/in6xxe/user-guides/driver-integration/adc-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/adc-guide.html</guid><description>ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.
Key Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.</description></item><item><title>ADC Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/adc-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/adc-sample.html</guid><description>ADC Sample # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.</description></item><item><title>AES Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/aes-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/aes-sample.html</guid><description>AES Sample # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.
AES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted.</description></item><item><title>Antenna Diversity</title><link>/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/antenna-diversity.html</guid><description>Antenna Diversity # Overview # The antenna diversity engine supports signal RSSI evaluation and antenna switching, and it supports both dual and 4 antennas. Signal evaluation and antenna switching are performed in the background by the chip&amp;rsquo;s hardware modules.
API # initialization. # int hal_ana_diversity_init(uint8_t num_ants, uint8_t frz_time, uint32_t agc_stable_time);
void hal_ann_2diversity_gpio25_invgpio00_sw_init(void);
void hal_ann_4diversity_gpio25_gpio26_sw_init(void); Example of Dual Antenna # int main(void)
{
int res;
uint8_t tx_buf[16];
sdr_mstr_scan_t scan_cfg;
hal_global_post_init();
PRINTD(DBG_TRACE, &amp;#34;%s %s\r\n&amp;#34;, __DATE__, __TIME__);
PRINTD(DBG_TRACE, &amp;#34;CHIP ID = %08X\r\n&amp;#34;, chip_get_id());
hal_ana_diversity_init(2, 40, 40); hal_ann_2diversity_gpio25_invgpio00_sw_init();
res = in_sdr_init();
if (SDR_ERR_OK !</description></item><item><title>AOA Antenna Guide</title><link>/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/aoa-antenna.html</guid><description>AOA Antenna # Overview # AOA Antenna engine supports antenna switching and IQ capture,as shown in the following Figure.AOA Antenna engine supports IQ capture for constant tone inside the payload and attached to the packet after CRC.
Below are some key features of the AoA antenna switching IQ capture engine:
Programmable SYNC address (preamble is not programmable) Programmable channel index and frequency relationship The enable/disable of whitening is programmable (the whitening sequence is not programmable, it is decided by the channel index) Support up to 256 antenna patterns.</description></item><item><title>BLE advertising Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-advertising-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-advertising-sample.html</guid><description>BLE Advertising Sample # Overview # Bluetooth advertising is based on the transmission of advertising packets. An advertising packet is a small amount of data that contains device identifiers and other relevant information. The transmission of advertising packets is connectionless, meaning that it does not require pairing or connection operations before establishing a Bluetooth connection.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_adv_conn in-dev/proj/BLE/proj_ble_adv_conn Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>BLE GATT Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-gatt-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-gatt-sample.html</guid><description>BLE GATT Sample # Overview # GATT (Generic Attribute Profile) is a protocol introduced in Bluetooth that defines the communication rules between Bluetooth devices. It enables different types of Bluetooth devices to communicate and exchange data efficiently, particularly in Bluetooth Low Energy (BLE) devices such as smart bracelets, watches, and health monitoring devices.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_gatt_service&amp;amp;proj_ble_gatt_write in-dev/proj/BLE/proj_ble_gatt_service&amp;amp;proj_ble_gatt_write Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>BLE Initiation Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-initiation-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-initiation-sample.html</guid><description>Ble Initiation Sample # Overview # The Bluetooth connection initiation mode refers to the method utilized by a Bluetooth device to proactively initiate a connection with other devices. Within Bluetooth communication, there are typically two connection modes: Central and Peripheral. The Central mode represents the party that takes the initiative in establishing the connection, whereas the Peripheral mode signifies the party that passively accepts the connection.
Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>BLE Keyboard Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-keyboard-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-keyboard-sample.html</guid><description>BLE Keyboard Sample # Overview # Bluetooth is widely used in wireless mouse and keyboard, this is an example for chip to plays a role of keyboard using bluetooth.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_Keyboard in-dev/proj/BLE_no_os/proj_ble_Keyboard Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.</description></item><item><title>BLE Scan Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-scan-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-scan-sample.html</guid><description>Bluetooth Scan Sample # Overview # In Bluetooth Low Energy (BLE), scanning is the process where a BLE central device (such as a smartphone or a BLE-enabled gateway) actively searches and listens for advertising packets from nearby BLE peripheral devices. The scanning process allows the central device to discover and connect to nearby peripherals.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_scan in-dev/proj/BLE/proj_ble_scan Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>BLE Transparent Transmission Sample</title><link>/docs/in6xxe/examples-and-use-case/ble/ble-transparent-transmission-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/ble/ble-transparent-transmission-sample.html</guid><description>BLE Transparent Transmission Sample # Overview # In Bluetooth data transparent transmission, the sending device packages the raw data into Bluetooth data packets and sends them to the receiving device through the Bluetooth connection. After receiving these data packets, the receiving device can directly read and parse the raw data without any decoding or processing.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_trx_clt&amp;amp;proj_ble_trx_svc in-dev/proj/BLE/proj_ble_trx_clt&amp;amp;proj_ble_trx_svc Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>BLE5.0 AT Command Set</title><link>/docs/in6xxe/protocols-reference/ble/inplay-ble5.0-at-command-set.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/protocols-reference/ble/inplay-ble5.0-at-command-set.html</guid><description>Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.
IN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.</description></item><item><title>Counter Guide</title><link>/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/counter-development-guide.html</guid><description>Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.
The 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.</description></item><item><title>CRC Guide</title><link>/docs/in6xxe/user-guides/driver-integration/crc-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/crc-guide.html</guid><description>CRC Guide # Overview # CRC (Cyclic Redundancy Check) is a widely used error-detecting code in digital communication networks and storage devices. It is a mathematical algorithm that calculates a checksum based on the data being transmitted or stored, which can then be used to detect errors during transmission or storage.
Features # Support calculate fix length data or variable length data Support DMA(need occupy one I2C DMA channel) Support configuare parameters such as polynomial selection, initial value, XOR output and so on.</description></item><item><title>Debug Guide</title><link>/docs/in6xx/getting-started/testing/debug-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/testing/debug-guide.html</guid><description>Debug Guide # Introduction # Arm Keil MDK (Microcontroller Development Kit) provides robust debugging capabilities that are essential for efficient software development targeting Arm Cortex-M based microcontrollers. This document provides instructions on using the debugging features in Keil.
Debug Step: # Enter debugging and run to main funtion # Enter debug mode, run program from flash to main function.
Open project, double click &amp;ldquo;proj_ble_lp.uvmpw&amp;rdquo; in &amp;ldquo;SDK\in-dev\proj\proj_ble_find_my\build\mdk&amp;rdquo;. Click project option button, select &amp;ldquo;J-Link&amp;rdquo; in &amp;ldquo;Debug&amp;rdquo; page.</description></item><item><title>Debug Guide</title><link>/docs/in6xxe/getting-started/testing/debug-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/testing/debug-guide.html</guid><description>Debug Guide # Introduction # This document provides a guide on how to use keil to debug project to the IN6XXE chip.
Debug Step: # Enter Debugging # Copy jlink_flash_setup.ini file in in-dev\proj\common\JLINK to project directory
Edit .ini file with following steps (1) change the setting in jlink_flash_setup.ini according to the in_config.h. (2)change the setup mode according to in_config.h Follow these steps to select the .ini file. Click the debug button.</description></item><item><title>ECC Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/ecc-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/ecc-sample.html</guid><description>ECC Sample # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.
Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.</description></item><item><title>GATT Programming Guide</title><link>/docs/in6xx/protocol-reference/ble/gatt-programming-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/protocol-reference/ble/gatt-programming-guide.html</guid><description>GATT Programming Guide # Overview # GATT is a standard BLE protocol, which is based on the ATT protocol. The ATT protocol describes the structure and the access method of Attribute, the basic data unit of BLE. ATT is equivalent to a base class, while Generic Attribute Profile (GATT) is a derived class. It reorganizes attributes and constructs the structure of data access in the application layer - Service/Characteristic. It defines the methods and mechanisms of the data structures including Discover, Read, Write, and Notify/Indicate.</description></item><item><title>GPIO Guide</title><link>/docs/in6xxe/user-guides/driver-integration/gpio-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/gpio-guide.html</guid><description>GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:
Digital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to &amp;ldquo;proj_drv_gpio&amp;rdquo;.
Configure GPIO to output and output high/low:</description></item><item><title>GPIO Interrupt Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-interrupt-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-interrupt-sample.html</guid><description>GPIO Interrupt Sample # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.</description></item><item><title>GPIO Reset Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-reset-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-reset-sample.html</guid><description>GPIO Reset Sample # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.</description></item><item><title>GPIO Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-sample.html</guid><description>GPIO Sample # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.
In this example, we can achieve basic input and output functionality using GPIO.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.</description></item><item><title>GPIO Wake Interrupt Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-interrupt-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-interrupt-sample.html</guid><description>GPIO Wake Interrupt Sample # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.</description></item><item><title>GPIO Wake Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/gpio-wake-sample.html</guid><description>GPIO Wake Sample # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.</description></item><item><title>HCI Command</title><link>/docs/in6xx/getting-started/testing/hci_command.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/testing/hci_command.html</guid><description>HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.
HCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters.</description></item><item><title>HCI Command</title><link>/docs/in6xxe/getting-started/testing/hci_command.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/testing/hci_command.html</guid><description>HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.
HCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters.</description></item><item><title>HCI Sample</title><link>/docs/in6xxe/examples-and-use-case/misc/hci-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/misc/hci-sample.html</guid><description>HCI Sample # Overview # HCI, as the Host Controller Interface, is a crucial component of the Bluetooth protocol stack. This interface lies within the hardware section of the Bluetooth communication module, providing a standardized communication mechanism between the host and controller elements of a Bluetooth device.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ate_test_hci proj_ate_test_hci_no_os in-dev/proj/misc/proj_ate_test_hci in-dev/proj/misc/proj_ate_test_hci_no_os Configuration # #define EXT_PA 0 ///&amp;lt; 0: diable external PA, 1: enable external PA Define if use PA control.</description></item><item><title>I2C Communication</title><link>/docs/in6xxe/user-guides/driver-integration/i2c-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/i2c-guide.html</guid><description>I2C Guide # Overview # I2C (Inter-Integrated Circuit) is a simple serial communication protocol commonly used to connect microcontrollers with various electronic devices such as sensors and memories. It utilizes only two wires: a clock line (SCL) for synchronizing data transfer and a data line (SDA) for sending and receiving data. Key Features # Multi-Master Capability: Multiple masters can be connected to the same bus and communicate with different slave devices.</description></item><item><title>I2C Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/i2c-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/i2c-sample.html</guid><description>I2C Sample # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.
This routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication.</description></item><item><title>InPlay Programmer Guide</title><link>/docs/in6xx/getting-started/download/in_prog-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/download/in_prog-guide.html</guid><description>InPlay Programmer Guide # Introduction # The InPlay Programmer is a graphical chip configuration and programming tool for the PC that enables developers to configure and download programs to target boards using InPlay chips via UART. Developers should refer to the chip datasheet to thoroughly understand the configuration options based on their specific application requirements.
The main window of the GUI tool, as shown in Figure 1, is organized into five area:</description></item><item><title>Introduction</title><link>/docs/solutions/multiconnnet/introduction.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/multiconnnet/introduction.html</guid><description>Introduction to MultiConnNet System # The MultiConnNet is Inplay&amp;rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.
The system is comprised of two primary components: the gateway module and the node module.
Key Features # Star Topology: The system employs a star connection model, with the gateway serving as the central node for bidirectional communication with multiple node modules, facilitating management and data transmission.</description></item><item><title>Introduction to IN6XXE DK</title><link>/docs/in6xxe/dk/introduction-to-in6xxe-dk.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/dk/introduction-to-in6xxe-dk.html</guid><description>Overview # IN6XXE DK is a development board for IN6XXE series chips. You can download the schematics:
SCH_IN612LE-QFN48-DK-ver1.1
SCH_IN612LE-QFN56-DK-ver1.1
Hardware description # Component Description 1 RF Connector 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.</description></item><item><title>JFlash Programming</title><link>/docs/in6xx/getting-started/download/jflash-download-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/download/jflash-download-guide.html</guid><description>JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XX chip.
J-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.
Prerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended).</description></item><item><title>JFlash Programming</title><link>/docs/in6xxe/getting-started/download/jflash-download-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/download/jflash-download-guide.html</guid><description>JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.
J-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.
Prerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended).</description></item><item><title>Keyboard Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/keyboard-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/keyboard-sample.html</guid><description>Keyboard Sample # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.</description></item><item><title>Module Instruction Set</title><link>/docs/solutions/multiconnnet/command-set.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/multiconnnet/command-set.html</guid><description>MultiConnNet Module Instruction Set # The MultiConnNet is Inplay&amp;rsquo;s proprietary Multi-Connection Private Network system. It is a 2.4GHz wireless communication network based on a private SDR (Software Defined Radio) protocol, utilizing a one-to-many star connection topology.
The system is comprised of two primary components: the Gateway module and the Node module. The module is connected to the HOST via UART interface, and this instruction set defines the data packet format between the module and the HOST.</description></item><item><title>MP Tool Guide</title><link>/docs/in6xx/getting-started/download/mp-tool-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/download/mp-tool-guide.html</guid><description>MP Tool Guide # Introduction # The MP Tool is a tool for mass production downloading and testing, capable of downloading the main program and token, as well as testing RF performance. Please refer to this document for details.</description></item><item><title>NanoSync Engine Guide</title><link>/docs/in6xxe/user-guides/nanosync-technology/trigger-handler-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/nanosync-technology/trigger-handler-guide.html</guid><description>NanoSync Engine Guide # Introduction # NanoSync engine(trigger handler block) which can be used to perform many real-time events or tasks without the CPU’s intervention.
The NanoSync engine operates based on triggers and handlers. When a trigger (also called an event) happens, a handler will be invoked. A handler consists of a sequence of hardware actions (also called hardware tasks), which can be automatically executed by the hardware without the CPU intervention.</description></item><item><title>PWM Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/pwm-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/pwm-sample.html</guid><description>PWM Sample # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.
This routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.</description></item><item><title>QDEC Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/qdec-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/qdec-sample.html</guid><description>QDEC Sample # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.
This routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).</description></item><item><title>Quick Start</title><link>/docs/in6xx/getting-started/installation/quick-start.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xx/getting-started/installation/quick-start.html</guid><description>Quick Start Guide # Introduction # This document provides a guide as following:
Install development tools Use the configuration tool Build &amp;ldquo;proj_ble_find_my&amp;rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).
Download and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).
Install InPlayInc.DeviceFamilyPack. Double click the InPlayInc.</description></item><item><title>Quick Start</title><link>/docs/in6xxe/getting-started/installation/quick-start.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/installation/quick-start.html</guid><description>Quick Start Guide # Introduction # This document provides a guide as following:
Install development tools Use the configuration tool Build &amp;ldquo;proj_ble_adv_conn&amp;rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).
Download and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).
Install InPlayInc.DeviceFamilyPack. Double click the InPlayInc.</description></item><item><title>Quick Start with GCC</title><link>/docs/in6xxe/getting-started/installation/quick-start-with-gcc.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/installation/quick-start-with-gcc.html</guid><description>Quick Start Guide with GCC # Introduction # This document introduce how to use GCC for software development.
Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install Arm GNU Toolchain (version &amp;ldquo;arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi&amp;rdquo; is recommended).
Install Make
sudo apt-get update sudo apt-get install build-essential Generate configuration File (optional) # Demo projects are in &amp;ldquo;SDK/in-dev/proj&amp;rdquo;. Each project has a configuration file named &amp;ldquo;in_config.h&amp;rdquo;. This file is located in the &amp;ldquo;inc&amp;rdquo; directory of the project.</description></item><item><title>Run Zephyr on IN6XXE</title><link>/docs/in6xxe/getting-started/installation/run-zephyr-on-in6xxe.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/installation/run-zephyr-on-in6xxe.html</guid><description>Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.
Inplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.
Setup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows.</description></item><item><title>SDR 1 to n Sample</title><link>/docs/in6xxe/examples-and-use-case/sdr/sdr-1-master-to-multiple-slave-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/sdr/sdr-1-master-to-multiple-slave-sample.html</guid><description>SDR 1 to n Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. In SDR broadcast systems, signal processing and transmission are both accomplished through software. This allows SDR broadcast equipment to support multiple modulation methods, coding techniques, and transmission protocols, thus achieving compatibility with various broadcast standards. Whether it&amp;rsquo;s the high-quality audio transmission of high-definition broadcasting or the extensive coverage of digital audio broadcasting, SDR delivers excellent performance.</description></item><item><title>SDR Broadcast Sample</title><link>/docs/in6xxe/examples-and-use-case/sdr/sdr-broadcast-sample-.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/sdr/sdr-broadcast-sample-.html</guid><description>SDR Broadcast Sample # Overview # SDR (Software Defined Radio) exhibits significant advantages in communication systems, especially in building flexible and multifunctional wireless communication networks. The Master device typically plays a central role in control and management, while multiple Slave devices serve as nodes performing specific communication tasks.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_SDR_Broadcast_Mode_Master proj_SDR_Broadcast_Mode_Slave in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Master in-dev/proj/SDR/proj_SDR_Broadcast_Mode_Slave Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title>SMULL Command Set</title><link>/docs/in6xxe/protocols-reference/smull/inplay-smull-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/protocols-reference/smull/inplay-smull-development-guide.html</guid><description>Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps.</description></item><item><title>SMULL Command Set</title><link>/docs/solutions/smull/inplay-smull-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/smull/inplay-smull-development-guide.html</guid><description>Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps.</description></item><item><title>SPI Communication</title><link>/docs/in6xxe/user-guides/driver-integration/spi-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/spi-guide.html</guid><description>SPI Guide # Overview # SPI, which stands for Serial Peripheral Interface, is a high-speed, full-duplex, synchronous communication bus that allows data transmission between a microcontroller and peripheral devices. It utilizes a master-slave model, with the master device controlling a set of slave devices. SPI requires four signal lines:
SCLK for synchronization
MOSI for data transmission from master to slave
MISO for data transmission from slave to master
SSN for selecting the slave device to communicate with.</description></item><item><title>SPI Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/spi-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/spi-sample.html</guid><description>SPI Sample # Overview # SPI (Serial Peripheral Interface) communication is a synchronous serial transmission specification typically used for communication between microprocessing control units (MCUs) and peripheral devices. This communication method is characterized by its high speed, full-duplex, and synchronous nature, achieving data transmission through four wires (MISO, MOSI, SCLK, CS/SS) on chip pins.
SPI communication consists of a master device and one or more slave devices. The master device initiates synchronized communication with the slave devices to complete data exchange.</description></item><item><title>Timer Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/timer-sample.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/timer-sample.html</guid><description>Timer Sample # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.
This routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.</description></item><item><title>Trigger Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/trigger-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/trigger-example-guide.html</guid><description>Trigger Sample # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger.</description></item><item><title>UART Communication</title><link>/docs/in6xxe/user-guides/driver-integration/uart-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/user-guides/driver-integration/uart-guide.html</guid><description>UART Guide # Overview # The Universal Asynchronous Receiver-Transmitter (UART) is a hardware communication protocol that enables serial data transmission between devices. It is widely used for communication between microcontrollers and various peripherals, such as computers, sensors, and other embedded systems.
Initialization # Before using the UART interface, it needs to be properly initialized. Configure the UART settings according to the uart_init_t struct:
uart_init_t init = {0}; init.baud_rate = 115200; /**&amp;lt; Baud rate (e.</description></item><item><title>UART Sample</title><link>/docs/in6xxe/examples-and-use-case/driver-examples/uart-sample-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/examples-and-use-case/driver-examples/uart-sample-guide.html</guid><description>UART Sample # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.
In this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.</description></item><item><title>User Guild</title><link>/docs/solutions/multiconnnet/user-guild.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/multiconnnet/user-guild.html</guid><description>MultiConnNet User Guild # Proper module configuration is essential before the MultiConnNet network can operate normally. However, it is necessary to understand the essential information beforehand.
Boot Mode: The module can enter Boot mode when GPIO_0_4 is connected to GND during power-up or reset, allowing for firmware flashing, storage resetting, and other operations.
Interactive Interface: By default, UART1 is used as interface between HOST and module, with GPIO_2_1 and GPIO_2_7 as TX and RX function, 921600 baud rate, 8N1.</description></item><item><title>Wireless Communication Protocol</title><link>/docs/solutions/stellar/stellar-gateway-wireless-communication-protocol-implementation-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/solutions/stellar/stellar-gateway-wireless-communication-protocol-implementation-guide.html</guid><description>Stellar Gateway Wireless Communication Protocol Implementation Guide # Purpose # This guide offers a comprehensive overview of the Stellar Gateway Wireless Communication Protocol, focusing on its practical implementation. Covering the design, functional operation, command structure, and safety precautions, it is tailored for developers, system integrators, and technical professionals who seek a deep understanding of how to effectively employ and optimize devices using the Stella Gateway Wireless Protocol.
Definition Glossary # BLE (Bluetooth Low Energy): A power-efficient version of the classic Bluetooth wireless technology.</description></item></channel></rss>