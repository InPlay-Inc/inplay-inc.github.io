<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>InPlay Doc</title><link>/</link><description>Recent content on InPlay Doc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>InPlay Inc</copyright><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>/docs/in6xxe/getting-started/rtt-viewer-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/rtt-viewer-guide.html</guid><description>RTT Viewer Guide # Introduction # J-Link RTT Viewer is a Windows GUI application that uses RTT functionality on the debugging host. RTT Viewer can be used independently, opening its own connection to the J-Link and connecting in parallel to the target of the ongoing debugging session or alternatively to it using an existing J-Link connection. The RTT Viewer supports the main functions of RTT:
Terminal output on channel Sending text input to channel Up to 16 virtual terminals with only one target channel Controlling text output Recording data on channel Configuration # Install Jlink # Should setup in-dev\tools\ InPlayToolsSetup.</description></item><item><title/><link>/docs/in6xxe/samples/adc-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/adc-example-guide.html</guid><description>ADC Example Guide # Overview # ADC, short for Analog-to-Digital Converter, is a key component in embedded systems. It is used to convert an analog signal, such as a voltage or current, into a digital value that can be processed by the microcontroller or processor in the embedded system. This allows the system to interact with the physical world by taking measurements from sensors or other analog devices. The accuracy and resolution of the ADC are important factors in determining the overall performance of the embedded system.</description></item><item><title/><link>/docs/in6xxe/samples/aes-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/aes-example-guide.html</guid><description>AES Example Guide # Overview # AES encryption, also known as Advanced Encryption Standard, is a widely used encryption algorithm. It is considered to be one of the most secure and advanced encryption algorithms in the world.
AES encryption is a symmetric encryption algorithm based on a key. It uses 128-bit, 192-bit or 256-bit keys to encrypt data. This means that as long as the key is known, the encrypted data can be decrypted.</description></item><item><title/><link>/docs/in6xxe/samples/ble-advertising-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/ble-advertising-example-guide.html</guid><description>Bluetooth Advertising Example Guide # Overview # Bluetooth advertising is based on the transmission of advertising packets. An advertising packet is a small amount of data that contains device identifiers and other relevant information. The transmission of advertising packets is connectionless, meaning that it does not require pairing or connection operations before establishing a Bluetooth connection.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_adv_conn in-dev/proj/BLE/proj_ble_adv_conn Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title/><link>/docs/in6xxe/samples/ble-initiation-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/ble-initiation-example-guide.html</guid><description>Ble initiation Routine Guide # Overview # The Bluetooth connection initiation mode refers to the method utilized by a Bluetooth device to proactively initiate a connection with other devices. Within Bluetooth communication, there are typically two connection modes: Central and Peripheral. The Central mode represents the party that takes the initiative in establishing the connection, whereas the Peripheral mode signifies the party that passively accepts the connection.
Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title/><link>/docs/in6xxe/samples/ble-scan-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/ble-scan-example-guide.html</guid><description>Bluetooth Scan Example Guide # Overview # In Bluetooth Low Energy (BLE), scanning is the process where a BLE central device (such as a smartphone or a BLE-enabled gateway) actively searches and listens for advertising packets from nearby BLE peripheral devices. The scanning process allows the central device to discover and connect to nearby peripherals.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_scan in-dev/proj/BLE/proj_ble_scan Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title/><link>/docs/in6xxe/samples/ble-transparent-transmission-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/ble-transparent-transmission-example-guide.html</guid><description>BLE Transparent Transmission Guide # Overview # In Bluetooth data transparent transmission, the sending device packages the raw data into Bluetooth data packets and sends them to the receiving device through the Bluetooth connection. After receiving these data packets, the receiving device can directly read and parse the raw data without any decoding or processing.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_ble_trx_clt&amp;amp;proj_ble_trx_svc in-dev/proj/BLE/proj_ble_trx_clt&amp;amp;proj_ble_trx_svc Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc.</description></item><item><title/><link>/docs/in6xxe/samples/debug-routine-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/debug-routine-guide.html</guid><description>Debug reference # Configuration and Connection during Debug # To connect with the IN628E, we should use a terminal emulator with following setting,
Port: according to your device.
Baud Rate: 115200.
Data bits: 8.
Stop bits: 1.
Parity: None.
Flow control: None.
UART Tx Pin: default is GPIO_2_1.
UART Rx Pin: default is GPIO_2_7.</description></item><item><title/><link>/docs/in6xxe/samples/ecc-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/ecc-example-guide.html</guid><description>ECC Guide # Overview # ECC (Error Correction Code) is an encoding technology used for detecting and correcting errors in data transmission. It is currently one of the more advanced methods for checking and correcting memory errors, making computer systems safer and more stable during operation.
Building # To build the sample with keil, follow the steps listed on the quick start page in the IN6xxE of Inplay Doc. You may be able to solve questions on that webpage.</description></item><item><title/><link>/docs/in6xxe/samples/gpio-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/gpio-example-guide.html</guid><description>GPIO Example Guide # Overview # GPIO is one of the essential hardware interfaces in microcontrollers. It enables beginners to better understand the hardware structure and basic principles of microcontrollers.
In this example, we can achieve basic input and output functionality using GPIO.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio in-dev/proj/driver/proj_drv_gpio Configuration # #define LED1_PORT 2 #define LED1_PORT 8 Define the GPIO output port and pin for LED.</description></item><item><title/><link>/docs/in6xxe/samples/gpio-interrupt-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/gpio-interrupt-example-guide.html</guid><description>GPIO Interrupt Example Guide # Overview # GPIO interrupts are signals that are sent to the processor when there is a change in the state of a GPIO pin. This allows the processor to immediately respond to the change and perform a specific task or function. These interrupts are commonly used in embedded systems and microcontrollers to efficiently manage input and output devices.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_interrupt in-dev/proj/driver/proj_drv_gpio_interrupt Configuration # #define GPIO_INTERRUPT_PORT 1 #define GPIO_INTERRUPT_PIN 2 Define the port and pin for testing GPIO interrupts.</description></item><item><title/><link>/docs/in6xxe/samples/gpio-reset-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/gpio-reset-example-guide.html</guid><description>GPIO Reset Example Guide # Overview # Triggering chip reset through GPIO involves controlling a GPIO pin to perform a hardware reset on the chip. When the state of the GPIO pin changes, it triggers a reset on the chip, restoring it to its initial state. This method is commonly used in embedded systems for system rebooting, fault recovery, or initialization under specific conditions. By configuring and changing the state of the GPIO pin, the chip reset can be flexibly controlled and managed.</description></item><item><title/><link>/docs/in6xxe/samples/gpio-wake-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/gpio-wake-example-guide.html</guid><description>GPIO Wake Example Guide # Overview # The GPIO wake-up feature is a functionality that allows a chip to be awakened from a low-power mode by configuring a GPIO pin. When certain predetermined wake-up conditions are met, a change in the state of the GPIO pin triggers the chip to transition from a sleep or idle state to normal operation.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_gpio_wuk in-dev/proj/driver/proj_drv_gpio_wuk Configuration # #define PORT 1 // wake up port #define PIN 3 // wake up pin Define the GPIO reset port and pin.</description></item><item><title/><link>/docs/in6xxe/samples/gpio-wake-up-interrupt-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/gpio-wake-up-interrupt-example-guide.html</guid><description>GPIO Wake Interrupt Example Guide # Overview # GPIO interrupt and wake-up are two important features in embedded systems. GPIO interrupt allows a microcontroller to respond to a change in the state of a GPIO pin without continuously checking it, reducing power consumption. Wake-up allows a sleeping microcontroller to quickly respond to an external event, such as a GPIO pin change, without consuming continuous power. When used together, these features improve power efficiency in applications such as battery-powered devices and IoT.</description></item><item><title/><link>/docs/in6xxe/samples/i2c-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/i2c-example-guide.html</guid><description>I2C Routine Guide # Overview # I2C (Inter-Integrated Circuit) is a common embedded communication protocol that allows high-speed bidirectional communication between microcontrollers and other devices. The bus is the physical channel for I2C communication and consists of two lines: a serial clock line (SCL) for transmitting clock signals and a serial data line (SDA) for transmitting data.
This routine demonstrates the sending and receiving of data between I2C Master and I2C Slave using I2C communication.</description></item><item><title/><link>/docs/in6xxe/samples/keyboard-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/keyboard-example-guide.html</guid><description>Keyboard Routine Guide # Overview # A matrix keyboard is a type of keyboard that uses a grid of buttons or keys arranged in rows and columns. Each key is assigned a unique position within the grid, identified by the intersection of its row and column. When a key is pressed, the corresponding row and column are activated, and the microcontroller can detect the specific key based on the activated row and column.</description></item><item><title/><link>/docs/in6xxe/samples/pwm-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/pwm-example-guide.html</guid><description>PWM Routine Guide # Overview # PWM (Pulse Width Modulation) is a technique used to control the output voltage or current by adjusting the ratio of high and low levels of a signal. The higher the ratio of high level time to the entire period, the higher the output voltage or current.
This routine demonstrates the generation of square wave signals using PWM. It can generate square wave signals with a specific period and duty cycle based on the selected PORT and PIN.</description></item><item><title/><link>/docs/in6xxe/samples/qdec-routine-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/qdec-routine-guide.html</guid><description>QDEC Routine Guide # Overview # QDEC, short for Quantization Decoder, is a tool used to decode quantized data. It is commonly used in embedded systems to decode quantized data for implementing specific functionalities on microcontrollers.
This routine demonstrates the counting function of a rotary encoder using qdec. It can count based on the events and direction of the rotary encoder (increasing the count for a forward rotation and decreasing the count for a reverse rotation).</description></item><item><title/><link>/docs/in6xxe/samples/timer-routine-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/timer-routine-guide.html</guid><description>TIMER Routine Guide # Overview # TIMER is a type of timer that allows timing operations within a microcontroller. By setting the count value and timing period of the TIMER, we can control the timing operations of the microcontroller, enabling features such as timed tasks and timestamp generation.
This routine demonstrates the functionality of configuring and handling callbacks using TIMER. It provides a brief overview of the usage of various functions, including TIMER configuration and functionality.</description></item><item><title/><link>/docs/in6xxe/samples/trigger-example-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/trigger-example-guide.html</guid><description>Trigger Routine Guide # Overview # Trigger is a mechanism that initiates specific operations or events. It can be implemented through hardware or software, converting external signals or events into actionable operations, such as activating sensors, controlling tasks, or initiating communication. Triggers are essential for the system to respond to external conditions and perform necessary actions.
Hardware Requirements # Hardware Project Name Project Path IN628E DK proj_drv_trig in-dev/proj/driver/proj_drv_trig Configuration # #define TRIG_QUEUE TRIG_HIGH_PRI_QUEUE //TRIG_LOW_PRI_QUEUE, TRIG_MID_PRI_QUEUE, TRIG_HIGH_PRI_QUEUE define the priority of trigger.</description></item><item><title/><link>/docs/in6xxe/samples/uart-routine-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/samples/uart-routine-guide.html</guid><description>UART Routine Guide # Overview # UART is a common serial communication protocol used for serial communication between microcontrollers and other devices. UART communication is a simple and effective method of communication, which can be used for data transmission between microcontrollers and sensors or for debugging and configuration between microcontrollers and other devices.
In this routine, we can achieve sending data, receiving data, and RTS/CTS flow control through UART APIs.</description></item><item><title>ADC Guide</title><link>/docs/in6xxe/development-guide/adc-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/development-guide/adc-guide.html</guid><description>ADC Guide # Overview # The ADC (Analog-to-Digital Converter) is a crucial component in electronic systems that facilitates the conversion of analog signals into digital values. This process is essential for interfacing with digital systems, microcontrollers, and processors, allowing them to process and interpret real-world analog data.
Key Features # Precision # The ADC operates with a precision of 12 bits, providing a fine resolution for accurate signal representation.</description></item><item><title>BLE5.0 AT Command Set</title><link>/docs/in6xxe/getting-started/inplay-ble5.0-at-command-set.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/inplay-ble5.0-at-command-set.html</guid><description>Inplay BLE 5.0 AT Command Set # INTRODUCTION # Inplay IN6xx BLE module is a standard Bluetooth Low Energy (BLE) 5.0 certified RF module. It introduces a private service as interface of data streaming between two BLE devices transparently.
IN6xx BLE module provides the control interface based on ASCII commands, say AT commands. They are used to configure parameters, retrieve module state, control actions of module, etc. All configuration changes can be optionally remained in Non-Volatile Memory (Flash) and survive the following power cycle.</description></item><item><title>Counter Guide</title><link>/docs/in6xxe/development-guide/counter-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/development-guide/counter-development-guide.html</guid><description>Counter Guide # Introduction # The counter block contains 4 32-bit identical counters. Each counter can be independently programmed to perform a wide range of functions including frequency measurement, event counting, interval measurement, pulse generation, delay timing and pulse width modulation.
The 6XX series chips have 4 built-in counter modules, corresponding to these 8 pins (GPIO port 2). The counter module can be used to achieve functions like PWM, Timer, IrDa, and 7816.</description></item><item><title>GPIO Guide</title><link>/docs/in6xxe/development-guide/gpio-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/development-guide/gpio-guide.html</guid><description>GPIO Guide # Overview # The GPIO (General Purpose Input/Output) is organized into five ports. And there are two types of GPIOs: mixed-signal GPIOs and digital GPIOs:
Digital GPIO: Port: Port 0, port 1, port 3 and port 4 Can NOT be used as sensor ADC input Mixed GPIO: Port: Port 2 Can be used as sensor ADC input Output / Input # Refer to &amp;ldquo;proj_drv_gpio&amp;rdquo;.
Configure GPIO to output and output high/low:</description></item><item><title>HCI Command</title><link>/docs/in6xxe/getting-started/hci_command.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/hci_command.html</guid><description>HCI Command # Introduction to BLE HCI Commands # BLE HCI commands are standardized instructions exchanged between the host and the Bluetooth controller to manage and configure Bluetooth communication. These commands enable the host to initiate various actions, such as establishing connections, configuring parameters, and managing the overall behavior of the Bluetooth device.
HCI Command Structure # BLE HCI commands follow a specific structure, adhering to a standardized format that includes an HCI type, opcode, and parameters.</description></item><item><title>Introduction to IN6XXE DK</title><link>/docs/in6xxe/getting-started/introduction-to-in6xxe-dk.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/introduction-to-in6xxe-dk.html</guid><description>Overview # IN6XXE DK is a development board for IN6XXE series chips. The schematics can be downloaded here.
Hardware description # Component Description 1 RF Switch 2 I2C pull up R19:GPIO_0_0, R20:GPIO_0_1; R21:GPIO_0_3, R22:GPIO_0_4 3 VDDQ Jumper When programming eFuse, connect VDDQ to 3.3V 4 GPIO Test Pin GPIO pins 5 GPIO Test Hole GPIO pins 6 GND TP1,2,3,7 These test points are connected to GND 7 Power Jumper Control power supply, see Power Supply 8 Cortex_debug+ETM Debug port 9 1.</description></item><item><title>JFlash Programming</title><link>/docs/in6xxe/getting-started/jflash-download-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/jflash-download-guide.html</guid><description>JFlash Programming Guide # Introduction # This document provides a guide on how to use J-Flash to download bin file to the IN6XXE chip.
J-Flash is a part of the J-Link tool series developed by Segger, offers a reliable solution for programming Flash memory on embedded systems.
Prerequisites # J-Link Debugger hardware.Get it on Segger web site. J-Link Software and Documentation Pack installed on your host computer(Version 7.62 or later is recommended).</description></item><item><title>NanoSync Engine Guide</title><link>/docs/in6xxe/development-guide/trigger-handler-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/development-guide/trigger-handler-guide.html</guid><description>NanoSync Engine Guide # Introduction # NanoSync engine(trigger handler block) which can be used to perform many real-time events or tasks without the CPU’s intervention.
The NanoSync engine operates based on triggers and handlers. When a trigger (also called an event) happens, a handler will be invoked. A handler consists of a sequence of hardware actions (also called hardware tasks), which can be automatically executed by the hardware without the CPU intervention.</description></item><item><title>Quick Start</title><link>/docs/in6xxe/quick-start.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/quick-start.html</guid><description>Quick Start Guide # Introduction # This document provides a guide as following:
Install development tools Use the configuration tool Build &amp;ldquo;proj_ble_adv_conn&amp;rdquo; demo project Download image to DK Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install MDK-ARM Keil µVision (Version 5.21 or later is recommended).
Download and install J-Link Software and Documentation Pack(Version 7.62 or later is recommended).
Install InPlayInc.DeviceFamilyPack. Double click the InPlayInc.</description></item><item><title>Quick Start with GCC</title><link>/docs/in6xxe/getting-started/quick-start-with-gcc.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/quick-start-with-gcc.html</guid><description>Quick Start Guide with GCC # Introduction # This document introduce how to use GCC for software development.
Preparation # InPlay DK Board JLink Debugger InPlay SDK Usb cable. Install Tools # Download and install Arm GNU Toolchain (version &amp;ldquo;arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi&amp;rdquo; is recommended).
Install Make
sudo apt-get update sudo apt-get install build-essential Generate configuration File (optional) # Demo projects are in &amp;ldquo;SDK/in-dev/proj&amp;rdquo;. Each project has a configuration file named &amp;ldquo;in_config.h&amp;rdquo;. This file is located in the &amp;ldquo;inc&amp;rdquo; directory of the project.</description></item><item><title>Run Zephyr on IN6XXE</title><link>/docs/in6xxe/development-guide/run-zephyr-on-in6xxe.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/development-guide/run-zephyr-on-in6xxe.html</guid><description>Introduction # Zephyr is an open source RTOS maintained by the Linux foundation, which is designed for connected, resource-constrained embedded devices. It provides a scalable and secure platform for developing IoT and embedded applications.
Inplay has added support including BLE for Zephyr on IN6XXE chips. If you have an IN6XXE DK board(Refer to Introduction to IN6XXE DK), you can run Zephyr BLE samples on it with this guide.
Setup a Zephyr development environment under Windows # It is recommended to develop Zephyr on IN6XXE under Windows.</description></item><item><title>SMULL Command Set</title><link>/docs/in6xxe/getting-started/inplay-smull-development-guide.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/in6xxe/getting-started/inplay-smull-development-guide.html</guid><description>Inplay SMULL Command Set For Transparent Data Transmission # Introduction # IN618 is InPlay’s SMULL SoC product which features synchronous multi-node low-latency protocol (SMULL) stack with 2.4Ghz frequency band RF radio and MCU system integrated. The device incorporates an InPlay SMULL radio and subsystem that contains the RF transceiver, baseband, PHY and link layer engines.The physical layer has the digital PHY and RF transceiver that transmits and receives GFSK packets at 2Mbps.</description></item></channel></rss>